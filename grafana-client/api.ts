/* tslint:disable */
/* eslint-disable */
/**
 * Grafana HTTP API.
 * The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: hello@grafana.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * ActiveSyncStatusDTO holds the information for LDAP background Sync
 * @export
 * @interface ActiveSyncStatusDTO
 */
export interface ActiveSyncStatusDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ActiveSyncStatusDTO
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActiveSyncStatusDTO
     */
    'nextSync'?: string;
    /**
     * 
     * @type {SyncResult}
     * @memberof ActiveSyncStatusDTO
     */
    'prevSync'?: SyncResult;
    /**
     * 
     * @type {string}
     * @memberof ActiveSyncStatusDTO
     */
    'schedule'?: string;
}
/**
 * 
 * @export
 * @interface ActiveUserStats
 */
export interface ActiveUserStats {
    /**
     * 
     * @type {number}
     * @memberof ActiveUserStats
     */
    'active_admins_and_editors'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveUserStats
     */
    'active_anonymous_devices'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveUserStats
     */
    'active_users'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveUserStats
     */
    'active_viewers'?: number;
}
/**
 * 
 * @export
 * @interface AddAPIKeyCommand
 */
export interface AddAPIKeyCommand {
    /**
     * 
     * @type {string}
     * @memberof AddAPIKeyCommand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddAPIKeyCommand
     */
    'role'?: AddAPIKeyCommandRoleEnum;
    /**
     * 
     * @type {number}
     * @memberof AddAPIKeyCommand
     */
    'secondsToLive'?: number;
}

export const AddAPIKeyCommandRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type AddAPIKeyCommandRoleEnum = typeof AddAPIKeyCommandRoleEnum[keyof typeof AddAPIKeyCommandRoleEnum];

/**
 * 
 * @export
 * @interface AddDataSource200Response
 */
export interface AddDataSource200Response {
    /**
     * 
     * @type {DataSource}
     * @memberof AddDataSource200Response
     */
    'datasource': DataSource;
    /**
     * ID Identifier of the new data source.
     * @type {number}
     * @memberof AddDataSource200Response
     */
    'id': number;
    /**
     * Message Message of the deleted dashboard.
     * @type {string}
     * @memberof AddDataSource200Response
     */
    'message': string;
    /**
     * Name of the new data source.
     * @type {string}
     * @memberof AddDataSource200Response
     */
    'name': string;
}
/**
 * Also acts as api DTO
 * @export
 * @interface AddDataSourceCommand
 */
export interface AddDataSourceCommand {
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'access'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddDataSourceCommand
     */
    'basicAuth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'basicAuthUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'database'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddDataSourceCommand
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof AddDataSourceCommand
     */
    'jsonData'?: object;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AddDataSourceCommand
     */
    'secureJsonData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddDataSourceCommand
     */
    'user'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddDataSourceCommand
     */
    'withCredentials'?: boolean;
}
/**
 * 
 * @export
 * @interface AddInviteForm
 */
export interface AddInviteForm {
    /**
     * 
     * @type {string}
     * @memberof AddInviteForm
     */
    'loginOrEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddInviteForm
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddInviteForm
     */
    'role'?: AddInviteFormRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AddInviteForm
     */
    'sendEmail'?: boolean;
}

export const AddInviteFormRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type AddInviteFormRoleEnum = typeof AddInviteFormRoleEnum[keyof typeof AddInviteFormRoleEnum];

/**
 * 
 * @export
 * @interface AddOrgUserCommand
 */
export interface AddOrgUserCommand {
    /**
     * 
     * @type {string}
     * @memberof AddOrgUserCommand
     */
    'loginOrEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddOrgUserCommand
     */
    'role'?: AddOrgUserCommandRoleEnum;
}

export const AddOrgUserCommandRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type AddOrgUserCommandRoleEnum = typeof AddOrgUserCommandRoleEnum[keyof typeof AddOrgUserCommandRoleEnum];

/**
 * 
 * @export
 * @interface AddServiceAccountTokenCommand
 */
export interface AddServiceAccountTokenCommand {
    /**
     * 
     * @type {string}
     * @memberof AddServiceAccountTokenCommand
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddServiceAccountTokenCommand
     */
    'secondsToLive'?: number;
}
/**
 * 
 * @export
 * @interface AddTeamMemberCommand
 */
export interface AddTeamMemberCommand {
    /**
     * 
     * @type {number}
     * @memberof AddTeamMemberCommand
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface AddTeamRoleCommand
 */
export interface AddTeamRoleCommand {
    /**
     * 
     * @type {string}
     * @memberof AddTeamRoleCommand
     */
    'roleUid'?: string;
}
/**
 * 
 * @export
 * @interface AddUserRoleCommand
 */
export interface AddUserRoleCommand {
    /**
     * 
     * @type {boolean}
     * @memberof AddUserRoleCommand
     */
    'global'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AddUserRoleCommand
     */
    'roleUid'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateUserForm
 */
export interface AdminCreateUserForm {
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserForm
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserForm
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserForm
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AdminCreateUserForm
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserForm
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AdminCreateUserResponse
 */
export interface AdminCreateUserResponse {
    /**
     * 
     * @type {number}
     * @memberof AdminCreateUserResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminCreateUserResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AdminStats
 */
export interface AdminStats {
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeAdmins'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeDevices'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeEditors'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeSessions'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'activeViewers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'admins'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'alerts'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dailyActiveAdmins'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dailyActiveEditors'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dailyActiveSessions'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dailyActiveUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dailyActiveViewers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'dashboards'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'datasources'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'editors'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'monthlyActiveUsers'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'orgs'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'playlists'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'snapshots'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'stars'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'tags'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'users'?: number;
    /**
     * 
     * @type {number}
     * @memberof AdminStats
     */
    'viewers'?: number;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserPasswordForm
 */
export interface AdminUpdateUserPasswordForm {
    /**
     * 
     * @type {string}
     * @memberof AdminUpdateUserPasswordForm
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface AdminUpdateUserPermissionsForm
 */
export interface AdminUpdateUserPermissionsForm {
    /**
     * 
     * @type {boolean}
     * @memberof AdminUpdateUserPermissionsForm
     */
    'isGrafanaAdmin'?: boolean;
}
/**
 * Alert alert
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * generator URL Format: uri
     * @type {string}
     * @memberof Alert
     */
    'generatorURL'?: string;
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof Alert
     */
    'labels': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface AlertDiscovery
 */
export interface AlertDiscovery {
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AlertDiscovery
     */
    'alerts': Array<Alert>;
}
/**
 * AlertGroup alert group
 * @export
 * @interface AlertGroup
 */
export interface AlertGroup {
    /**
     * alerts
     * @type {Array<GettableAlert>}
     * @memberof AlertGroup
     */
    'alerts': Array<GettableAlert>;
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof AlertGroup
     */
    'labels': { [key: string]: string; };
    /**
     * 
     * @type {Receiver}
     * @memberof AlertGroup
     */
    'receiver': Receiver;
}
/**
 * 
 * @export
 * @interface AlertInstancesResponse
 */
export interface AlertInstancesResponse {
    /**
     * Instances is an array of arrow encoded dataframes each frame has a single row, and a column for each instance (alert identified by unique labels) with a boolean value (firing/not firing)
     * @type {Array<Array<number>>}
     * @memberof AlertInstancesResponse
     */
    'instances'?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface AlertManager
 */
export interface AlertManager {
    /**
     * 
     * @type {string}
     * @memberof AlertManager
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AlertManagersResult
 */
export interface AlertManagersResult {
    /**
     * 
     * @type {Array<AlertManager>}
     * @memberof AlertManagersResult
     */
    'activeAlertManagers'?: Array<AlertManager>;
    /**
     * 
     * @type {Array<AlertManager>}
     * @memberof AlertManagersResult
     */
    'droppedAlertManagers'?: Array<AlertManager>;
}
/**
 * 
 * @export
 * @interface AlertQuery
 */
export interface AlertQuery {
    /**
     * Grafana data source unique identifier; it should be \'__expr__\' for a Server Side Expression operation.
     * @type {string}
     * @memberof AlertQuery
     */
    'datasourceUid'?: string;
    /**
     * JSON is the raw JSON query and includes the above properties as well as custom properties.
     * @type {object}
     * @memberof AlertQuery
     */
    'model'?: object;
    /**
     * QueryType is an optional identifier for the type of query. It can be used to distinguish different types of queries.
     * @type {string}
     * @memberof AlertQuery
     */
    'queryType'?: string;
    /**
     * RefID is the unique identifier of the query, set by the frontend call.
     * @type {string}
     * @memberof AlertQuery
     */
    'refId'?: string;
    /**
     * 
     * @type {RelativeTimeRange}
     * @memberof AlertQuery
     */
    'relativeTimeRange'?: RelativeTimeRange;
}
/**
 * 
 * @export
 * @interface AlertQueryExport
 */
export interface AlertQueryExport {
    /**
     * 
     * @type {string}
     * @memberof AlertQueryExport
     */
    'datasourceUid'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AlertQueryExport
     */
    'model'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof AlertQueryExport
     */
    'queryType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertQueryExport
     */
    'refId'?: string;
    /**
     * 
     * @type {RelativeTimeRangeExport}
     * @memberof AlertQueryExport
     */
    'relativeTimeRange'?: RelativeTimeRangeExport;
}
/**
 * 
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
    /**
     * 
     * @type {AlertDiscovery}
     * @memberof AlertResponse
     */
    'data'?: AlertDiscovery;
    /**
     * 
     * @type {string}
     * @memberof AlertResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertResponse
     */
    'errorType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface AlertRuleExport
 */
export interface AlertRuleExport {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertRuleExport
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'dashboardUid'?: string;
    /**
     * 
     * @type {Array<AlertQueryExport>}
     * @memberof AlertRuleExport
     */
    'data'?: Array<AlertQueryExport>;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'execErrState'?: AlertRuleExportExecErrStateEnum;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof AlertRuleExport
     */
    'for'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AlertRuleExport
     */
    'isPaused'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AlertRuleExport
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'noDataState'?: AlertRuleExportNoDataStateEnum;
    /**
     * 
     * @type {AlertRuleNotificationSettingsExport}
     * @memberof AlertRuleExport
     */
    'notification_settings'?: AlertRuleNotificationSettingsExport;
    /**
     * 
     * @type {number}
     * @memberof AlertRuleExport
     */
    'panelId'?: number;
    /**
     * 
     * @type {AlertRuleRecordExport}
     * @memberof AlertRuleExport
     */
    'record'?: AlertRuleRecordExport;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleExport
     */
    'uid'?: string;
}

export const AlertRuleExportExecErrStateEnum = {
    Ok: 'OK',
    Alerting: 'Alerting',
    Error: 'Error'
} as const;

export type AlertRuleExportExecErrStateEnum = typeof AlertRuleExportExecErrStateEnum[keyof typeof AlertRuleExportExecErrStateEnum];
export const AlertRuleExportNoDataStateEnum = {
    Alerting: 'Alerting',
    NoData: 'NoData',
    Ok: 'OK'
} as const;

export type AlertRuleExportNoDataStateEnum = typeof AlertRuleExportNoDataStateEnum[keyof typeof AlertRuleExportNoDataStateEnum];

/**
 * 
 * @export
 * @interface AlertRuleGroup
 */
export interface AlertRuleGroup {
    /**
     * 
     * @type {string}
     * @memberof AlertRuleGroup
     */
    'folderUid'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRuleGroup
     */
    'interval'?: number;
    /**
     * 
     * @type {Array<ProvisionedAlertRule>}
     * @memberof AlertRuleGroup
     */
    'rules'?: Array<ProvisionedAlertRule>;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleGroup
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface AlertRuleGroupExport
 */
export interface AlertRuleGroupExport {
    /**
     * 
     * @type {string}
     * @memberof AlertRuleGroupExport
     */
    'folder'?: string;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof AlertRuleGroupExport
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleGroupExport
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertRuleGroupExport
     */
    'orgId'?: number;
    /**
     * 
     * @type {Array<AlertRuleExport>}
     * @memberof AlertRuleGroupExport
     */
    'rules'?: Array<AlertRuleExport>;
}
/**
 * 
 * @export
 * @interface AlertRuleGroupMetadata
 */
export interface AlertRuleGroupMetadata {
    /**
     * 
     * @type {number}
     * @memberof AlertRuleGroupMetadata
     */
    'interval'?: number;
}
/**
 * 
 * @export
 * @interface AlertRuleNotificationSettings
 */
export interface AlertRuleNotificationSettings {
    /**
     * Override the labels by which incoming alerts are grouped together. For example, multiple alerts coming in for cluster=A and alertname=LatencyHigh would be batched into a single group. To aggregate by all possible labels use the special value \'...\' as the sole label name. This effectively disables aggregation entirely, passing through all alerts as-is. This is unlikely to be what you want, unless you have a very low alert volume or your upstream notification system performs its own grouping. Must include \'alertname\' and \'grafana_folder\' if not using \'...\'.
     * @type {Array<string>}
     * @memberof AlertRuleNotificationSettings
     */
    'group_by'?: Array<string>;
    /**
     * Override how long to wait before sending a notification about new alerts that are added to a group of alerts for which an initial notification has already been sent. (Usually ~5m or more.)
     * @type {string}
     * @memberof AlertRuleNotificationSettings
     */
    'group_interval'?: string;
    /**
     * Override how long to initially wait to send a notification for a group of alerts. Allows to wait for an inhibiting alert to arrive or collect more initial alerts for the same group. (Usually ~0s to few minutes.)
     * @type {string}
     * @memberof AlertRuleNotificationSettings
     */
    'group_wait'?: string;
    /**
     * Override the times when notifications should be muted. These must match the name of a mute time interval defined in the alertmanager configuration mute_time_intervals section. When muted it will not send any notifications, but otherwise acts normally.
     * @type {Array<string>}
     * @memberof AlertRuleNotificationSettings
     */
    'mute_time_intervals'?: Array<string>;
    /**
     * Name of the receiver to send notifications to.
     * @type {string}
     * @memberof AlertRuleNotificationSettings
     */
    'receiver': string;
    /**
     * Override how long to wait before sending a notification again if it has already been sent successfully for an alert. (Usually ~3h or more). Note that this parameter is implicitly bound by Alertmanager\'s `--data.retention` configuration flag. Notifications will be resent after either repeat_interval or the data retention period have passed, whichever occurs first. `repeat_interval` should not be less than `group_interval`.
     * @type {string}
     * @memberof AlertRuleNotificationSettings
     */
    'repeat_interval'?: string;
}
/**
 * 
 * @export
 * @interface AlertRuleNotificationSettingsExport
 */
export interface AlertRuleNotificationSettingsExport {
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'group_by'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'group_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'group_wait'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'mute_time_intervals'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleNotificationSettingsExport
     */
    'repeat_interval'?: string;
}
/**
 * 
 * @export
 * @interface AlertRuleRecordExport
 */
export interface AlertRuleRecordExport {
    /**
     * 
     * @type {string}
     * @memberof AlertRuleRecordExport
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertRuleRecordExport
     */
    'metric'?: string;
}
/**
 * AlertStatus alert status
 * @export
 * @interface AlertStatus
 */
export interface AlertStatus {
    /**
     * inhibited by
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'inhibitedBy': Array<string>;
    /**
     * silenced by
     * @type {Array<string>}
     * @memberof AlertStatus
     */
    'silencedBy': Array<string>;
    /**
     * state
     * @type {string}
     * @memberof AlertStatus
     */
    'state': AlertStatusStateEnum;
}

export const AlertStatusStateEnum = {
    UnprocessedActiveSuppressed: '[unprocessed active suppressed]'
} as const;

export type AlertStatusStateEnum = typeof AlertStatusStateEnum[keyof typeof AlertStatusStateEnum];

/**
 * 
 * @export
 * @interface AlertingFileExport
 */
export interface AlertingFileExport {
    /**
     * 
     * @type {number}
     * @memberof AlertingFileExport
     */
    'apiVersion'?: number;
    /**
     * 
     * @type {Array<ContactPointExport>}
     * @memberof AlertingFileExport
     */
    'contactPoints'?: Array<ContactPointExport>;
    /**
     * 
     * @type {Array<AlertRuleGroupExport>}
     * @memberof AlertingFileExport
     */
    'groups'?: Array<AlertRuleGroupExport>;
    /**
     * 
     * @type {Array<MuteTimeIntervalExport>}
     * @memberof AlertingFileExport
     */
    'muteTimes'?: Array<MuteTimeIntervalExport>;
    /**
     * 
     * @type {Array<NotificationPolicyExport>}
     * @memberof AlertingFileExport
     */
    'policies'?: Array<NotificationPolicyExport>;
}
/**
 * adapted from cortex
 * @export
 * @interface AlertingRule
 */
export interface AlertingRule {
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'activeAt': string;
    /**
     * 
     * @type {Array<Alert>}
     * @memberof AlertingRule
     */
    'alerts'?: Array<Alert>;
    /**
     * Labels is a sorted set of labels. Order has to be guaranteed upon instantiation.
     * @type {Array<Label>}
     * @memberof AlertingRule
     */
    'annotations': Array<Label>;
    /**
     * 
     * @type {number}
     * @memberof AlertingRule
     */
    'duration'?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertingRule
     */
    'evaluationTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'health': string;
    /**
     * Labels is a sorted set of labels. Order has to be guaranteed upon instantiation.
     * @type {Array<Label>}
     * @memberof AlertingRule
     */
    'labels'?: Array<Label>;
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'lastEvaluation'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'query': string;
    /**
     * State can be \"pending\", \"firing\", \"inactive\".
     * @type {string}
     * @memberof AlertingRule
     */
    'state': string;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AlertingRule
     */
    'totals'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AlertingRule
     */
    'totalsFiltered'?: { [key: string]: number; };
    /**
     * 
     * @type {string}
     * @memberof AlertingRule
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface AlertingStatus
 */
export interface AlertingStatus {
    /**
     * 
     * @type {string}
     * @memberof AlertingStatus
     */
    'alertmanagersChoice'?: AlertingStatusAlertmanagersChoiceEnum;
    /**
     * 
     * @type {number}
     * @memberof AlertingStatus
     */
    'numExternalAlertmanagers'?: number;
}

export const AlertingStatusAlertmanagersChoiceEnum = {
    All: 'all',
    Internal: 'internal',
    External: 'external'
} as const;

export type AlertingStatusAlertmanagersChoiceEnum = typeof AlertingStatusAlertmanagersChoiceEnum[keyof typeof AlertingStatusAlertmanagersChoiceEnum];

/**
 * AlertmanagerConfig alertmanager config
 * @export
 * @interface AlertmanagerConfig
 */
export interface AlertmanagerConfig {
    /**
     * original
     * @type {string}
     * @memberof AlertmanagerConfig
     */
    'original': string;
}
/**
 * AlertmanagerStatus alertmanager status
 * @export
 * @interface AlertmanagerStatus
 */
export interface AlertmanagerStatus {
    /**
     * 
     * @type {ClusterStatus}
     * @memberof AlertmanagerStatus
     */
    'cluster': ClusterStatus;
    /**
     * 
     * @type {AlertmanagerConfig}
     * @memberof AlertmanagerStatus
     */
    'config': AlertmanagerConfig;
    /**
     * uptime
     * @type {string}
     * @memberof AlertmanagerStatus
     */
    'uptime': string;
    /**
     * 
     * @type {VersionInfo}
     * @memberof AlertmanagerStatus
     */
    'versionInfo': VersionInfo;
}
/**
 * 
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'alertId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'alertName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'created'?: number;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'dashboardUID'?: string;
    /**
     * 
     * @type {object}
     * @memberof Annotation
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'newState'?: string;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'panelId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'prevState'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Annotation
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Annotation
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'timeEnd'?: number;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'updated'?: number;
    /**
     * 
     * @type {number}
     * @memberof Annotation
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface AnnotationActions
 */
export interface AnnotationActions {
    /**
     * 
     * @type {boolean}
     * @memberof AnnotationActions
     */
    'canAdd'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AnnotationActions
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AnnotationActions
     */
    'canEdit'?: boolean;
}
/**
 * 
 * @export
 * @interface AnnotationEvent
 */
export interface AnnotationEvent {
    /**
     * 
     * @type {string}
     * @memberof AnnotationEvent
     */
    'color'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationEvent
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnnotationEvent
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AnnotationEvent
     */
    'isRegion'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AnnotationEvent
     */
    'panelId'?: number;
    /**
     * 
     * @type {AnnotationQuery}
     * @memberof AnnotationEvent
     */
    'source'?: AnnotationQuery;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnotationEvent
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AnnotationEvent
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationEvent
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnnotationEvent
     */
    'timeEnd'?: number;
}
/**
 * 
 * @export
 * @interface AnnotationPanelFilter
 */
export interface AnnotationPanelFilter {
    /**
     * Should the specified panels be included or excluded
     * @type {boolean}
     * @memberof AnnotationPanelFilter
     */
    'exclude'?: boolean;
    /**
     * Panel IDs that should be included or excluded
     * @type {Array<number>}
     * @memberof AnnotationPanelFilter
     */
    'ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface AnnotationPermission
 */
export interface AnnotationPermission {
    /**
     * 
     * @type {AnnotationActions}
     * @memberof AnnotationPermission
     */
    'dashboard'?: AnnotationActions;
    /**
     * 
     * @type {AnnotationActions}
     * @memberof AnnotationPermission
     */
    'organization'?: AnnotationActions;
}
/**
 * TODO docs FROM: AnnotationQuery in grafana-data/src/types/annotations.ts
 * @export
 * @interface AnnotationQuery
 */
export interface AnnotationQuery {
    /**
     * Set to 1 for the standard annotation query all dashboards have by default.
     * @type {number}
     * @memberof AnnotationQuery
     */
    'builtIn'?: number;
    /**
     * 
     * @type {DataSourceRef}
     * @memberof AnnotationQuery
     */
    'datasource'?: DataSourceRef;
    /**
     * When enabled the annotation query is issued with every dashboard refresh
     * @type {boolean}
     * @memberof AnnotationQuery
     */
    'enable'?: boolean;
    /**
     * 
     * @type {AnnotationPanelFilter}
     * @memberof AnnotationQuery
     */
    'filter'?: AnnotationPanelFilter;
    /**
     * Annotation queries can be toggled on or off at the top of the dashboard. When hide is true, the toggle is not shown in the dashboard.
     * @type {boolean}
     * @memberof AnnotationQuery
     */
    'hide'?: boolean;
    /**
     * Color to use for the annotation event markers
     * @type {string}
     * @memberof AnnotationQuery
     */
    'iconColor'?: string;
    /**
     * Name of annotation.
     * @type {string}
     * @memberof AnnotationQuery
     */
    'name'?: string;
    /**
     * 
     * @type {AnnotationTarget}
     * @memberof AnnotationQuery
     */
    'target'?: AnnotationTarget;
    /**
     * TODO -- this should not exist here, it is based on the --grafana-- datasource
     * @type {string}
     * @memberof AnnotationQuery
     */
    'type'?: string;
}
/**
 * TODO: this should be a regular DataQuery that depends on the selected dashboard these match the properties of the \"grafana\" datasouce that is default in most dashboards
 * @export
 * @interface AnnotationTarget
 */
export interface AnnotationTarget {
    /**
     * Only required/valid for the grafana datasource... but code+tests is already depending on it so hard to change
     * @type {number}
     * @memberof AnnotationTarget
     */
    'limit'?: number;
    /**
     * Only required/valid for the grafana datasource... but code+tests is already depending on it so hard to change
     * @type {boolean}
     * @memberof AnnotationTarget
     */
    'matchAny'?: boolean;
    /**
     * Only required/valid for the grafana datasource... but code+tests is already depending on it so hard to change
     * @type {Array<string>}
     * @memberof AnnotationTarget
     */
    'tags'?: Array<string>;
    /**
     * Only required/valid for the grafana datasource... but code+tests is already depending on it so hard to change
     * @type {string}
     * @memberof AnnotationTarget
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ApiKeyDTO
 */
export interface ApiKeyDTO {
    /**
     * Metadata contains user accesses for a given resource Ex: map[string]bool{\"create\":true, \"delete\": true}
     * @type {{ [key: string]: boolean; }}
     * @memberof ApiKeyDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'expiration'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiKeyDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKeyDTO
     */
    'role'?: ApiKeyDTORoleEnum;
}

export const ApiKeyDTORoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type ApiKeyDTORoleEnum = typeof ApiKeyDTORoleEnum[keyof typeof ApiKeyDTORoleEnum];

/**
 * 
 * @export
 * @interface ApiRuleNode
 */
export interface ApiRuleNode {
    /**
     * 
     * @type {string}
     * @memberof ApiRuleNode
     */
    'alert'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiRuleNode
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApiRuleNode
     */
    'expr'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRuleNode
     */
    'for'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiRuleNode
     */
    'keep_firing_for'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ApiRuleNode
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ApiRuleNode
     */
    'record'?: string;
}
/**
 * 
 * @export
 * @interface Assignments
 */
export interface Assignments {
    /**
     * 
     * @type {boolean}
     * @memberof Assignments
     */
    'builtInRoles'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Assignments
     */
    'serviceAccounts'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Assignments
     */
    'teams'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Assignments
     */
    'users'?: boolean;
}
/**
 * AttributeTypeAndValue mirrors the ASN.1 structure of the same name in RFC 5280, Section 4.1.2.4.
 * @export
 * @interface AttributeTypeAndValue
 */
export interface AttributeTypeAndValue {
    /**
     * 
     * @type {Array<number>}
     * @memberof AttributeTypeAndValue
     */
    'Type'?: Array<number>;
    /**
     * 
     * @type {any}
     * @memberof AttributeTypeAndValue
     */
    'Value'?: any;
}
/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    'credentials'?: string;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    'credentials_file'?: string;
    /**
     * CredentialsRef is the name of the secret within the secret manager to use as credentials.
     * @type {string}
     * @memberof Authorization
     */
    'credentials_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof Authorization
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface BacktestConfig
 */
export interface BacktestConfig {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BacktestConfig
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BacktestConfig
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof BacktestConfig
     */
    'data'?: Array<AlertQuery>;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof BacktestConfig
     */
    'for'?: number;
    /**
     * 
     * @type {string}
     * @memberof BacktestConfig
     */
    'from'?: string;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof BacktestConfig
     */
    'interval'?: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof BacktestConfig
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof BacktestConfig
     */
    'no_data_state'?: BacktestConfigNoDataStateEnum;
    /**
     * 
     * @type {string}
     * @memberof BacktestConfig
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BacktestConfig
     */
    'to'?: string;
}

export const BacktestConfigNoDataStateEnum = {
    Alerting: 'Alerting',
    NoData: 'NoData',
    Ok: 'OK'
} as const;

export type BacktestConfigNoDataStateEnum = typeof BacktestConfigNoDataStateEnum[keyof typeof BacktestConfigNoDataStateEnum];

/**
 * 
 * @export
 * @interface BasicAuth
 */
export interface BasicAuth {
    /**
     * 
     * @type {string}
     * @memberof BasicAuth
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicAuth
     */
    'password_file'?: string;
    /**
     * PasswordRef is the name of the secret within the secret manager to use as the password.
     * @type {string}
     * @memberof BasicAuth
     */
    'password_ref'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicAuth
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicAuth
     */
    'username_file'?: string;
    /**
     * UsernameRef is the name of the secret within the secret manager to use as the username.
     * @type {string}
     * @memberof BasicAuth
     */
    'username_ref'?: string;
}
/**
 * Config defines the internal representation of a cache configuration, including fields not set by the API caller
 * @export
 * @interface CacheConfig
 */
export interface CacheConfig {
    /**
     * 
     * @type {string}
     * @memberof CacheConfig
     */
    'created'?: string;
    /**
     * Fields that can be set by the API caller - read/write
     * @type {number}
     * @memberof CacheConfig
     */
    'dataSourceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof CacheConfig
     */
    'dataSourceUID'?: string;
    /**
     * These are returned by the HTTP API, but are managed internally - read-only Note: \'created\' and \'updated\' are special properties managed automatically by xorm, but we are setting them manually
     * @type {number}
     * @memberof CacheConfig
     */
    'defaultTTLMs'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CacheConfig
     */
    'enabled'?: boolean;
    /**
     * TTL MS, or \"time to live\", is how long a cached item will stay in the cache before it is removed (in milliseconds)
     * @type {number}
     * @memberof CacheConfig
     */
    'ttlQueriesMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof CacheConfig
     */
    'ttlResourcesMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof CacheConfig
     */
    'updated'?: string;
    /**
     * If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini
     * @type {boolean}
     * @memberof CacheConfig
     */
    'useDefaultTTL'?: boolean;
}
/**
 * 
 * @export
 * @interface CacheConfigResponse
 */
export interface CacheConfigResponse {
    /**
     * 
     * @type {string}
     * @memberof CacheConfigResponse
     */
    'created'?: string;
    /**
     * Fields that can be set by the API caller - read/write
     * @type {number}
     * @memberof CacheConfigResponse
     */
    'dataSourceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof CacheConfigResponse
     */
    'dataSourceUID'?: string;
    /**
     * These are returned by the HTTP API, but are managed internally - read-only Note: \'created\' and \'updated\' are special properties managed automatically by xorm, but we are setting them manually
     * @type {number}
     * @memberof CacheConfigResponse
     */
    'defaultTTLMs'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CacheConfigResponse
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CacheConfigResponse
     */
    'message'?: string;
    /**
     * TTL MS, or \"time to live\", is how long a cached item will stay in the cache before it is removed (in milliseconds)
     * @type {number}
     * @memberof CacheConfigResponse
     */
    'ttlQueriesMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof CacheConfigResponse
     */
    'ttlResourcesMs'?: number;
    /**
     * 
     * @type {string}
     * @memberof CacheConfigResponse
     */
    'updated'?: string;
    /**
     * If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini
     * @type {boolean}
     * @memberof CacheConfigResponse
     */
    'useDefaultTTL'?: boolean;
}
/**
 * ConfigSetter defines the cache parameters that users can configure per datasource This is only intended to be consumed by the SetCache HTTP Handler
 * @export
 * @interface CacheConfigSetter
 */
export interface CacheConfigSetter {
    /**
     * 
     * @type {number}
     * @memberof CacheConfigSetter
     */
    'dataSourceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof CacheConfigSetter
     */
    'dataSourceUID'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CacheConfigSetter
     */
    'enabled'?: boolean;
    /**
     * TTL MS, or \"time to live\", is how long a cached item will stay in the cache before it is removed (in milliseconds)
     * @type {number}
     * @memberof CacheConfigSetter
     */
    'ttlQueriesMs'?: number;
    /**
     * 
     * @type {number}
     * @memberof CacheConfigSetter
     */
    'ttlResourcesMs'?: number;
    /**
     * If UseDefaultTTL is enabled, then the TTLQueriesMS and TTLResourcesMS in this object is always sent as the default TTL located in grafana.ini
     * @type {boolean}
     * @memberof CacheConfigSetter
     */
    'useDefaultTTL'?: boolean;
}
/**
 * 
 * @export
 * @interface CalculateDashboardDiffRequest
 */
export interface CalculateDashboardDiffRequest {
    /**
     * 
     * @type {CalculateDiffTarget}
     * @memberof CalculateDashboardDiffRequest
     */
    'base'?: CalculateDiffTarget;
    /**
     * The type of diff to return Description: `basic` `json`
     * @type {string}
     * @memberof CalculateDashboardDiffRequest
     */
    'diffType'?: CalculateDashboardDiffRequestDiffTypeEnum;
    /**
     * 
     * @type {CalculateDiffTarget}
     * @memberof CalculateDashboardDiffRequest
     */
    'new'?: CalculateDiffTarget;
}

export const CalculateDashboardDiffRequestDiffTypeEnum = {
    Basic: 'basic',
    Json: 'json'
} as const;

export type CalculateDashboardDiffRequestDiffTypeEnum = typeof CalculateDashboardDiffRequestDiffTypeEnum[keyof typeof CalculateDashboardDiffRequestDiffTypeEnum];

/**
 * 
 * @export
 * @interface CalculateDiffTarget
 */
export interface CalculateDiffTarget {
    /**
     * 
     * @type {number}
     * @memberof CalculateDiffTarget
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {object}
     * @memberof CalculateDiffTarget
     */
    'unsavedDashboard'?: object;
    /**
     * 
     * @type {number}
     * @memberof CalculateDiffTarget
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface Certificate
 */
export interface Certificate {
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'AuthorityKeyId'?: Array<number>;
    /**
     * BasicConstraintsValid indicates whether IsCA, MaxPathLen, and MaxPathLenZero are valid.
     * @type {boolean}
     * @memberof Certificate
     */
    'BasicConstraintsValid'?: boolean;
    /**
     * CRL Distribution Points
     * @type {Array<string>}
     * @memberof Certificate
     */
    'CRLDistributionPoints'?: Array<string>;
    /**
     * Subject Alternate Name values. (Note that these values may not be valid if invalid values were contained within a parsed certificate. For example, an element of DNSNames may not be a valid DNS domain name.)
     * @type {Array<string>}
     * @memberof Certificate
     */
    'DNSNames'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'EmailAddresses'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'ExcludedDNSDomains'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'ExcludedEmailAddresses'?: Array<string>;
    /**
     * 
     * @type {Array<IPNet>}
     * @memberof Certificate
     */
    'ExcludedIPRanges'?: Array<IPNet>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'ExcludedURIDomains'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'ExtKeyUsage'?: Array<number>;
    /**
     * Extensions contains raw X.509 extensions. When parsing certificates, this can be used to extract non-critical extensions that are not parsed by this package. When marshaling certificates, the Extensions field is ignored, see ExtraExtensions.
     * @type {Array<Extension>}
     * @memberof Certificate
     */
    'Extensions'?: Array<Extension>;
    /**
     * ExtraExtensions contains extensions to be copied, raw, into any marshaled certificates. Values override any extensions that would otherwise be produced based on the other fields. The ExtraExtensions field is not populated when parsing certificates, see Extensions.
     * @type {Array<Extension>}
     * @memberof Certificate
     */
    'ExtraExtensions'?: Array<Extension>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'IPAddresses'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Certificate
     */
    'IsCA'?: boolean;
    /**
     * 
     * @type {Name}
     * @memberof Certificate
     */
    'Issuer'?: Name;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'IssuingCertificateURL'?: Array<string>;
    /**
     * KeyUsage represents the set of actions that are valid for a given key. It\'s a bitmap of the KeyUsage* constants.
     * @type {number}
     * @memberof Certificate
     */
    'KeyUsage'?: number;
    /**
     * MaxPathLen and MaxPathLenZero indicate the presence and value of the BasicConstraints\' \"pathLenConstraint\".  When parsing a certificate, a positive non-zero MaxPathLen means that the field was specified, -1 means it was unset, and MaxPathLenZero being true mean that the field was explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false should be treated equivalent to -1 (unset).  When generating a certificate, an unset pathLenConstraint can be requested with either MaxPathLen == -1 or using the zero value for both MaxPathLen and MaxPathLenZero.
     * @type {number}
     * @memberof Certificate
     */
    'MaxPathLen'?: number;
    /**
     * MaxPathLenZero indicates that BasicConstraintsValid==true and MaxPathLen==0 should be interpreted as an actual maximum path length of zero. Otherwise, that combination is interpreted as MaxPathLen not being set.
     * @type {boolean}
     * @memberof Certificate
     */
    'MaxPathLenZero'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'NotBefore'?: string;
    /**
     * RFC 5280, 4.2.2.1 (Authority Information Access)
     * @type {Array<string>}
     * @memberof Certificate
     */
    'OCSPServer'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'PermittedDNSDomains'?: Array<string>;
    /**
     * Name constraints
     * @type {boolean}
     * @memberof Certificate
     */
    'PermittedDNSDomainsCritical'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'PermittedEmailAddresses'?: Array<string>;
    /**
     * 
     * @type {Array<IPNet>}
     * @memberof Certificate
     */
    'PermittedIPRanges'?: Array<IPNet>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Certificate
     */
    'PermittedURIDomains'?: Array<string>;
    /**
     * Policies contains all policy identifiers included in the certificate. In Go 1.22, encoding/gob cannot handle and ignores this field.
     * @type {Array<string>}
     * @memberof Certificate
     */
    'Policies'?: Array<string>;
    /**
     * PolicyIdentifiers contains asn1.ObjectIdentifiers, the components of which are limited to int32. If a certificate contains a policy which cannot be represented by asn1.ObjectIdentifier, it will not be included in PolicyIdentifiers, but will be present in Policies, which contains all parsed policy OIDs.
     * @type {Array<Array<number>>}
     * @memberof Certificate
     */
    'PolicyIdentifiers'?: Array<Array<number>>;
    /**
     * 
     * @type {any}
     * @memberof Certificate
     */
    'PublicKey'?: any;
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    'PublicKeyAlgorithm'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'Raw'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'RawIssuer'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'RawSubject'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'RawSubjectPublicKeyInfo'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'RawTBSCertificate'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Certificate
     */
    'SerialNumber'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'Signature'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    'SignatureAlgorithm'?: number;
    /**
     * 
     * @type {Name}
     * @memberof Certificate
     */
    'Subject'?: Name;
    /**
     * 
     * @type {Array<number>}
     * @memberof Certificate
     */
    'SubjectKeyId'?: Array<number>;
    /**
     * 
     * @type {Array<URL>}
     * @memberof Certificate
     */
    'URIs'?: Array<URL>;
    /**
     * UnhandledCriticalExtensions contains a list of extension IDs that were not (fully) processed when parsing. Verify will fail if this slice is non-empty, unless verification is delegated to an OS library which understands all the critical extensions.  Users can access these extensions using Extensions and can remove elements from this slice if they believe that they have been handled.
     * @type {Array<Array<number>>}
     * @memberof Certificate
     */
    'UnhandledCriticalExtensions'?: Array<Array<number>>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof Certificate
     */
    'UnknownExtKeyUsage'?: Array<Array<number>>;
    /**
     * 
     * @type {number}
     * @memberof Certificate
     */
    'Version'?: number;
}
/**
 * 
 * @export
 * @interface ChangeUserPasswordCommand
 */
export interface ChangeUserPasswordCommand {
    /**
     * 
     * @type {string}
     * @memberof ChangeUserPasswordCommand
     */
    'newPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangeUserPasswordCommand
     */
    'oldPassword'?: string;
}
/**
 * 
 * @export
 * @interface ClearHelpFlags200Response
 */
export interface ClearHelpFlags200Response {
    /**
     * 
     * @type {number}
     * @memberof ClearHelpFlags200Response
     */
    'helpFlags1'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClearHelpFlags200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CloudMigrationRunListDTO
 */
export interface CloudMigrationRunListDTO {
    /**
     * 
     * @type {Array<MigrateDataResponseListDTO>}
     * @memberof CloudMigrationRunListDTO
     */
    'runs'?: Array<MigrateDataResponseListDTO>;
}
/**
 * 
 * @export
 * @interface CloudMigrationSessionListResponseDTO
 */
export interface CloudMigrationSessionListResponseDTO {
    /**
     * 
     * @type {Array<CloudMigrationSessionResponseDTO>}
     * @memberof CloudMigrationSessionListResponseDTO
     */
    'sessions'?: Array<CloudMigrationSessionResponseDTO>;
}
/**
 * 
 * @export
 * @interface CloudMigrationSessionRequestDTO
 */
export interface CloudMigrationSessionRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof CloudMigrationSessionRequestDTO
     */
    'authToken'?: string;
}
/**
 * 
 * @export
 * @interface CloudMigrationSessionResponseDTO
 */
export interface CloudMigrationSessionResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof CloudMigrationSessionResponseDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudMigrationSessionResponseDTO
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudMigrationSessionResponseDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof CloudMigrationSessionResponseDTO
     */
    'updated'?: string;
}
/**
 * ClusterStatus cluster status
 * @export
 * @interface ClusterStatus
 */
export interface ClusterStatus {
    /**
     * name
     * @type {string}
     * @memberof ClusterStatus
     */
    'name'?: string;
    /**
     * peers
     * @type {Array<PeerStatus>}
     * @memberof ClusterStatus
     */
    'peers'?: Array<PeerStatus>;
    /**
     * status
     * @type {string}
     * @memberof ClusterStatus
     */
    'status': ClusterStatusStatusEnum;
}

export const ClusterStatusStatusEnum = {
    ReadySettlingDisabled: '[ready settling disabled]'
} as const;

export type ClusterStatusStatusEnum = typeof ClusterStatusStatusEnum[keyof typeof ClusterStatusStatusEnum];

/**
 * 
 * @export
 * @interface Config
 */
export interface Config {
    /**
     * 
     * @type {GlobalConfig}
     * @memberof Config
     */
    'global'?: GlobalConfig;
    /**
     * 
     * @type {Array<InhibitRule>}
     * @memberof Config
     */
    'inhibit_rules'?: Array<InhibitRule>;
    /**
     * MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.
     * @type {Array<MuteTimeInterval>}
     * @memberof Config
     */
    'mute_time_intervals'?: Array<MuteTimeInterval>;
    /**
     * 
     * @type {Route}
     * @memberof Config
     */
    'route'?: Route;
    /**
     * 
     * @type {Array<string>}
     * @memberof Config
     */
    'templates'?: Array<string>;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof Config
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * 
 * @export
 * @interface ContactPointExport
 */
export interface ContactPointExport {
    /**
     * 
     * @type {string}
     * @memberof ContactPointExport
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContactPointExport
     */
    'orgId'?: number;
    /**
     * 
     * @type {Array<ReceiverExport>}
     * @memberof ContactPointExport
     */
    'receivers'?: Array<ReceiverExport>;
}
/**
 * 
 * @export
 * @interface CookiePreferences
 */
export interface CookiePreferences {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CookiePreferences
     */
    'analytics'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CookiePreferences
     */
    'functional'?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CookiePreferences
     */
    'performance'?: { [key: string]: any; };
}
/**
 * Correlation is the model for correlations definitions
 * @export
 * @interface Correlation
 */
export interface Correlation {
    /**
     * 
     * @type {CorrelationConfig}
     * @memberof Correlation
     */
    'config'?: CorrelationConfig;
    /**
     * Description of the correlation
     * @type {string}
     * @memberof Correlation
     */
    'description'?: string;
    /**
     * Label identifying the correlation
     * @type {string}
     * @memberof Correlation
     */
    'label'?: string;
    /**
     * OrgID of the data source the correlation originates from
     * @type {number}
     * @memberof Correlation
     */
    'orgId'?: number;
    /**
     * Provisioned True if the correlation was created during provisioning
     * @type {boolean}
     * @memberof Correlation
     */
    'provisioned'?: boolean;
    /**
     * UID of the data source the correlation originates from
     * @type {string}
     * @memberof Correlation
     */
    'sourceUID'?: string;
    /**
     * UID of the data source the correlation points to
     * @type {string}
     * @memberof Correlation
     */
    'targetUID'?: string;
    /**
     * the type of correlation, either query for containing query information, or external for containing an external URL +enum
     * @type {string}
     * @memberof Correlation
     */
    'type'?: string;
    /**
     * Unique identifier of the correlation
     * @type {string}
     * @memberof Correlation
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface CorrelationConfig
 */
export interface CorrelationConfig {
    /**
     * Field used to attach the correlation link
     * @type {string}
     * @memberof CorrelationConfig
     */
    'field': string;
    /**
     * Target data query
     * @type {{ [key: string]: any; }}
     * @memberof CorrelationConfig
     */
    'target': { [key: string]: any; };
    /**
     * 
     * @type {Array<Transformation>}
     * @memberof CorrelationConfig
     */
    'transformations'?: Array<Transformation>;
    /**
     * the type of correlation, either query for containing query information, or external for containing an external URL +enum
     * @type {string}
     * @memberof CorrelationConfig
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface CorrelationConfigUpdateDTO
 */
export interface CorrelationConfigUpdateDTO {
    /**
     * Field used to attach the correlation link
     * @type {string}
     * @memberof CorrelationConfigUpdateDTO
     */
    'field'?: string;
    /**
     * Target data query
     * @type {{ [key: string]: any; }}
     * @memberof CorrelationConfigUpdateDTO
     */
    'target'?: { [key: string]: any; };
    /**
     * Source data transformations
     * @type {Array<Transformation>}
     * @memberof CorrelationConfigUpdateDTO
     */
    'transformations'?: Array<Transformation>;
}
/**
 * 
 * @export
 * @interface CreateAccessTokenResponseDTO
 */
export interface CreateAccessTokenResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateAccessTokenResponseDTO
     */
    'token'?: string;
}
/**
 * CreateCorrelationCommand is the command for creating a correlation
 * @export
 * @interface CreateCorrelationCommand
 */
export interface CreateCorrelationCommand {
    /**
     * 
     * @type {CorrelationConfig}
     * @memberof CreateCorrelationCommand
     */
    'config'?: CorrelationConfig;
    /**
     * Optional description of the correlation
     * @type {string}
     * @memberof CreateCorrelationCommand
     */
    'description'?: string;
    /**
     * Optional label identifying the correlation
     * @type {string}
     * @memberof CreateCorrelationCommand
     */
    'label'?: string;
    /**
     * True if correlation was created with provisioning. This makes it read-only.
     * @type {boolean}
     * @memberof CreateCorrelationCommand
     */
    'provisioned'?: boolean;
    /**
     * Target data source UID to which the correlation is created. required if type = query
     * @type {string}
     * @memberof CreateCorrelationCommand
     */
    'targetUID'?: string;
    /**
     * the type of correlation, either query for containing query information, or external for containing an external URL +enum
     * @type {string}
     * @memberof CreateCorrelationCommand
     */
    'type'?: string;
}
/**
 * CreateCorrelationResponse is the response struct for CreateCorrelationCommand
 * @export
 * @interface CreateCorrelationResponseBody
 */
export interface CreateCorrelationResponseBody {
    /**
     * 
     * @type {string}
     * @memberof CreateCorrelationResponseBody
     */
    'message'?: string;
    /**
     * 
     * @type {Correlation}
     * @memberof CreateCorrelationResponseBody
     */
    'result'?: Correlation;
}
/**
 * 
 * @export
 * @interface CreateDashboardSnapshot200Response
 */
export interface CreateDashboardSnapshot200Response {
    /**
     * Unique key used to delete the snapshot. It is different from the key so that only the creator can delete the snapshot.
     * @type {string}
     * @memberof CreateDashboardSnapshot200Response
     */
    'deleteKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDashboardSnapshot200Response
     */
    'deleteUrl'?: string;
    /**
     * Snapshot id
     * @type {number}
     * @memberof CreateDashboardSnapshot200Response
     */
    'id'?: number;
    /**
     * Unique key
     * @type {string}
     * @memberof CreateDashboardSnapshot200Response
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateDashboardSnapshot200Response
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface CreateDashboardSnapshotCommand
 */
export interface CreateDashboardSnapshotCommand {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof CreateDashboardSnapshotCommand
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {Unstructured}
     * @memberof CreateDashboardSnapshotCommand
     */
    'dashboard': Unstructured;
    /**
     * Unique key used to delete the snapshot. It is different from the `key` so that only the creator can delete the snapshot. Required if `external` is `true`.
     * @type {string}
     * @memberof CreateDashboardSnapshotCommand
     */
    'deleteKey'?: string;
    /**
     * When the snapshot should expire in seconds in seconds. Default is never to expire.
     * @type {number}
     * @memberof CreateDashboardSnapshotCommand
     */
    'expires'?: number;
    /**
     * these are passed when storing an external snapshot ref Save the snapshot on an external server rather than locally.
     * @type {boolean}
     * @memberof CreateDashboardSnapshotCommand
     */
    'external'?: boolean;
    /**
     * Define the unique key. Required if `external` is `true`.
     * @type {string}
     * @memberof CreateDashboardSnapshotCommand
     */
    'key'?: string;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof CreateDashboardSnapshotCommand
     */
    'kind'?: string;
    /**
     * Snapshot name
     * @type {string}
     * @memberof CreateDashboardSnapshotCommand
     */
    'name'?: string;
}
/**
 * CreateFolderCommand captures the information required by the folder service to create a folder.
 * @export
 * @interface CreateFolderCommand
 */
export interface CreateFolderCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateFolderCommand
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderCommand
     */
    'parentUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderCommand
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFolderCommand
     */
    'uid'?: string;
}
/**
 * CreateLibraryElementCommand is the command for adding a LibraryElement
 * @export
 * @interface CreateLibraryElementCommand
 */
export interface CreateLibraryElementCommand {
    /**
     * ID of the folder where the library element is stored.  Deprecated: use FolderUID instead
     * @type {number}
     * @memberof CreateLibraryElementCommand
     */
    'folderId'?: number;
    /**
     * UID of the folder where the library element is stored.
     * @type {string}
     * @memberof CreateLibraryElementCommand
     */
    'folderUid'?: string;
    /**
     * Kind of element to create, Use 1 for library panels or 2 for c. Description: 1 - library panels 2 - library variables
     * @type {number}
     * @memberof CreateLibraryElementCommand
     */
    'kind'?: CreateLibraryElementCommandKindEnum;
    /**
     * The JSON model for the library element.
     * @type {object}
     * @memberof CreateLibraryElementCommand
     */
    'model'?: object;
    /**
     * Name of the library element.
     * @type {string}
     * @memberof CreateLibraryElementCommand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLibraryElementCommand
     */
    'uid'?: string;
}

export const CreateLibraryElementCommandKindEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type CreateLibraryElementCommandKindEnum = typeof CreateLibraryElementCommandKindEnum[keyof typeof CreateLibraryElementCommandKindEnum];

/**
 * 
 * @export
 * @interface CreateOrUpdateReport
 */
export interface CreateOrUpdateReport {
    /**
     * 
     * @type {Array<ReportDashboard>}
     * @memberof CreateOrUpdateReport
     */
    'dashboards'?: Array<ReportDashboard>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateReport
     */
    'enableCsv'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrUpdateReport
     */
    'enableDashboardUrl'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateOrUpdateReport
     */
    'formats'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReport
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReport
     */
    'name'?: string;
    /**
     * 
     * @type {ReportOptions}
     * @memberof CreateOrUpdateReport
     */
    'options'?: ReportOptions;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReport
     */
    'recipients'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrUpdateReport
     */
    'replyTo'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateOrUpdateReport
     */
    'scaleFactor'?: number;
    /**
     * 
     * @type {ReportSchedule}
     * @memberof CreateOrUpdateReport
     */
    'schedule'?: ReportSchedule;
    /**
     * +enum
     * @type {string}
     * @memberof CreateOrUpdateReport
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface CreateOrg200Response
 */
export interface CreateOrg200Response {
    /**
     * Message Message of the created org.
     * @type {string}
     * @memberof CreateOrg200Response
     */
    'message': string;
    /**
     * ID Identifier of the created org.
     * @type {number}
     * @memberof CreateOrg200Response
     */
    'orgId': number;
}
/**
 * 
 * @export
 * @interface CreateOrgCommand
 */
export interface CreateOrgCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateOrgCommand
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreatePlaylistCommand
 */
export interface CreatePlaylistCommand {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistCommand
     */
    'interval'?: string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof CreatePlaylistCommand
     */
    'items'?: Array<PlaylistItem>;
    /**
     * 
     * @type {string}
     * @memberof CreatePlaylistCommand
     */
    'name'?: string;
}
/**
 * CreateQueryInQueryHistoryCommand is the command for adding query history
 * @export
 * @interface CreateQueryInQueryHistoryCommand
 */
export interface CreateQueryInQueryHistoryCommand {
    /**
     * UID of the data source for which are queries stored.
     * @type {string}
     * @memberof CreateQueryInQueryHistoryCommand
     */
    'datasourceUid'?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateQueryInQueryHistoryCommand
     */
    'queries': object;
}
/**
 * 
 * @export
 * @interface CreateReport200Response
 */
export interface CreateReport200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateReport200Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateReport200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CreateRoleForm
 */
export interface CreateRoleForm {
    /**
     * 
     * @type {string}
     * @memberof CreateRoleForm
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleForm
     */
    'displayName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoleForm
     */
    'global'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleForm
     */
    'group'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRoleForm
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleForm
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof CreateRoleForm
     */
    'permissions'?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof CreateRoleForm
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRoleForm
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface CreateServiceAccountForm
 */
export interface CreateServiceAccountForm {
    /**
     * 
     * @type {boolean}
     * @memberof CreateServiceAccountForm
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAccountForm
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateServiceAccountForm
     */
    'role'?: CreateServiceAccountFormRoleEnum;
}

export const CreateServiceAccountFormRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type CreateServiceAccountFormRoleEnum = typeof CreateServiceAccountFormRoleEnum[keyof typeof CreateServiceAccountFormRoleEnum];

/**
 * 
 * @export
 * @interface CreateSnapshotResponseDTO
 */
export interface CreateSnapshotResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateSnapshotResponseDTO
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface CreateTeam200Response
 */
export interface CreateTeam200Response {
    /**
     * 
     * @type {string}
     * @memberof CreateTeam200Response
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTeam200Response
     */
    'teamId'?: number;
}
/**
 * 
 * @export
 * @interface CreateTeamCommand
 */
export interface CreateTeamCommand {
    /**
     * 
     * @type {string}
     * @memberof CreateTeamCommand
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTeamCommand
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DashboardACLInfoDTO
 */
export interface DashboardACLInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'created'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLInfoDTO
     */
    'dashboardId'?: number;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof DashboardACLInfoDTO
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'folderUid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardACLInfoDTO
     */
    'inherited'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardACLInfoDTO
     */
    'isFolder'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLInfoDTO
     */
    'permission'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'permissionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'role'?: DashboardACLInfoDTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'team'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'teamAvatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'teamEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLInfoDTO
     */
    'teamId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'userAvatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'userEmail'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLInfoDTO
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLInfoDTO
     */
    'userLogin'?: string;
}

export const DashboardACLInfoDTORoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type DashboardACLInfoDTORoleEnum = typeof DashboardACLInfoDTORoleEnum[keyof typeof DashboardACLInfoDTORoleEnum];

/**
 * 
 * @export
 * @interface DashboardACLUpdateItem
 */
export interface DashboardACLUpdateItem {
    /**
     * 
     * @type {number}
     * @memberof DashboardACLUpdateItem
     */
    'permission'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardACLUpdateItem
     */
    'role'?: DashboardACLUpdateItemRoleEnum;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLUpdateItem
     */
    'teamId'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardACLUpdateItem
     */
    'userId'?: number;
}

export const DashboardACLUpdateItemRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type DashboardACLUpdateItemRoleEnum = typeof DashboardACLUpdateItemRoleEnum[keyof typeof DashboardACLUpdateItemRoleEnum];

/**
 * These are the values expected to be sent from an end user +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 * @export
 * @interface DashboardCreateCommand
 */
export interface DashboardCreateCommand {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof DashboardCreateCommand
     */
    'apiVersion'?: string;
    /**
     * 
     * @type {Unstructured}
     * @memberof DashboardCreateCommand
     */
    'dashboard': Unstructured;
    /**
     * When the snapshot should expire in seconds in seconds. Default is never to expire.
     * @type {number}
     * @memberof DashboardCreateCommand
     */
    'expires'?: number;
    /**
     * these are passed when storing an external snapshot ref Save the snapshot on an external server rather than locally.
     * @type {boolean}
     * @memberof DashboardCreateCommand
     */
    'external'?: boolean;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof DashboardCreateCommand
     */
    'kind'?: string;
    /**
     * Snapshot name
     * @type {string}
     * @memberof DashboardCreateCommand
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface DashboardFullWithMeta
 */
export interface DashboardFullWithMeta {
    /**
     * 
     * @type {object}
     * @memberof DashboardFullWithMeta
     */
    'dashboard'?: object;
    /**
     * 
     * @type {DashboardMeta}
     * @memberof DashboardFullWithMeta
     */
    'meta'?: DashboardMeta;
}
/**
 * 
 * @export
 * @interface DashboardMeta
 */
export interface DashboardMeta {
    /**
     * 
     * @type {AnnotationPermission}
     * @memberof DashboardMeta
     */
    'annotationsPermissions'?: AnnotationPermission;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'canAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'canEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'canSave'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'canStar'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'expires'?: string;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof DashboardMeta
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'folderTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'folderUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'folderUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'hasAcl'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'isFolder'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'isSnapshot'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'isStarred'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'provisioned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'provisionedExternalId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardMeta
     */
    'publicDashboardEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardMeta
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardMeta
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface DashboardRedirect
 */
export interface DashboardRedirect {
    /**
     * 
     * @type {string}
     * @memberof DashboardRedirect
     */
    'redirectUri'?: string;
}
/**
 * DashboardSnapshotDTO without dashboard map
 * @export
 * @interface DashboardSnapshotDTO
 */
export interface DashboardSnapshotDTO {
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'expires'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DashboardSnapshotDTO
     */
    'external'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'externalUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardSnapshotDTO
     */
    'updated'?: string;
}
/**
 * 
 * @export
 * @interface DashboardTagCloudItem
 */
export interface DashboardTagCloudItem {
    /**
     * 
     * @type {number}
     * @memberof DashboardTagCloudItem
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardTagCloudItem
     */
    'term'?: string;
}
/**
 * DashboardVersionMeta extends the DashboardVersionDTO with the names associated with the UserIds, overriding the field with the same name from the DashboardVersionDTO model.
 * @export
 * @interface DashboardVersionMeta
 */
export interface DashboardVersionMeta {
    /**
     * 
     * @type {string}
     * @memberof DashboardVersionMeta
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof DashboardVersionMeta
     */
    'createdBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardVersionMeta
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {object}
     * @memberof DashboardVersionMeta
     */
    'data'?: object;
    /**
     * 
     * @type {number}
     * @memberof DashboardVersionMeta
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardVersionMeta
     */
    'message'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardVersionMeta
     */
    'parentVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof DashboardVersionMeta
     */
    'restoredFrom'?: number;
    /**
     * 
     * @type {string}
     * @memberof DashboardVersionMeta
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof DashboardVersionMeta
     */
    'version'?: number;
}
/**
 * DataLink define what
 * @export
 * @interface DataLink
 */
export interface DataLink {
    /**
     * 
     * @type {InternalDataLink}
     * @memberof DataLink
     */
    'internal'?: InternalDataLink;
    /**
     * 
     * @type {boolean}
     * @memberof DataLink
     */
    'targetBlank'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataLink
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLink
     */
    'url'?: string;
}
/**
 * A map of RefIDs (unique query identifiers) to this type makes up the Responses property of a QueryDataResponse. The Error property is used to allow for partial success responses from the containing QueryDataResponse.
 * @export
 * @interface DataResponse
 */
export interface DataResponse {
    /**
     * Error is a property to be set if the corresponding DataQuery has an error.
     * @type {string}
     * @memberof DataResponse
     */
    'Error'?: string;
    /**
     * ErrorSource type defines the source of the error
     * @type {string}
     * @memberof DataResponse
     */
    'ErrorSource'?: string;
    /**
     * It is the main data container within a backend.DataResponse. There should be no `nil` entries in the Frames slice (making them pointers was a mistake).
     * @type {Array<Frame>}
     * @memberof DataResponse
     */
    'Frames'?: Array<Frame>;
    /**
     * 
     * @type {number}
     * @memberof DataResponse
     */
    'Status'?: number;
}
/**
 * 
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'access'?: string;
    /**
     * Metadata contains user accesses for a given resource Ex: map[string]bool{\"create\":true, \"delete\": true}
     * @type {{ [key: string]: boolean; }}
     * @memberof DataSource
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof DataSource
     */
    'basicAuth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'basicAuthUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSource
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DataSource
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DataSource
     */
    'jsonData'?: object;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSource
     */
    'orgId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DataSource
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof DataSource
     */
    'secureJsonFields'?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'typeLogoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSource
     */
    'user'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSource
     */
    'version'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DataSource
     */
    'withCredentials'?: boolean;
}
/**
 * 
 * @export
 * @interface DataSourceListItemDTO
 */
export interface DataSourceListItemDTO {
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'access'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataSourceListItemDTO
     */
    'basicAuth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'database'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSourceListItemDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DataSourceListItemDTO
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof DataSourceListItemDTO
     */
    'jsonData'?: object;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSourceListItemDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DataSourceListItemDTO
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'typeLogoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'typeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSourceListItemDTO
     */
    'user'?: string;
}
/**
 * Ref to a DataSource instance
 * @export
 * @interface DataSourceRef
 */
export interface DataSourceRef {
    /**
     * The plugin type-id
     * @type {string}
     * @memberof DataSourceRef
     */
    'type'?: string;
    /**
     * Specific datasource instance
     * @type {string}
     * @memberof DataSourceRef
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface DeleteCorrelationResponseBody
 */
export interface DeleteCorrelationResponseBody {
    /**
     * 
     * @type {string}
     * @memberof DeleteCorrelationResponseBody
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeleteDashboardByUID200Response
 */
export interface DeleteDashboardByUID200Response {
    /**
     * Message Message of the deleted dashboard.
     * @type {string}
     * @memberof DeleteDashboardByUID200Response
     */
    'message': string;
    /**
     * Title Title of the deleted dashboard.
     * @type {string}
     * @memberof DeleteDashboardByUID200Response
     */
    'title': string;
    /**
     * UID Identifier of the deleted dashboard.
     * @type {string}
     * @memberof DeleteDashboardByUID200Response
     */
    'uid': string;
}
/**
 * 
 * @export
 * @interface DeleteDataSourceByName200Response
 */
export interface DeleteDataSourceByName200Response {
    /**
     * ID Identifier of the deleted data source.
     * @type {number}
     * @memberof DeleteDataSourceByName200Response
     */
    'id': number;
    /**
     * Message Message of the deleted dashboard.
     * @type {string}
     * @memberof DeleteDataSourceByName200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteFolder200Response
 */
export interface DeleteFolder200Response {
    /**
     * ID Identifier of the deleted folder.
     * @type {number}
     * @memberof DeleteFolder200Response
     */
    'id': number;
    /**
     * Message Message of the deleted folder.
     * @type {string}
     * @memberof DeleteFolder200Response
     */
    'message': string;
    /**
     * Title of the deleted folder.
     * @type {string}
     * @memberof DeleteFolder200Response
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface DeleteTokenCommand
 */
export interface DeleteTokenCommand {
    /**
     * 
     * @type {string}
     * @memberof DeleteTokenCommand
     */
    'instance'?: string;
}
/**
 * 
 * @export
 * @interface Description
 */
export interface Description {
    /**
     * 
     * @type {Assignments}
     * @memberof Description
     */
    'assignments'?: Assignments;
    /**
     * 
     * @type {Array<string>}
     * @memberof Description
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeviceDTO
 */
export interface DeviceDTO {
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'clientIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDTO
     */
    'userAgent'?: string;
}
/**
 * 
 * @export
 * @interface DeviceSearchHitDTO
 */
export interface DeviceSearchHitDTO {
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'clientIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceSearchHitDTO
     */
    'userAgent'?: string;
}
/**
 * 
 * @export
 * @interface DiscordConfig
 */
export interface DiscordConfig {
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof DiscordConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof DiscordConfig
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiscordConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DiscordConfig
     */
    'title'?: string;
    /**
     * 
     * @type {URL}
     * @memberof DiscordConfig
     */
    'webhook_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof DiscordConfig
     */
    'webhook_url_file'?: string;
}
/**
 * 
 * @export
 * @interface DiscoveryBase
 */
export interface DiscoveryBase {
    /**
     * 
     * @type {string}
     * @memberof DiscoveryBase
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscoveryBase
     */
    'errorType'?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscoveryBase
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface EmailConfig
 */
export interface EmailConfig {
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'auth_identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'auth_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'auth_password_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'auth_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'auth_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'from'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailConfig
     */
    'headers'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'hello'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'html'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailConfig
     */
    'require_tls'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EmailConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {HostPort}
     * @memberof EmailConfig
     */
    'smarthost'?: HostPort;
    /**
     * 
     * @type {string}
     * @memberof EmailConfig
     */
    'text'?: string;
    /**
     * 
     * @type {TLSConfig}
     * @memberof EmailConfig
     */
    'tls_config'?: TLSConfig;
    /**
     * Email address to notify.
     * @type {string}
     * @memberof EmailConfig
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface EmailDTO
 */
export interface EmailDTO {
    /**
     * 
     * @type {string}
     * @memberof EmailDTO
     */
    'recipient'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailDTO
     */
    'uid'?: string;
}
/**
 * EmbeddedContactPoint is the contact point type that is used by grafanas embedded alertmanager implementation.
 * @export
 * @interface EmbeddedContactPoint
 */
export interface EmbeddedContactPoint {
    /**
     * 
     * @type {boolean}
     * @memberof EmbeddedContactPoint
     */
    'disableResolveMessage'?: boolean;
    /**
     * Name is used as grouping key in the UI. Contact points with the same name will be grouped in the UI.
     * @type {string}
     * @memberof EmbeddedContactPoint
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedContactPoint
     */
    'provenance'?: string;
    /**
     * 
     * @type {object}
     * @memberof EmbeddedContactPoint
     */
    'settings': object;
    /**
     * 
     * @type {string}
     * @memberof EmbeddedContactPoint
     */
    'type': EmbeddedContactPointTypeEnum;
    /**
     * UID is the unique identifier of the contact point. The UID can be set by the user.
     * @type {string}
     * @memberof EmbeddedContactPoint
     */
    'uid'?: string;
}

export const EmbeddedContactPointTypeEnum = {
    Alertmanager: 'alertmanager',
    Dingding: ' dingding',
    Discord: ' discord',
    Email: ' email',
    Googlechat: ' googlechat',
    Kafka: ' kafka',
    Line: ' line',
    Opsgenie: ' opsgenie',
    Pagerduty: ' pagerduty',
    Pushover: ' pushover',
    Sensugo: ' sensugo',
    Slack: ' slack',
    Teams: ' teams',
    Telegram: ' telegram',
    Threema: ' threema',
    Victorops: ' victorops',
    Webhook: ' webhook',
    Wecom: ' wecom'
} as const;

export type EmbeddedContactPointTypeEnum = typeof EmbeddedContactPointTypeEnum[keyof typeof EmbeddedContactPointTypeEnum];

/**
 * Enum field config Vector values are used as lookup keys into the enum fields
 * @export
 * @interface EnumFieldConfig
 */
export interface EnumFieldConfig {
    /**
     * Color is the color value for a given index (empty is undefined)
     * @type {Array<string>}
     * @memberof EnumFieldConfig
     */
    'color'?: Array<string>;
    /**
     * Description of the enum state
     * @type {Array<string>}
     * @memberof EnumFieldConfig
     */
    'description'?: Array<string>;
    /**
     * Icon supports setting an icon for a given index value
     * @type {Array<string>}
     * @memberof EnumFieldConfig
     */
    'icon'?: Array<string>;
    /**
     * Value is the string display value for a given index
     * @type {Array<string>}
     * @memberof EnumFieldConfig
     */
    'text'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorResponseBody
 */
export interface ErrorResponseBody {
    /**
     * Error An optional detailed description of the actual error. Only included if running in developer mode.
     * @type {string}
     * @memberof ErrorResponseBody
     */
    'error'?: string;
    /**
     * a human readable version of the error
     * @type {string}
     * @memberof ErrorResponseBody
     */
    'message': string;
    /**
     * Status An optional status to denote the cause of the error.  For example, a 412 Precondition Failed error may include additional information of why that error happened.
     * @type {string}
     * @memberof ErrorResponseBody
     */
    'status'?: string;
}
/**
 * EvalAlertConditionCommand is the command for evaluating a condition
 * @export
 * @interface EvalAlertConditionCommand
 */
export interface EvalAlertConditionCommand {
    /**
     * 
     * @type {string}
     * @memberof EvalAlertConditionCommand
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof EvalAlertConditionCommand
     */
    'data'?: Array<AlertQuery>;
    /**
     * 
     * @type {string}
     * @memberof EvalAlertConditionCommand
     */
    'now'?: string;
}
/**
 * 
 * @export
 * @interface EvalQueriesPayload
 */
export interface EvalQueriesPayload {
    /**
     * 
     * @type {string}
     * @memberof EvalQueriesPayload
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof EvalQueriesPayload
     */
    'data'?: Array<AlertQuery>;
    /**
     * 
     * @type {string}
     * @memberof EvalQueriesPayload
     */
    'now'?: string;
}
/**
 * 
 * @export
 * @interface ExtendedReceiver
 */
export interface ExtendedReceiver {
    /**
     * 
     * @type {EmailConfig}
     * @memberof ExtendedReceiver
     */
    'email_configs'?: EmailConfig;
    /**
     * 
     * @type {PostableGrafanaReceiver}
     * @memberof ExtendedReceiver
     */
    'grafana_managed_receiver'?: PostableGrafanaReceiver;
    /**
     * 
     * @type {OpsGenieConfig}
     * @memberof ExtendedReceiver
     */
    'opsgenie_configs'?: OpsGenieConfig;
    /**
     * 
     * @type {PagerdutyConfig}
     * @memberof ExtendedReceiver
     */
    'pagerduty_configs'?: PagerdutyConfig;
    /**
     * 
     * @type {PushoverConfig}
     * @memberof ExtendedReceiver
     */
    'pushover_configs'?: PushoverConfig;
    /**
     * 
     * @type {SlackConfig}
     * @memberof ExtendedReceiver
     */
    'slack_configs'?: SlackConfig;
    /**
     * 
     * @type {VictorOpsConfig}
     * @memberof ExtendedReceiver
     */
    'victorops_configs'?: VictorOpsConfig;
    /**
     * 
     * @type {WebhookConfig}
     * @memberof ExtendedReceiver
     */
    'webhook_configs'?: WebhookConfig;
    /**
     * 
     * @type {WechatConfig}
     * @memberof ExtendedReceiver
     */
    'wechat_configs'?: WechatConfig;
}
/**
 * Extension represents the ASN.1 structure of the same name. See RFC 5280, section 4.2.
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * 
     * @type {boolean}
     * @memberof Extension
     */
    'Critical'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof Extension
     */
    'Id'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof Extension
     */
    'Value'?: Array<number>;
}
/**
 * FailedUser holds the information of an user that failed
 * @export
 * @interface FailedUser
 */
export interface FailedUser {
    /**
     * 
     * @type {string}
     * @memberof FailedUser
     */
    'Error'?: string;
    /**
     * 
     * @type {string}
     * @memberof FailedUser
     */
    'Login'?: string;
}
/**
 * A Field is essentially a slice of various types with extra properties and methods. See NewField() for supported types.  The slice data in the Field is a not exported, so methods on the Field are used to to manipulate its data.
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {FieldConfig}
     * @memberof Field
     */
    'config'?: FieldConfig;
    /**
     * Labels are used to add metadata to an object.  The JSON will always be sorted keys
     * @type {{ [key: string]: string; }}
     * @memberof Field
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name is default identifier of the field. The name does not have to be unique, but the combination of name and Labels should be unique for proper behavior in all situations.
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface FieldConfig
 */
export interface FieldConfig {
    /**
     * Map values to a display color NOTE: this interface is under development in the frontend... so simple map for now
     * @type {{ [key: string]: any; }}
     * @memberof FieldConfig
     */
    'color'?: { [key: string]: any; };
    /**
     * Panel Specific Values
     * @type {{ [key: string]: any; }}
     * @memberof FieldConfig
     */
    'custom'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof FieldConfig
     */
    'decimals'?: number;
    /**
     * Description is human readable field metadata
     * @type {string}
     * @memberof FieldConfig
     */
    'description'?: string;
    /**
     * DisplayName overrides Grafana default naming, should not be used from a data source
     * @type {string}
     * @memberof FieldConfig
     */
    'displayName'?: string;
    /**
     * DisplayNameFromDS overrides Grafana default naming strategy.
     * @type {string}
     * @memberof FieldConfig
     */
    'displayNameFromDS'?: string;
    /**
     * Filterable indicates if the Field\'s data can be filtered by additional calls.
     * @type {boolean}
     * @memberof FieldConfig
     */
    'filterable'?: boolean;
    /**
     * Interval indicates the expected regular step between values in the series. When an interval exists, consumers can identify \"missing\" values when the expected value is not present. The grafana timeseries visualization will render disconnected values when missing values are found it the time field. The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
     * @type {number}
     * @memberof FieldConfig
     */
    'interval'?: number;
    /**
     * The behavior when clicking on a result
     * @type {Array<DataLink>}
     * @memberof FieldConfig
     */
    'links'?: Array<DataLink>;
    /**
     * 
     * @type {Array<object>}
     * @memberof FieldConfig
     */
    'mappings'?: Array<object>;
    /**
     * ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf to null.
     * @type {number}
     * @memberof FieldConfig
     */
    'max'?: number;
    /**
     * ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf to null.
     * @type {number}
     * @memberof FieldConfig
     */
    'min'?: number;
    /**
     * Alternative to empty string
     * @type {string}
     * @memberof FieldConfig
     */
    'noValue'?: string;
    /**
     * Path is an explicit path to the field in the datasource. When the frame meta includes a path, this will default to `${frame.meta.path}/${field.name}  When defined, this value can be used as an identifier within the datasource scope, and may be used as an identifier to update values in a subsequent request
     * @type {string}
     * @memberof FieldConfig
     */
    'path'?: string;
    /**
     * 
     * @type {ThresholdsConfig}
     * @memberof FieldConfig
     */
    'thresholds'?: ThresholdsConfig;
    /**
     * 
     * @type {FieldTypeConfig}
     * @memberof FieldConfig
     */
    'type'?: FieldTypeConfig;
    /**
     * Numeric Options
     * @type {string}
     * @memberof FieldConfig
     */
    'unit'?: string;
    /**
     * Writeable indicates that the datasource knows how to update this value
     * @type {boolean}
     * @memberof FieldConfig
     */
    'writeable'?: boolean;
}
/**
 * FieldTypeConfig has type specific configs, only one should be active at a time
 * @export
 * @interface FieldTypeConfig
 */
export interface FieldTypeConfig {
    /**
     * 
     * @type {EnumFieldConfig}
     * @memberof FieldTypeConfig
     */
    'enum'?: EnumFieldConfig;
}
/**
 * 
 * @export
 * @interface FindTagsResult
 */
export interface FindTagsResult {
    /**
     * 
     * @type {Array<TagsDTO>}
     * @memberof FindTagsResult
     */
    'tags'?: Array<TagsDTO>;
}
/**
 * A FloatHistogram is needed by PromQL to handle operations that might result in fractional counts. Since the counts in a histogram are unlikely to be too large to be represented precisely by a float64, a FloatHistogram can also be used to represent a histogram with integer counts and thus serves as a more generalized representation.
 * @export
 * @interface FloatHistogram
 */
export interface FloatHistogram {
    /**
     * Total number of observations. Must be zero or positive.
     * @type {number}
     * @memberof FloatHistogram
     */
    'Count'?: number;
    /**
     * or alternatively that we are dealing with a gauge histogram, where counter resets do not apply.
     * @type {number}
     * @memberof FloatHistogram
     */
    'CounterResetHint'?: number;
    /**
     * Observation counts in buckets. Each represents an absolute count and must be zero or positive.
     * @type {Array<number>}
     * @memberof FloatHistogram
     */
    'PositiveBuckets'?: Array<number>;
    /**
     * Spans for positive and negative buckets (see Span below).
     * @type {Array<Span>}
     * @memberof FloatHistogram
     */
    'PositiveSpans'?: Array<Span>;
    /**
     * Currently valid schema numbers are -4 <= n <= 8.  They are all for base-2 bucket schemas, where 1 is a bucket boundary in each case, and then each power of two is divided into 2^n logarithmic buckets.  Or in other words, each bucket boundary is the previous boundary times 2^(2^-n).
     * @type {number}
     * @memberof FloatHistogram
     */
    'Schema'?: number;
    /**
     * Sum of observations. This is also used as the stale marker.
     * @type {number}
     * @memberof FloatHistogram
     */
    'Sum'?: number;
    /**
     * Observations falling into the zero bucket. Must be zero or positive.
     * @type {number}
     * @memberof FloatHistogram
     */
    'ZeroCount'?: number;
    /**
     * Width of the zero bucket.
     * @type {number}
     * @memberof FloatHistogram
     */
    'ZeroThreshold'?: number;
}
/**
 * 
 * @export
 * @interface Folder
 */
export interface Folder {
    /**
     * Metadata contains user accesses for a given resource Ex: map[string]bool{\"create\":true, \"delete\": true}
     * @type {{ [key: string]: boolean; }}
     * @memberof Folder
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'canAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'canDelete'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'canEdit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'canSave'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'createdBy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Folder
     */
    'hasAcl'?: boolean;
    /**
     * Deprecated: use UID instead
     * @type {number}
     * @memberof Folder
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'orgId'?: number;
    /**
     * only used if nested folders are enabled
     * @type {string}
     * @memberof Folder
     */
    'parentUid'?: string;
    /**
     * the parent folders starting from the root going down
     * @type {Array<Folder>}
     * @memberof Folder
     */
    'parents'?: Array<Folder>;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'updated'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Folder
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Folder
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface FolderSearchHit
 */
export interface FolderSearchHit {
    /**
     * 
     * @type {number}
     * @memberof FolderSearchHit
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FolderSearchHit
     */
    'parentUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderSearchHit
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FolderSearchHit
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {PublicError}
     * @memberof ForbiddenError
     */
    'body'?: PublicError;
}
/**
 * Each Field is well typed by its FieldType and supports optional Labels.  A Frame is a general data container for Grafana. A Frame can be table data or time series data depending on its content and field types.
 * @export
 * @interface Frame
 */
export interface Frame {
    /**
     * Fields are the columns of a frame. All Fields must be of the same the length when marshalling the Frame for transmission. There should be no `nil` entries in the Fields slice (making them pointers was a mistake).
     * @type {Array<Field>}
     * @memberof Frame
     */
    'Fields'?: Array<Field>;
    /**
     * 
     * @type {FrameMeta}
     * @memberof Frame
     */
    'Meta'?: FrameMeta;
    /**
     * Name is used in some Grafana visualizations.
     * @type {string}
     * @memberof Frame
     */
    'Name'?: string;
    /**
     * RefID is a property that can be set to match a Frame to its originating query.
     * @type {string}
     * @memberof Frame
     */
    'RefID'?: string;
}
/**
 * https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L11 NOTE -- in javascript this can accept any `[key: string]: any;` however this interface only exposes the values we want to be exposed
 * @export
 * @interface FrameMeta
 */
export interface FrameMeta {
    /**
     * Channel is the path to a stream in grafana live that has real-time updates for this data.
     * @type {string}
     * @memberof FrameMeta
     */
    'channel'?: string;
    /**
     * Custom datasource specific values.
     * @type {any}
     * @memberof FrameMeta
     */
    'custom'?: any;
    /**
     * nolint:revive
     * @type {string}
     * @memberof FrameMeta
     */
    'dataTopic'?: string;
    /**
     * ExecutedQueryString is the raw query sent to the underlying system. All macros and templating have been applied.  When metadata contains this value, it will be shown in the query inspector.
     * @type {string}
     * @memberof FrameMeta
     */
    'executedQueryString'?: string;
    /**
     * Notices provide additional information about the data in the Frame that Grafana can display to the user in the user interface.
     * @type {Array<Notice>}
     * @memberof FrameMeta
     */
    'notices'?: Array<Notice>;
    /**
     * Path is a browsable path on the datasource.
     * @type {string}
     * @memberof FrameMeta
     */
    'path'?: string;
    /**
     * PathSeparator defines the separator pattern to decode a hierarchy. The default separator is \'/\'.
     * @type {string}
     * @memberof FrameMeta
     */
    'pathSeparator'?: string;
    /**
     * PreferredVisualizationPluginId sets the panel plugin id to use to render the data when using Explore. If the plugin cannot be found will fall back to PreferredVisualization.
     * @type {string}
     * @memberof FrameMeta
     */
    'preferredVisualisationPluginId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FrameMeta
     */
    'preferredVisualisationType'?: string;
    /**
     * Stats is an array of query result statistics.
     * @type {Array<QueryStat>}
     * @memberof FrameMeta
     */
    'stats'?: Array<QueryStat>;
    /**
     * A FrameType string, when present in a frame\'s metadata, asserts that the frame\'s structure conforms to the FrameType\'s specification. This property is currently optional, so FrameType may be FrameTypeUnknown even if the properties of the Frame correspond to a defined FrameType. +enum
     * @type {string}
     * @memberof FrameMeta
     */
    'type'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof FrameMeta
     */
    'typeVersion'?: Array<number>;
    /**
     * Array of field indices which values create a unique id for each row. Ideally this should be globally unique ID but that isn\'t guarantied. Should help with keeping track and deduplicating rows in visualizations, especially with streaming data with frequent updates.
     * @type {Array<number>}
     * @memberof FrameMeta
     */
    'uniqueRowIdFields'?: Array<number>;
}
/**
 * 
 * @export
 * @interface GetAccessTokenResponseDTO
 */
export interface GetAccessTokenResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'expiresAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'firstUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetAccessTokenResponseDTO
     */
    'lastUsedAt'?: string;
}
/**
 * 
 * @export
 * @interface GetAnnotationTagsResponse
 */
export interface GetAnnotationTagsResponse {
    /**
     * 
     * @type {FindTagsResult}
     * @memberof GetAnnotationTagsResponse
     */
    'result'?: FindTagsResult;
}
/**
 * 
 * @export
 * @interface GetDataSourceIdByName200Response
 */
export interface GetDataSourceIdByName200Response {
    /**
     * ID Identifier of the data source.
     * @type {number}
     * @memberof GetDataSourceIdByName200Response
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface GetHomeDashboardResponse
 */
export interface GetHomeDashboardResponse {
    /**
     * 
     * @type {object}
     * @memberof GetHomeDashboardResponse
     */
    'dashboard'?: object;
    /**
     * 
     * @type {DashboardMeta}
     * @memberof GetHomeDashboardResponse
     */
    'meta'?: DashboardMeta;
    /**
     * 
     * @type {string}
     * @memberof GetHomeDashboardResponse
     */
    'redirectUri'?: string;
}
/**
 * 
 * @export
 * @interface GetSharingOptions200Response
 */
export interface GetSharingOptions200Response {
    /**
     * 
     * @type {boolean}
     * @memberof GetSharingOptions200Response
     */
    'externalEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSharingOptions200Response
     */
    'externalSnapshotName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSharingOptions200Response
     */
    'externalSnapshotURL'?: string;
}
/**
 * 
 * @export
 * @interface GetSnapshotResponseDTO
 */
export interface GetSnapshotResponseDTO {
    /**
     * 
     * @type {string}
     * @memberof GetSnapshotResponseDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSnapshotResponseDTO
     */
    'finished'?: string;
    /**
     * 
     * @type {Array<MigrateDataResponseItemDTO>}
     * @memberof GetSnapshotResponseDTO
     */
    'results'?: Array<MigrateDataResponseItemDTO>;
    /**
     * 
     * @type {string}
     * @memberof GetSnapshotResponseDTO
     */
    'sessionUid'?: string;
    /**
     * 
     * @type {SnapshotResourceStats}
     * @memberof GetSnapshotResponseDTO
     */
    'stats'?: SnapshotResourceStats;
    /**
     * 
     * @type {string}
     * @memberof GetSnapshotResponseDTO
     */
    'status'?: GetSnapshotResponseDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetSnapshotResponseDTO
     */
    'uid'?: string;
}

export const GetSnapshotResponseDTOStatusEnum = {
    Initializing: 'INITIALIZING',
    Creating: 'CREATING',
    PendingUpload: 'PENDING_UPLOAD',
    Uploading: 'UPLOADING',
    PendingProcessing: 'PENDING_PROCESSING',
    Processing: 'PROCESSING',
    Finished: 'FINISHED',
    Canceled: 'CANCELED',
    Error: 'ERROR',
    Unknown: 'UNKNOWN'
} as const;

export type GetSnapshotResponseDTOStatusEnum = typeof GetSnapshotResponseDTOStatusEnum[keyof typeof GetSnapshotResponseDTOStatusEnum];

/**
 * GettableAlert gettable alert
 * @export
 * @interface GettableAlert
 */
export interface GettableAlert {
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof GettableAlert
     */
    'annotations': { [key: string]: string; };
    /**
     * ends at
     * @type {string}
     * @memberof GettableAlert
     */
    'endsAt': string;
    /**
     * fingerprint
     * @type {string}
     * @memberof GettableAlert
     */
    'fingerprint': string;
    /**
     * generator URL Format: uri
     * @type {string}
     * @memberof GettableAlert
     */
    'generatorURL'?: string;
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof GettableAlert
     */
    'labels': { [key: string]: string; };
    /**
     * receivers
     * @type {Array<Receiver>}
     * @memberof GettableAlert
     */
    'receivers': Array<Receiver>;
    /**
     * starts at
     * @type {string}
     * @memberof GettableAlert
     */
    'startsAt': string;
    /**
     * 
     * @type {AlertStatus}
     * @memberof GettableAlert
     */
    'status': AlertStatus;
    /**
     * updated at
     * @type {string}
     * @memberof GettableAlert
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GettableAlertmanagers
 */
export interface GettableAlertmanagers {
    /**
     * 
     * @type {AlertManagersResult}
     * @memberof GettableAlertmanagers
     */
    'data'?: AlertManagersResult;
    /**
     * 
     * @type {string}
     * @memberof GettableAlertmanagers
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GettableApiAlertingConfig
 */
export interface GettableApiAlertingConfig {
    /**
     * 
     * @type {GlobalConfig}
     * @memberof GettableApiAlertingConfig
     */
    'global'?: GlobalConfig;
    /**
     * 
     * @type {Array<InhibitRule>}
     * @memberof GettableApiAlertingConfig
     */
    'inhibit_rules'?: Array<InhibitRule>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableApiAlertingConfig
     */
    'muteTimeProvenances'?: { [key: string]: string; };
    /**
     * MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.
     * @type {Array<MuteTimeInterval>}
     * @memberof GettableApiAlertingConfig
     */
    'mute_time_intervals'?: Array<MuteTimeInterval>;
    /**
     * Override with our superset receiver type
     * @type {Array<GettableApiReceiver>}
     * @memberof GettableApiAlertingConfig
     */
    'receivers'?: Array<GettableApiReceiver>;
    /**
     * 
     * @type {Route}
     * @memberof GettableApiAlertingConfig
     */
    'route'?: Route;
    /**
     * 
     * @type {Array<string>}
     * @memberof GettableApiAlertingConfig
     */
    'templates'?: Array<string>;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof GettableApiAlertingConfig
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * 
 * @export
 * @interface GettableApiReceiver
 */
export interface GettableApiReceiver {
    /**
     * 
     * @type {Array<DiscordConfig>}
     * @memberof GettableApiReceiver
     */
    'discord_configs'?: Array<DiscordConfig>;
    /**
     * 
     * @type {Array<EmailConfig>}
     * @memberof GettableApiReceiver
     */
    'email_configs'?: Array<EmailConfig>;
    /**
     * 
     * @type {Array<GettableGrafanaReceiver>}
     * @memberof GettableApiReceiver
     */
    'grafana_managed_receiver_configs'?: Array<GettableGrafanaReceiver>;
    /**
     * 
     * @type {Array<MSTeamsConfig>}
     * @memberof GettableApiReceiver
     */
    'msteams_configs'?: Array<MSTeamsConfig>;
    /**
     * A unique identifier for this receiver.
     * @type {string}
     * @memberof GettableApiReceiver
     */
    'name'?: string;
    /**
     * 
     * @type {Array<OpsGenieConfig>}
     * @memberof GettableApiReceiver
     */
    'opsgenie_configs'?: Array<OpsGenieConfig>;
    /**
     * 
     * @type {Array<PagerdutyConfig>}
     * @memberof GettableApiReceiver
     */
    'pagerduty_configs'?: Array<PagerdutyConfig>;
    /**
     * 
     * @type {Array<PushoverConfig>}
     * @memberof GettableApiReceiver
     */
    'pushover_configs'?: Array<PushoverConfig>;
    /**
     * 
     * @type {Array<SlackConfig>}
     * @memberof GettableApiReceiver
     */
    'slack_configs'?: Array<SlackConfig>;
    /**
     * 
     * @type {Array<SNSConfig>}
     * @memberof GettableApiReceiver
     */
    'sns_configs'?: Array<SNSConfig>;
    /**
     * 
     * @type {Array<TelegramConfig>}
     * @memberof GettableApiReceiver
     */
    'telegram_configs'?: Array<TelegramConfig>;
    /**
     * 
     * @type {Array<VictorOpsConfig>}
     * @memberof GettableApiReceiver
     */
    'victorops_configs'?: Array<VictorOpsConfig>;
    /**
     * 
     * @type {Array<WebexConfig>}
     * @memberof GettableApiReceiver
     */
    'webex_configs'?: Array<WebexConfig>;
    /**
     * 
     * @type {Array<WebhookConfig>}
     * @memberof GettableApiReceiver
     */
    'webhook_configs'?: Array<WebhookConfig>;
    /**
     * 
     * @type {Array<WechatConfig>}
     * @memberof GettableApiReceiver
     */
    'wechat_configs'?: Array<WechatConfig>;
}
/**
 * 
 * @export
 * @interface GettableExtendedRuleNode
 */
export interface GettableExtendedRuleNode {
    /**
     * 
     * @type {string}
     * @memberof GettableExtendedRuleNode
     */
    'alert'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableExtendedRuleNode
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GettableExtendedRuleNode
     */
    'expr'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableExtendedRuleNode
     */
    'for'?: string;
    /**
     * 
     * @type {GettableGrafanaRule}
     * @memberof GettableExtendedRuleNode
     */
    'grafana_alert'?: GettableGrafanaRule;
    /**
     * 
     * @type {string}
     * @memberof GettableExtendedRuleNode
     */
    'keep_firing_for'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableExtendedRuleNode
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof GettableExtendedRuleNode
     */
    'record'?: string;
}
/**
 * 
 * @export
 * @interface GettableGrafanaReceiver
 */
export interface GettableGrafanaReceiver {
    /**
     * 
     * @type {boolean}
     * @memberof GettableGrafanaReceiver
     */
    'disableResolveMessage'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaReceiver
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaReceiver
     */
    'provenance'?: string;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof GettableGrafanaReceiver
     */
    'secureFields'?: { [key: string]: boolean; };
    /**
     * 
     * @type {object}
     * @memberof GettableGrafanaReceiver
     */
    'settings'?: object;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaReceiver
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaReceiver
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface GettableGrafanaReceivers
 */
export interface GettableGrafanaReceivers {
    /**
     * 
     * @type {Array<GettableGrafanaReceiver>}
     * @memberof GettableGrafanaReceivers
     */
    'grafana_managed_receiver_configs'?: Array<GettableGrafanaReceiver>;
}
/**
 * 
 * @export
 * @interface GettableGrafanaRule
 */
export interface GettableGrafanaRule {
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof GettableGrafanaRule
     */
    'data'?: Array<AlertQuery>;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'exec_err_state'?: GettableGrafanaRuleExecErrStateEnum;
    /**
     * 
     * @type {number}
     * @memberof GettableGrafanaRule
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof GettableGrafanaRule
     */
    'intervalSeconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GettableGrafanaRule
     */
    'is_paused'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'namespace_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'no_data_state'?: GettableGrafanaRuleNoDataStateEnum;
    /**
     * 
     * @type {AlertRuleNotificationSettings}
     * @memberof GettableGrafanaRule
     */
    'notification_settings'?: AlertRuleNotificationSettings;
    /**
     * 
     * @type {number}
     * @memberof GettableGrafanaRule
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'provenance'?: string;
    /**
     * 
     * @type {Record}
     * @memberof GettableGrafanaRule
     */
    'record'?: Record;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'rule_group'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableGrafanaRule
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof GettableGrafanaRule
     */
    'version'?: number;
}

export const GettableGrafanaRuleExecErrStateEnum = {
    Ok: 'OK',
    Alerting: 'Alerting',
    Error: 'Error'
} as const;

export type GettableGrafanaRuleExecErrStateEnum = typeof GettableGrafanaRuleExecErrStateEnum[keyof typeof GettableGrafanaRuleExecErrStateEnum];
export const GettableGrafanaRuleNoDataStateEnum = {
    Alerting: 'Alerting',
    NoData: 'NoData',
    Ok: 'OK'
} as const;

export type GettableGrafanaRuleNoDataStateEnum = typeof GettableGrafanaRuleNoDataStateEnum[keyof typeof GettableGrafanaRuleNoDataStateEnum];

/**
 * 
 * @export
 * @interface GettableGrafanaSilence
 */
export interface GettableGrafanaSilence {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof GettableGrafanaSilence
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * comment
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'comment': string;
    /**
     * created by
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'createdBy': string;
    /**
     * ends at
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'endsAt': string;
    /**
     * id
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'id': string;
    /**
     * Matchers matchers
     * @type {Array<Matcher>}
     * @memberof GettableGrafanaSilence
     */
    'matchers': Array<Matcher>;
    /**
     * 
     * @type {SilenceMetadata}
     * @memberof GettableGrafanaSilence
     */
    'metadata'?: SilenceMetadata;
    /**
     * starts at
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'startsAt': string;
    /**
     * 
     * @type {SilenceStatus}
     * @memberof GettableGrafanaSilence
     */
    'status': SilenceStatus;
    /**
     * updated at
     * @type {string}
     * @memberof GettableGrafanaSilence
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GettableHistoricUserConfig
 */
export interface GettableHistoricUserConfig {
    /**
     * 
     * @type {GettableApiAlertingConfig}
     * @memberof GettableHistoricUserConfig
     */
    'alertmanager_config'?: GettableApiAlertingConfig;
    /**
     * 
     * @type {number}
     * @memberof GettableHistoricUserConfig
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GettableHistoricUserConfig
     */
    'last_applied'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableHistoricUserConfig
     */
    'template_file_provenances'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableHistoricUserConfig
     */
    'template_files'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GettableNGalertConfig
 */
export interface GettableNGalertConfig {
    /**
     * 
     * @type {string}
     * @memberof GettableNGalertConfig
     */
    'alertmanagersChoice'?: GettableNGalertConfigAlertmanagersChoiceEnum;
}

export const GettableNGalertConfigAlertmanagersChoiceEnum = {
    All: 'all',
    Internal: 'internal',
    External: 'external'
} as const;

export type GettableNGalertConfigAlertmanagersChoiceEnum = typeof GettableNGalertConfigAlertmanagersChoiceEnum[keyof typeof GettableNGalertConfigAlertmanagersChoiceEnum];

/**
 * 
 * @export
 * @interface GettableRuleGroupConfig
 */
export interface GettableRuleGroupConfig {
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof GettableRuleGroupConfig
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof GettableRuleGroupConfig
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GettableExtendedRuleNode>}
     * @memberof GettableRuleGroupConfig
     */
    'rules'?: Array<GettableExtendedRuleNode>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GettableRuleGroupConfig
     */
    'source_tenants'?: Array<string>;
}
/**
 * GettableSilence gettable silence
 * @export
 * @interface GettableSilence
 */
export interface GettableSilence {
    /**
     * comment
     * @type {string}
     * @memberof GettableSilence
     */
    'comment': string;
    /**
     * created by
     * @type {string}
     * @memberof GettableSilence
     */
    'createdBy': string;
    /**
     * ends at
     * @type {string}
     * @memberof GettableSilence
     */
    'endsAt': string;
    /**
     * id
     * @type {string}
     * @memberof GettableSilence
     */
    'id': string;
    /**
     * Matchers matchers
     * @type {Array<Matcher>}
     * @memberof GettableSilence
     */
    'matchers': Array<Matcher>;
    /**
     * starts at
     * @type {string}
     * @memberof GettableSilence
     */
    'startsAt': string;
    /**
     * 
     * @type {SilenceStatus}
     * @memberof GettableSilence
     */
    'status': SilenceStatus;
    /**
     * updated at
     * @type {string}
     * @memberof GettableSilence
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GettableStatus
 */
export interface GettableStatus {
    /**
     * 
     * @type {ClusterStatus}
     * @memberof GettableStatus
     */
    'cluster': ClusterStatus;
    /**
     * 
     * @type {PostableApiAlertingConfig}
     * @memberof GettableStatus
     */
    'config': PostableApiAlertingConfig;
    /**
     * uptime
     * @type {string}
     * @memberof GettableStatus
     */
    'uptime': string;
    /**
     * 
     * @type {VersionInfo}
     * @memberof GettableStatus
     */
    'versionInfo': VersionInfo;
}
/**
 * 
 * @export
 * @interface GettableTimeIntervals
 */
export interface GettableTimeIntervals {
    /**
     * 
     * @type {string}
     * @memberof GettableTimeIntervals
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GettableTimeIntervals
     */
    'provenance'?: string;
    /**
     * 
     * @type {Array<TimeIntervalItem>}
     * @memberof GettableTimeIntervals
     */
    'time_intervals'?: Array<TimeIntervalItem>;
    /**
     * 
     * @type {string}
     * @memberof GettableTimeIntervals
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface GettableUserConfig
 */
export interface GettableUserConfig {
    /**
     * 
     * @type {GettableApiAlertingConfig}
     * @memberof GettableUserConfig
     */
    'alertmanager_config'?: GettableApiAlertingConfig;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableUserConfig
     */
    'template_file_provenances'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GettableUserConfig
     */
    'template_files'?: { [key: string]: string; };
}
/**
 * GlobalConfig defines configuration parameters that are valid globally unless overwritten.
 * @export
 * @interface GlobalConfig
 */
export interface GlobalConfig {
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof GlobalConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'opsgenie_api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'opsgenie_api_key_file'?: string;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'opsgenie_api_url'?: URL;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'pagerduty_url'?: URL;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof GlobalConfig
     */
    'resolve_timeout'?: number;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'slack_api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'slack_api_url_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_auth_identity'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_auth_password'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_auth_password_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_auth_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_auth_username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_from'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'smtp_hello'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GlobalConfig
     */
    'smtp_require_tls'?: boolean;
    /**
     * 
     * @type {HostPort}
     * @memberof GlobalConfig
     */
    'smtp_smarthost'?: HostPort;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'telegram_api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'victorops_api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'victorops_api_key_file'?: string;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'victorops_api_url'?: URL;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'webex_api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'wechat_api_corp_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GlobalConfig
     */
    'wechat_api_secret'?: string;
    /**
     * 
     * @type {URL}
     * @memberof GlobalConfig
     */
    'wechat_api_url'?: URL;
}
/**
 * 
 * @export
 * @interface HTTPClientConfig
 */
export interface HTTPClientConfig {
    /**
     * 
     * @type {Authorization}
     * @memberof HTTPClientConfig
     */
    'authorization'?: Authorization;
    /**
     * 
     * @type {BasicAuth}
     * @memberof HTTPClientConfig
     */
    'basic_auth'?: BasicAuth;
    /**
     * 
     * @type {string}
     * @memberof HTTPClientConfig
     */
    'bearer_token'?: string;
    /**
     * The bearer token file for the targets. Deprecated in favour of Authorization.CredentialsFile.
     * @type {string}
     * @memberof HTTPClientConfig
     */
    'bearer_token_file'?: string;
    /**
     * EnableHTTP2 specifies whether the client should configure HTTP2. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.
     * @type {boolean}
     * @memberof HTTPClientConfig
     */
    'enable_http2'?: boolean;
    /**
     * FollowRedirects specifies whether the client should follow HTTP 3xx redirects. The omitempty flag is not set, because it would be hidden from the marshalled configuration when set to false.
     * @type {boolean}
     * @memberof HTTPClientConfig
     */
    'follow_redirects'?: boolean;
    /**
     * 
     * @type {Headers}
     * @memberof HTTPClientConfig
     */
    'http_headers'?: Headers;
    /**
     * NoProxy contains addresses that should not use a proxy.
     * @type {string}
     * @memberof HTTPClientConfig
     */
    'no_proxy'?: string;
    /**
     * 
     * @type {OAuth2}
     * @memberof HTTPClientConfig
     */
    'oauth2'?: OAuth2;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof HTTPClientConfig
     */
    'proxy_connect_header'?: { [key: string]: Array<string>; };
    /**
     * ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.
     * @type {boolean}
     * @memberof HTTPClientConfig
     */
    'proxy_from_environment'?: boolean;
    /**
     * 
     * @type {URL}
     * @memberof HTTPClientConfig
     */
    'proxy_url'?: URL;
    /**
     * 
     * @type {TLSConfig}
     * @memberof HTTPClientConfig
     */
    'tls_config'?: TLSConfig;
}
/**
 * 
 * @export
 * @interface Header
 */
export interface Header {
    /**
     * 
     * @type {Array<string>}
     * @memberof Header
     */
    'files'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Header
     */
    'secrets'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Header
     */
    'values'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Headers
 */
export interface Headers {
    /**
     * 
     * @type {{ [key: string]: Header; }}
     * @memberof Headers
     */
    'Headers'?: { [key: string]: Header; };
}
/**
 * 
 * @export
 * @interface HealthResponse
 */
export interface HealthResponse {
    /**
     * 
     * @type {string}
     * @memberof HealthResponse
     */
    'commit'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponse
     */
    'database'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponse
     */
    'enterpriseCommit'?: string;
    /**
     * 
     * @type {string}
     * @memberof HealthResponse
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface Hit
 */
export interface Hit {
    /**
     * 
     * @type {number}
     * @memberof Hit
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'folderTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'folderUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'folderUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Hit
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Hit
     */
    'isDeleted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Hit
     */
    'isStarred'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'permanentlyDeleteDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof Hit
     */
    'sortMeta'?: number;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'sortMetaName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Hit
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Hit
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface HostPort
 */
export interface HostPort {
    /**
     * 
     * @type {string}
     * @memberof HostPort
     */
    'Host'?: string;
    /**
     * 
     * @type {string}
     * @memberof HostPort
     */
    'Port'?: string;
}
/**
 * 
 * @export
 * @interface IPNet
 */
export interface IPNet {
    /**
     * 
     * @type {string}
     * @memberof IPNet
     */
    'IP'?: string;
    /**
     * See type [IPNet] and func [ParseCIDR] for details.
     * @type {Array<number>}
     * @memberof IPNet
     */
    'Mask'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ImportDashboardInput
 */
export interface ImportDashboardInput {
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardInput
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardInput
     */
    'pluginId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardInput
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardInput
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ImportDashboardRequest
 */
export interface ImportDashboardRequest {
    /**
     * 
     * @type {object}
     * @memberof ImportDashboardRequest
     */
    'dashboard'?: object;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof ImportDashboardRequest
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardRequest
     */
    'folderUid'?: string;
    /**
     * 
     * @type {Array<ImportDashboardInput>}
     * @memberof ImportDashboardRequest
     */
    'inputs'?: Array<ImportDashboardInput>;
    /**
     * 
     * @type {boolean}
     * @memberof ImportDashboardRequest
     */
    'overwrite'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardRequest
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardRequest
     */
    'pluginId'?: string;
}
/**
 * 
 * @export
 * @interface ImportDashboardResponse
 */
export interface ImportDashboardResponse {
    /**
     * 
     * @type {number}
     * @memberof ImportDashboardResponse
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'description'?: string;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof ImportDashboardResponse
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'folderUid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportDashboardResponse
     */
    'imported'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ImportDashboardResponse
     */
    'importedRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'importedUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'importedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'pluginId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportDashboardResponse
     */
    'removed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ImportDashboardResponse
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportDashboardResponse
     */
    'uid'?: string;
}
/**
 * InhibitRule defines an inhibition rule that mutes alerts that match the target labels if an alert matching the source labels exists. Both alerts have to have a set of labels being equal.
 * @export
 * @interface InhibitRule
 */
export interface InhibitRule {
    /**
     * 
     * @type {Array<string>}
     * @memberof InhibitRule
     */
    'equal'?: Array<string>;
    /**
     * SourceMatch defines a set of labels that have to equal the given value for source alerts. Deprecated. Remove before v1.0 release.
     * @type {{ [key: string]: string; }}
     * @memberof InhibitRule
     */
    'source_match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InhibitRule
     */
    'source_match_re'?: { [key: string]: string; };
    /**
     * Matchers is a slice of Matchers that is sortable, implements Stringer, and provides a Matches method to match a LabelSet against all Matchers in the slice. Note that some users of Matchers might require it to be sorted.
     * @type {Array<Matcher>}
     * @memberof InhibitRule
     */
    'source_matchers'?: Array<Matcher>;
    /**
     * TargetMatch defines a set of labels that have to equal the given value for target alerts. Deprecated. Remove before v1.0 release.
     * @type {{ [key: string]: string; }}
     * @memberof InhibitRule
     */
    'target_match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof InhibitRule
     */
    'target_match_re'?: { [key: string]: string; };
    /**
     * Matchers is a slice of Matchers that is sortable, implements Stringer, and provides a Matches method to match a LabelSet against all Matchers in the slice. Note that some users of Matchers might require it to be sorted.
     * @type {Array<Matcher>}
     * @memberof InhibitRule
     */
    'target_matchers'?: Array<Matcher>;
}
/**
 * InternalDataLink definition to allow Explore links to be constructed in the backend
 * @export
 * @interface InternalDataLink
 */
export interface InternalDataLink {
    /**
     * 
     * @type {string}
     * @memberof InternalDataLink
     */
    'datasourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalDataLink
     */
    'datasourceUid'?: string;
    /**
     * This is an object constructed with the keys as the values of the enum VisType and the value being a bag of properties
     * @type {any}
     * @memberof InternalDataLink
     */
    'panelsState'?: any;
    /**
     * 
     * @type {any}
     * @memberof InternalDataLink
     */
    'query'?: any;
    /**
     * 
     * @type {TimeRange}
     * @memberof InternalDataLink
     */
    'timeRange'?: TimeRange;
    /**
     * 
     * @type {Array<LinkTransformationConfig>}
     * @memberof InternalDataLink
     */
    'transformations'?: Array<LinkTransformationConfig>;
}
/**
 * JSONWebKey represents a public or private key in JWK format. It can be marshaled into JSON and unmarshaled from JSON.
 * @export
 * @interface JSONWebKey
 */
export interface JSONWebKey {
    /**
     * Key algorithm, parsed from `alg` header.
     * @type {string}
     * @memberof JSONWebKey
     */
    'Algorithm'?: string;
    /**
     * X.509 certificate thumbprint (SHA-1), parsed from `x5t` header.
     * @type {Array<number>}
     * @memberof JSONWebKey
     */
    'CertificateThumbprintSHA1'?: Array<number>;
    /**
     * X.509 certificate thumbprint (SHA-256), parsed from `x5t#S256` header.
     * @type {Array<number>}
     * @memberof JSONWebKey
     */
    'CertificateThumbprintSHA256'?: Array<number>;
    /**
     * X.509 certificate chain, parsed from `x5c` header.
     * @type {Array<Certificate>}
     * @memberof JSONWebKey
     */
    'Certificates'?: Array<Certificate>;
    /**
     * 
     * @type {URL}
     * @memberof JSONWebKey
     */
    'CertificatesURL'?: URL;
    /**
     * Key is the Go in-memory representation of this key. It must have one of these types: ed25519.PublicKey ed25519.PrivateKey ecdsa.PublicKey ecdsa.PrivateKey rsa.PublicKey rsa.PrivateKey []byte (a symmetric key)  When marshaling this JSONWebKey into JSON, the \"kty\" header parameter will be automatically set based on the type of this field.
     * @type {any}
     * @memberof JSONWebKey
     */
    'Key'?: any;
    /**
     * Key identifier, parsed from `kid` header.
     * @type {string}
     * @memberof JSONWebKey
     */
    'KeyID'?: string;
    /**
     * Key use, parsed from `use` header.
     * @type {string}
     * @memberof JSONWebKey
     */
    'Use'?: string;
}
/**
 * 
 * @export
 * @interface Label
 */
export interface Label {
    /**
     * 
     * @type {string}
     * @memberof Label
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface LibraryElementArrayResponse
 */
export interface LibraryElementArrayResponse {
    /**
     * 
     * @type {Array<LibraryElementDTO>}
     * @memberof LibraryElementArrayResponse
     */
    'result'?: Array<LibraryElementDTO>;
}
/**
 * 
 * @export
 * @interface LibraryElementConnectionDTO
 */
export interface LibraryElementConnectionDTO {
    /**
     * 
     * @type {number}
     * @memberof LibraryElementConnectionDTO
     */
    'connectionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementConnectionDTO
     */
    'connectionUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementConnectionDTO
     */
    'created'?: string;
    /**
     * 
     * @type {LibraryElementDTOMetaUser}
     * @memberof LibraryElementConnectionDTO
     */
    'createdBy'?: LibraryElementDTOMetaUser;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementConnectionDTO
     */
    'elementId'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementConnectionDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementConnectionDTO
     */
    'kind'?: number;
}
/**
 * 
 * @export
 * @interface LibraryElementConnectionsResponse
 */
export interface LibraryElementConnectionsResponse {
    /**
     * 
     * @type {Array<LibraryElementConnectionDTO>}
     * @memberof LibraryElementConnectionsResponse
     */
    'result'?: Array<LibraryElementConnectionDTO>;
}
/**
 * 
 * @export
 * @interface LibraryElementDTO
 */
export interface LibraryElementDTO {
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTO
     */
    'description'?: string;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTO
     */
    'folderUid'?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'kind'?: number;
    /**
     * 
     * @type {LibraryElementDTOMeta}
     * @memberof LibraryElementDTO
     */
    'meta'?: LibraryElementDTOMeta;
    /**
     * 
     * @type {object}
     * @memberof LibraryElementDTO
     */
    'model'?: object;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'schemaVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTO
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface LibraryElementDTOMeta
 */
export interface LibraryElementDTOMeta {
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTOMeta
     */
    'connectedDashboards'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMeta
     */
    'created'?: string;
    /**
     * 
     * @type {LibraryElementDTOMetaUser}
     * @memberof LibraryElementDTOMeta
     */
    'createdBy'?: LibraryElementDTOMetaUser;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMeta
     */
    'folderName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMeta
     */
    'folderUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMeta
     */
    'updated'?: string;
    /**
     * 
     * @type {LibraryElementDTOMetaUser}
     * @memberof LibraryElementDTOMeta
     */
    'updatedBy'?: LibraryElementDTOMetaUser;
}
/**
 * 
 * @export
 * @interface LibraryElementDTOMetaUser
 */
export interface LibraryElementDTOMetaUser {
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMetaUser
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementDTOMetaUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LibraryElementDTOMetaUser
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface LibraryElementResponse
 */
export interface LibraryElementResponse {
    /**
     * 
     * @type {LibraryElementDTO}
     * @memberof LibraryElementResponse
     */
    'result'?: LibraryElementDTO;
}
/**
 * 
 * @export
 * @interface LibraryElementSearchResponse
 */
export interface LibraryElementSearchResponse {
    /**
     * 
     * @type {LibraryElementSearchResult}
     * @memberof LibraryElementSearchResponse
     */
    'result'?: LibraryElementSearchResult;
}
/**
 * 
 * @export
 * @interface LibraryElementSearchResult
 */
export interface LibraryElementSearchResult {
    /**
     * 
     * @type {Array<LibraryElementDTO>}
     * @memberof LibraryElementSearchResult
     */
    'elements'?: Array<LibraryElementDTO>;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementSearchResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementSearchResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof LibraryElementSearchResult
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface LinkTransformationConfig
 */
export interface LinkTransformationConfig {
    /**
     * 
     * @type {string}
     * @memberof LinkTransformationConfig
     */
    'expression'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkTransformationConfig
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkTransformationConfig
     */
    'mapValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof LinkTransformationConfig
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface ListAllProvidersSettings200ResponseInner
 */
export interface ListAllProvidersSettings200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof ListAllProvidersSettings200ResponseInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListAllProvidersSettings200ResponseInner
     */
    'provider'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ListAllProvidersSettings200ResponseInner
     */
    'settings'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof ListAllProvidersSettings200ResponseInner
     */
    'source'?: string;
}
/**
 * 
 * @export
 * @interface ListSortOptions200Response
 */
export interface ListSortOptions200Response {
    /**
     * 
     * @type {string}
     * @memberof ListSortOptions200Response
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSortOptions200Response
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSortOptions200Response
     */
    'meta'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListSortOptions200Response
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface MSTeamsConfig
 */
export interface MSTeamsConfig {
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof MSTeamsConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {boolean}
     * @memberof MSTeamsConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MSTeamsConfig
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof MSTeamsConfig
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof MSTeamsConfig
     */
    'title'?: string;
    /**
     * 
     * @type {URL}
     * @memberof MSTeamsConfig
     */
    'webhook_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof MSTeamsConfig
     */
    'webhook_url_file'?: string;
}
/**
 * 
 * @export
 * @interface MassDeleteAnnotationsCmd
 */
export interface MassDeleteAnnotationsCmd {
    /**
     * 
     * @type {number}
     * @memberof MassDeleteAnnotationsCmd
     */
    'annotationId'?: number;
    /**
     * 
     * @type {number}
     * @memberof MassDeleteAnnotationsCmd
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof MassDeleteAnnotationsCmd
     */
    'dashboardUID'?: string;
    /**
     * 
     * @type {number}
     * @memberof MassDeleteAnnotationsCmd
     */
    'panelId'?: number;
}
/**
 * Matcher matcher
 * @export
 * @interface Matcher
 */
export interface Matcher {
    /**
     * is equal
     * @type {boolean}
     * @memberof Matcher
     */
    'isEqual'?: boolean;
    /**
     * is regex
     * @type {boolean}
     * @memberof Matcher
     */
    'isRegex': boolean;
    /**
     * name
     * @type {string}
     * @memberof Matcher
     */
    'name': string;
    /**
     * value
     * @type {string}
     * @memberof Matcher
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface MetricRequest
 */
export interface MetricRequest {
    /**
     * 
     * @type {boolean}
     * @memberof MetricRequest
     */
    'debug'?: boolean;
    /**
     * From Start time in epoch timestamps in milliseconds or relative using Grafana time units.
     * @type {string}
     * @memberof MetricRequest
     */
    'from': string;
    /**
     * queries.refId – Specifies an identifier of the query. Is optional and default to “A”. queries.datasourceId – Specifies the data source to be queried. Each query in the request must have an unique datasourceId. queries.maxDataPoints - Species maximum amount of data points that dashboard panel can render. Is optional and default to 100. queries.intervalMs - Specifies the time interval in milliseconds of time series. Is optional and defaults to 1000.
     * @type {Array<object>}
     * @memberof MetricRequest
     */
    'queries': Array<object>;
    /**
     * To End time in epoch timestamps in milliseconds or relative using Grafana time units.
     * @type {string}
     * @memberof MetricRequest
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface MigrateDataResponseDTO
 */
export interface MigrateDataResponseDTO {
    /**
     * 
     * @type {Array<MigrateDataResponseItemDTO>}
     * @memberof MigrateDataResponseDTO
     */
    'items'?: Array<MigrateDataResponseItemDTO>;
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseDTO
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface MigrateDataResponseItemDTO
 */
export interface MigrateDataResponseItemDTO {
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseItemDTO
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseItemDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseItemDTO
     */
    'refId': string;
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseItemDTO
     */
    'status': MigrateDataResponseItemDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseItemDTO
     */
    'type': MigrateDataResponseItemDTOTypeEnum;
}

export const MigrateDataResponseItemDTOStatusEnum = {
    Ok: 'OK',
    Warning: 'WARNING',
    Error: 'ERROR',
    Pending: 'PENDING',
    Unknown: 'UNKNOWN'
} as const;

export type MigrateDataResponseItemDTOStatusEnum = typeof MigrateDataResponseItemDTOStatusEnum[keyof typeof MigrateDataResponseItemDTOStatusEnum];
export const MigrateDataResponseItemDTOTypeEnum = {
    Dashboard: 'DASHBOARD',
    Datasource: 'DATASOURCE',
    Folder: 'FOLDER',
    LibraryElement: 'LIBRARY_ELEMENT'
} as const;

export type MigrateDataResponseItemDTOTypeEnum = typeof MigrateDataResponseItemDTOTypeEnum[keyof typeof MigrateDataResponseItemDTOTypeEnum];

/**
 * 
 * @export
 * @interface MigrateDataResponseListDTO
 */
export interface MigrateDataResponseListDTO {
    /**
     * 
     * @type {string}
     * @memberof MigrateDataResponseListDTO
     */
    'uid'?: string;
}
/**
 * MoveFolderCommand captures the information required by the folder service to move a folder.
 * @export
 * @interface MoveFolderCommand
 */
export interface MoveFolderCommand {
    /**
     * 
     * @type {string}
     * @memberof MoveFolderCommand
     */
    'parentUid'?: string;
}
/**
 * 
 * @export
 * @interface MuteTimeInterval
 */
export interface MuteTimeInterval {
    /**
     * 
     * @type {string}
     * @memberof MuteTimeInterval
     */
    'name'?: string;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof MuteTimeInterval
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * 
 * @export
 * @interface MuteTimeIntervalExport
 */
export interface MuteTimeIntervalExport {
    /**
     * 
     * @type {string}
     * @memberof MuteTimeIntervalExport
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof MuteTimeIntervalExport
     */
    'orgId'?: number;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof MuteTimeIntervalExport
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * Name represents an X.509 distinguished name. This only includes the common elements of a DN. Note that Name is only an approximation of the X.509 structure. If an accurate representation is needed, asn1.Unmarshal the raw subject or issuer as an [RDNSequence].
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    'Country'?: Array<string>;
    /**
     * ExtraNames contains attributes to be copied, raw, into any marshaled distinguished names. Values override any attributes with the same OID. The ExtraNames field is not populated when parsing, see Names.
     * @type {Array<AttributeTypeAndValue>}
     * @memberof Name
     */
    'ExtraNames'?: Array<AttributeTypeAndValue>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    'Locality'?: Array<string>;
    /**
     * Names contains all parsed attributes. When parsing distinguished names, this can be used to extract non-standard attributes that are not parsed by this package. When marshaling to RDNSequences, the Names field is ignored, see ExtraNames.
     * @type {Array<AttributeTypeAndValue>}
     * @memberof Name
     */
    'Names'?: Array<AttributeTypeAndValue>;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'SerialNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Name
     */
    'StreetAddress'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NavbarPreference
 */
export interface NavbarPreference {
    /**
     * 
     * @type {Array<string>}
     * @memberof NavbarPreference
     */
    'bookmarkUrls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NewApiKeyResult
 */
export interface NewApiKeyResult {
    /**
     * 
     * @type {number}
     * @memberof NewApiKeyResult
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof NewApiKeyResult
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof NewApiKeyResult
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Notice
 */
export interface Notice {
    /**
     * 
     * @type {number}
     * @memberof Notice
     */
    'inspect'?: number;
    /**
     * Link is an optional link for display in the user interface and can be an absolute URL or a path relative to Grafana\'s root url.
     * @type {string}
     * @memberof Notice
     */
    'link'?: string;
    /**
     * 
     * @type {number}
     * @memberof Notice
     */
    'severity'?: number;
    /**
     * Text is freeform descriptive text for the notice.
     * @type {string}
     * @memberof Notice
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface NotificationPolicyExport
 */
export interface NotificationPolicyExport {
    /**
     * 
     * @type {boolean}
     * @memberof NotificationPolicyExport
     */
    'continue'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationPolicyExport
     */
    'group_by'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NotificationPolicyExport
     */
    'group_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPolicyExport
     */
    'group_wait'?: string;
    /**
     * Deprecated. Remove before v1.0 release.
     * @type {{ [key: string]: string; }}
     * @memberof NotificationPolicyExport
     */
    'match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NotificationPolicyExport
     */
    'match_re'?: { [key: string]: string; };
    /**
     * Matchers is a slice of Matchers that is sortable, implements Stringer, and provides a Matches method to match a LabelSet against all Matchers in the slice. Note that some users of Matchers might require it to be sorted.
     * @type {Array<Matcher>}
     * @memberof NotificationPolicyExport
     */
    'matchers'?: Array<Matcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NotificationPolicyExport
     */
    'mute_time_intervals'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof NotificationPolicyExport
     */
    'object_matchers'?: Array<Array<string>>;
    /**
     * 
     * @type {number}
     * @memberof NotificationPolicyExport
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof NotificationPolicyExport
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationPolicyExport
     */
    'repeat_interval'?: string;
    /**
     * 
     * @type {Array<RouteExport>}
     * @memberof NotificationPolicyExport
     */
    'routes'?: Array<RouteExport>;
}
/**
 * 
 * @export
 * @interface NotificationTemplate
 */
export interface NotificationTemplate {
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'provenance'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplate
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface NotificationTemplateContent
 */
export interface NotificationTemplateContent {
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateContent
     */
    'template'?: string;
    /**
     * 
     * @type {string}
     * @memberof NotificationTemplateContent
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface NotifierConfig
 */
export interface NotifierConfig {
    /**
     * 
     * @type {boolean}
     * @memberof NotifierConfig
     */
    'send_resolved'?: boolean;
}
/**
 * 
 * @export
 * @interface OAuth2
 */
export interface OAuth2 {
    /**
     * 
     * @type {TLSConfig}
     * @memberof OAuth2
     */
    'TLSConfig'?: TLSConfig;
    /**
     * 
     * @type {string}
     * @memberof OAuth2
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2
     */
    'client_secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2
     */
    'client_secret_file'?: string;
    /**
     * ClientSecretRef is the name of the secret within the secret manager to use as the client secret.
     * @type {string}
     * @memberof OAuth2
     */
    'client_secret_ref'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OAuth2
     */
    'endpoint_params'?: { [key: string]: string; };
    /**
     * NoProxy contains addresses that should not use a proxy.
     * @type {string}
     * @memberof OAuth2
     */
    'no_proxy'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof OAuth2
     */
    'proxy_connect_header'?: { [key: string]: Array<string>; };
    /**
     * ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.
     * @type {boolean}
     * @memberof OAuth2
     */
    'proxy_from_environment'?: boolean;
    /**
     * 
     * @type {URL}
     * @memberof OAuth2
     */
    'proxy_url'?: URL;
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuth2
     */
    'scopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuth2
     */
    'token_url'?: string;
}
/**
 * 
 * @export
 * @interface OpsGenieConfig
 */
export interface OpsGenieConfig {
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'actions'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'api_key_file'?: string;
    /**
     * 
     * @type {URL}
     * @memberof OpsGenieConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof OpsGenieConfig
     */
    'details'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'entity'?: string;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof OpsGenieConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'note'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'priority'?: string;
    /**
     * 
     * @type {Array<OpsGenieConfigResponder>}
     * @memberof OpsGenieConfig
     */
    'responders'?: Array<OpsGenieConfigResponder>;
    /**
     * 
     * @type {boolean}
     * @memberof OpsGenieConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfig
     */
    'tags'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpsGenieConfig
     */
    'update_alerts'?: boolean;
}
/**
 * 
 * @export
 * @interface OpsGenieConfigResponder
 */
export interface OpsGenieConfigResponder {
    /**
     * One of those 3 should be filled.
     * @type {string}
     * @memberof OpsGenieConfigResponder
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfigResponder
     */
    'name'?: string;
    /**
     * team, user, escalation, schedule etc.
     * @type {string}
     * @memberof OpsGenieConfigResponder
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpsGenieConfigResponder
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface OrgDTO
 */
export interface OrgDTO {
    /**
     * 
     * @type {number}
     * @memberof OrgDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgDTO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface OrgDetailsDTO
 */
export interface OrgDetailsDTO {
    /**
     * 
     * @type {Address}
     * @memberof OrgDetailsDTO
     */
    'address'?: Address;
    /**
     * 
     * @type {number}
     * @memberof OrgDetailsDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgDetailsDTO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface OrgUserDTO
 */
export interface OrgUserDTO {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof OrgUserDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<string>}
     * @memberof OrgUserDTO
     */
    'authLabels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrgUserDTO
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrgUserDTO
     */
    'isExternallySynced'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'lastSeenAtAge'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgUserDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrgUserDTO
     */
    'role'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrgUserDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface PagerdutyConfig
 */
export interface PagerdutyConfig {
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'class'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'client'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'client_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'component'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PagerdutyConfig
     */
    'details'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'group'?: string;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof PagerdutyConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {Array<PagerdutyImage>}
     * @memberof PagerdutyConfig
     */
    'images'?: Array<PagerdutyImage>;
    /**
     * 
     * @type {Array<PagerdutyLink>}
     * @memberof PagerdutyConfig
     */
    'links'?: Array<PagerdutyLink>;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'routing_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'routing_key_file'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PagerdutyConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'service_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'service_key_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'severity'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyConfig
     */
    'source'?: string;
    /**
     * 
     * @type {URL}
     * @memberof PagerdutyConfig
     */
    'url'?: URL;
}
/**
 * 
 * @export
 * @interface PagerdutyImage
 */
export interface PagerdutyImage {
    /**
     * 
     * @type {string}
     * @memberof PagerdutyImage
     */
    'alt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyImage
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyImage
     */
    'src'?: string;
}
/**
 * 
 * @export
 * @interface PagerdutyLink
 */
export interface PagerdutyLink {
    /**
     * 
     * @type {string}
     * @memberof PagerdutyLink
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof PagerdutyLink
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface PatchAnnotationsCmd
 */
export interface PatchAnnotationsCmd {
    /**
     * 
     * @type {object}
     * @memberof PatchAnnotationsCmd
     */
    'data'?: object;
    /**
     * 
     * @type {number}
     * @memberof PatchAnnotationsCmd
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchAnnotationsCmd
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PatchAnnotationsCmd
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchAnnotationsCmd
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchAnnotationsCmd
     */
    'timeEnd'?: number;
}
/**
 * PatchLibraryElementCommand is the command for patching a LibraryElement
 * @export
 * @interface PatchLibraryElementCommand
 */
export interface PatchLibraryElementCommand {
    /**
     * ID of the folder where the library element is stored.  Deprecated: use FolderUID instead
     * @type {number}
     * @memberof PatchLibraryElementCommand
     */
    'folderId'?: number;
    /**
     * UID of the folder where the library element is stored.
     * @type {string}
     * @memberof PatchLibraryElementCommand
     */
    'folderUid'?: string;
    /**
     * Kind of element to create, Use 1 for library panels or 2 for c. Description: 1 - library panels 2 - library variables
     * @type {number}
     * @memberof PatchLibraryElementCommand
     */
    'kind'?: PatchLibraryElementCommandKindEnum;
    /**
     * The JSON model for the library element.
     * @type {object}
     * @memberof PatchLibraryElementCommand
     */
    'model'?: object;
    /**
     * Name of the library element.
     * @type {string}
     * @memberof PatchLibraryElementCommand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchLibraryElementCommand
     */
    'uid'?: string;
    /**
     * Version of the library element you are updating.
     * @type {number}
     * @memberof PatchLibraryElementCommand
     */
    'version'?: number;
}

export const PatchLibraryElementCommandKindEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type PatchLibraryElementCommandKindEnum = typeof PatchLibraryElementCommandKindEnum[keyof typeof PatchLibraryElementCommandKindEnum];

/**
 * 
 * @export
 * @interface PatchPrefsCmd
 */
export interface PatchPrefsCmd {
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchPrefsCmd
     */
    'cookies'?: Array<string>;
    /**
     * The numerical :id of a favorited dashboard
     * @type {number}
     * @memberof PatchPrefsCmd
     */
    'homeDashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchPrefsCmd
     */
    'homeDashboardUID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchPrefsCmd
     */
    'language'?: string;
    /**
     * 
     * @type {NavbarPreference}
     * @memberof PatchPrefsCmd
     */
    'navbar'?: NavbarPreference;
    /**
     * 
     * @type {QueryHistoryPreference}
     * @memberof PatchPrefsCmd
     */
    'queryHistory'?: QueryHistoryPreference;
    /**
     * 
     * @type {string}
     * @memberof PatchPrefsCmd
     */
    'theme'?: PatchPrefsCmdThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchPrefsCmd
     */
    'timezone'?: PatchPrefsCmdTimezoneEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchPrefsCmd
     */
    'weekStart'?: string;
}

export const PatchPrefsCmdThemeEnum = {
    Light: 'light',
    Dark: 'dark'
} as const;

export type PatchPrefsCmdThemeEnum = typeof PatchPrefsCmdThemeEnum[keyof typeof PatchPrefsCmdThemeEnum];
export const PatchPrefsCmdTimezoneEnum = {
    Utc: 'utc',
    Browser: 'browser'
} as const;

export type PatchPrefsCmdTimezoneEnum = typeof PatchPrefsCmdTimezoneEnum[keyof typeof PatchPrefsCmdTimezoneEnum];

/**
 * PatchQueryCommentInQueryHistoryCommand is the command for updating comment for query in query history
 * @export
 * @interface PatchQueryCommentInQueryHistoryCommand
 */
export interface PatchQueryCommentInQueryHistoryCommand {
    /**
     * Updated comment
     * @type {string}
     * @memberof PatchQueryCommentInQueryHistoryCommand
     */
    'comment'?: string;
}
/**
 * PeerStatus peer status
 * @export
 * @interface PeerStatus
 */
export interface PeerStatus {
    /**
     * address
     * @type {string}
     * @memberof PeerStatus
     */
    'address': string;
    /**
     * name
     * @type {string}
     * @memberof PeerStatus
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Permission
 */
export interface Permission {
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof Permission
     */
    'updated'?: string;
}
/**
 * Playlist model
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {number}
     * @memberof Playlist
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistDTO
 */
export interface PlaylistDTO {
    /**
     * Interval sets the time between switching views in a playlist.
     * @type {string}
     * @memberof PlaylistDTO
     */
    'interval'?: string;
    /**
     * The ordered list of items that the playlist will iterate over.
     * @type {Array<PlaylistItemDTO>}
     * @memberof PlaylistDTO
     */
    'items'?: Array<PlaylistItemDTO>;
    /**
     * Name of the playlist.
     * @type {string}
     * @memberof PlaylistDTO
     */
    'name'?: string;
    /**
     * Unique playlist identifier. Generated on creation, either by the creator of the playlist of by the application.
     * @type {string}
     * @memberof PlaylistDTO
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistDashboard
 */
export interface PlaylistDashboard {
    /**
     * 
     * @type {number}
     * @memberof PlaylistDashboard
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistDashboard
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDashboard
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDashboard
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDashboard
     */
    'uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistDashboard
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'Id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'PlaylistId'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistItem
     */
    'order'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaylistItem
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PlaylistItemDTO
 */
export interface PlaylistItemDTO {
    /**
     * Title is an unused property -- it will be removed in the future
     * @type {string}
     * @memberof PlaylistItemDTO
     */
    'title'?: string;
    /**
     * Type of the item.
     * @type {string}
     * @memberof PlaylistItemDTO
     */
    'type'?: string;
    /**
     * Value depends on type and describes the playlist item.  dashboard_by_id: The value is an internal numerical identifier set by Grafana. This is not portable as the numerical identifier is non-deterministic between different instances. Will be replaced by dashboard_by_uid in the future. (deprecated) dashboard_by_tag: The value is a tag which is set on any number of dashboards. All dashboards behind the tag will be added to the playlist. dashboard_by_uid: The value is the dashboard UID
     * @type {string}
     * @memberof PlaylistItemDTO
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PostAnnotation200Response
 */
export interface PostAnnotation200Response {
    /**
     * ID Identifier of the created annotation.
     * @type {number}
     * @memberof PostAnnotation200Response
     */
    'id': number;
    /**
     * Message Message of the created annotation.
     * @type {string}
     * @memberof PostAnnotation200Response
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface PostAnnotationsCmd
 */
export interface PostAnnotationsCmd {
    /**
     * 
     * @type {number}
     * @memberof PostAnnotationsCmd
     */
    'dashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostAnnotationsCmd
     */
    'dashboardUID'?: string;
    /**
     * 
     * @type {object}
     * @memberof PostAnnotationsCmd
     */
    'data'?: object;
    /**
     * 
     * @type {number}
     * @memberof PostAnnotationsCmd
     */
    'panelId'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostAnnotationsCmd
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PostAnnotationsCmd
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof PostAnnotationsCmd
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PostAnnotationsCmd
     */
    'timeEnd'?: number;
}
/**
 * 
 * @export
 * @interface PostDashboard200Response
 */
export interface PostDashboard200Response {
    /**
     * FolderUID The unique identifier (uid) of the folder the dashboard belongs to.
     * @type {string}
     * @memberof PostDashboard200Response
     */
    'folderUid'?: string;
    /**
     * ID The unique identifier (id) of the created/updated dashboard.
     * @type {number}
     * @memberof PostDashboard200Response
     */
    'id': number;
    /**
     * Status status of the response.
     * @type {string}
     * @memberof PostDashboard200Response
     */
    'status': string;
    /**
     * Slug The slug of the dashboard.
     * @type {string}
     * @memberof PostDashboard200Response
     */
    'title': string;
    /**
     * UID The unique identifier (uid) of the created/updated dashboard.
     * @type {string}
     * @memberof PostDashboard200Response
     */
    'uid': string;
    /**
     * URL The relative URL for accessing the created/updated dashboard.
     * @type {string}
     * @memberof PostDashboard200Response
     */
    'url': string;
    /**
     * Version The version of the dashboard.
     * @type {number}
     * @memberof PostDashboard200Response
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface PostGraphiteAnnotationsCmd
 */
export interface PostGraphiteAnnotationsCmd {
    /**
     * 
     * @type {string}
     * @memberof PostGraphiteAnnotationsCmd
     */
    'data'?: string;
    /**
     * 
     * @type {any}
     * @memberof PostGraphiteAnnotationsCmd
     */
    'tags'?: any;
    /**
     * 
     * @type {string}
     * @memberof PostGraphiteAnnotationsCmd
     */
    'what'?: string;
    /**
     * 
     * @type {number}
     * @memberof PostGraphiteAnnotationsCmd
     */
    'when'?: number;
}
/**
 * 
 * @export
 * @interface PostSilencesOKBody
 */
export interface PostSilencesOKBody {
    /**
     * silence ID
     * @type {string}
     * @memberof PostSilencesOKBody
     */
    'silenceID'?: string;
}
/**
 * PostableAlert postable alert
 * @export
 * @interface PostableAlert
 */
export interface PostableAlert {
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof PostableAlert
     */
    'annotations'?: { [key: string]: string; };
    /**
     * ends at Format: date-time
     * @type {string}
     * @memberof PostableAlert
     */
    'endsAt'?: string;
    /**
     * generator URL Format: uri
     * @type {string}
     * @memberof PostableAlert
     */
    'generatorURL'?: string;
    /**
     * LabelSet label set
     * @type {{ [key: string]: string; }}
     * @memberof PostableAlert
     */
    'labels': { [key: string]: string; };
    /**
     * starts at Format: date-time
     * @type {string}
     * @memberof PostableAlert
     */
    'startsAt'?: string;
}
/**
 * nolint:revive
 * @export
 * @interface PostableApiAlertingConfig
 */
export interface PostableApiAlertingConfig {
    /**
     * 
     * @type {GlobalConfig}
     * @memberof PostableApiAlertingConfig
     */
    'global'?: GlobalConfig;
    /**
     * 
     * @type {Array<InhibitRule>}
     * @memberof PostableApiAlertingConfig
     */
    'inhibit_rules'?: Array<InhibitRule>;
    /**
     * MuteTimeIntervals is deprecated and will be removed before Alertmanager 1.0.
     * @type {Array<MuteTimeInterval>}
     * @memberof PostableApiAlertingConfig
     */
    'mute_time_intervals'?: Array<MuteTimeInterval>;
    /**
     * Override with our superset receiver type
     * @type {Array<PostableApiReceiver>}
     * @memberof PostableApiAlertingConfig
     */
    'receivers'?: Array<PostableApiReceiver>;
    /**
     * 
     * @type {Route}
     * @memberof PostableApiAlertingConfig
     */
    'route'?: Route;
    /**
     * 
     * @type {Array<string>}
     * @memberof PostableApiAlertingConfig
     */
    'templates'?: Array<string>;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof PostableApiAlertingConfig
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * nolint:revive
 * @export
 * @interface PostableApiReceiver
 */
export interface PostableApiReceiver {
    /**
     * 
     * @type {Array<DiscordConfig>}
     * @memberof PostableApiReceiver
     */
    'discord_configs'?: Array<DiscordConfig>;
    /**
     * 
     * @type {Array<EmailConfig>}
     * @memberof PostableApiReceiver
     */
    'email_configs'?: Array<EmailConfig>;
    /**
     * 
     * @type {Array<PostableGrafanaReceiver>}
     * @memberof PostableApiReceiver
     */
    'grafana_managed_receiver_configs'?: Array<PostableGrafanaReceiver>;
    /**
     * 
     * @type {Array<MSTeamsConfig>}
     * @memberof PostableApiReceiver
     */
    'msteams_configs'?: Array<MSTeamsConfig>;
    /**
     * A unique identifier for this receiver.
     * @type {string}
     * @memberof PostableApiReceiver
     */
    'name'?: string;
    /**
     * 
     * @type {Array<OpsGenieConfig>}
     * @memberof PostableApiReceiver
     */
    'opsgenie_configs'?: Array<OpsGenieConfig>;
    /**
     * 
     * @type {Array<PagerdutyConfig>}
     * @memberof PostableApiReceiver
     */
    'pagerduty_configs'?: Array<PagerdutyConfig>;
    /**
     * 
     * @type {Array<PushoverConfig>}
     * @memberof PostableApiReceiver
     */
    'pushover_configs'?: Array<PushoverConfig>;
    /**
     * 
     * @type {Array<SlackConfig>}
     * @memberof PostableApiReceiver
     */
    'slack_configs'?: Array<SlackConfig>;
    /**
     * 
     * @type {Array<SNSConfig>}
     * @memberof PostableApiReceiver
     */
    'sns_configs'?: Array<SNSConfig>;
    /**
     * 
     * @type {Array<TelegramConfig>}
     * @memberof PostableApiReceiver
     */
    'telegram_configs'?: Array<TelegramConfig>;
    /**
     * 
     * @type {Array<VictorOpsConfig>}
     * @memberof PostableApiReceiver
     */
    'victorops_configs'?: Array<VictorOpsConfig>;
    /**
     * 
     * @type {Array<WebexConfig>}
     * @memberof PostableApiReceiver
     */
    'webex_configs'?: Array<WebexConfig>;
    /**
     * 
     * @type {Array<WebhookConfig>}
     * @memberof PostableApiReceiver
     */
    'webhook_configs'?: Array<WebhookConfig>;
    /**
     * 
     * @type {Array<WechatConfig>}
     * @memberof PostableApiReceiver
     */
    'wechat_configs'?: Array<WechatConfig>;
}
/**
 * 
 * @export
 * @interface PostableExtendedRuleNode
 */
export interface PostableExtendedRuleNode {
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNode
     */
    'alert'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PostableExtendedRuleNode
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNode
     */
    'expr'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNode
     */
    'for'?: string;
    /**
     * 
     * @type {PostableGrafanaRule}
     * @memberof PostableExtendedRuleNode
     */
    'grafana_alert'?: PostableGrafanaRule;
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNode
     */
    'keep_firing_for'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PostableExtendedRuleNode
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNode
     */
    'record'?: string;
}
/**
 * 
 * @export
 * @interface PostableExtendedRuleNodeExtended
 */
export interface PostableExtendedRuleNodeExtended {
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNodeExtended
     */
    'folderTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNodeExtended
     */
    'folderUid'?: string;
    /**
     * 
     * @type {PostableExtendedRuleNode}
     * @memberof PostableExtendedRuleNodeExtended
     */
    'rule': PostableExtendedRuleNode;
    /**
     * 
     * @type {string}
     * @memberof PostableExtendedRuleNodeExtended
     */
    'ruleGroup'?: string;
}
/**
 * 
 * @export
 * @interface PostableGrafanaReceiver
 */
export interface PostableGrafanaReceiver {
    /**
     * 
     * @type {boolean}
     * @memberof PostableGrafanaReceiver
     */
    'disableResolveMessage'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaReceiver
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PostableGrafanaReceiver
     */
    'secureSettings'?: { [key: string]: string; };
    /**
     * 
     * @type {object}
     * @memberof PostableGrafanaReceiver
     */
    'settings'?: object;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaReceiver
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaReceiver
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface PostableGrafanaReceivers
 */
export interface PostableGrafanaReceivers {
    /**
     * 
     * @type {Array<PostableGrafanaReceiver>}
     * @memberof PostableGrafanaReceivers
     */
    'grafana_managed_receiver_configs'?: Array<PostableGrafanaReceiver>;
}
/**
 * 
 * @export
 * @interface PostableGrafanaRule
 */
export interface PostableGrafanaRule {
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaRule
     */
    'condition'?: string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof PostableGrafanaRule
     */
    'data'?: Array<AlertQuery>;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaRule
     */
    'exec_err_state'?: PostableGrafanaRuleExecErrStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PostableGrafanaRule
     */
    'is_paused'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaRule
     */
    'no_data_state'?: PostableGrafanaRuleNoDataStateEnum;
    /**
     * 
     * @type {AlertRuleNotificationSettings}
     * @memberof PostableGrafanaRule
     */
    'notification_settings'?: AlertRuleNotificationSettings;
    /**
     * 
     * @type {Record}
     * @memberof PostableGrafanaRule
     */
    'record'?: Record;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaRule
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostableGrafanaRule
     */
    'uid'?: string;
}

export const PostableGrafanaRuleExecErrStateEnum = {
    Ok: 'OK',
    Alerting: 'Alerting',
    Error: 'Error'
} as const;

export type PostableGrafanaRuleExecErrStateEnum = typeof PostableGrafanaRuleExecErrStateEnum[keyof typeof PostableGrafanaRuleExecErrStateEnum];
export const PostableGrafanaRuleNoDataStateEnum = {
    Alerting: 'Alerting',
    NoData: 'NoData',
    Ok: 'OK'
} as const;

export type PostableGrafanaRuleNoDataStateEnum = typeof PostableGrafanaRuleNoDataStateEnum[keyof typeof PostableGrafanaRuleNoDataStateEnum];

/**
 * 
 * @export
 * @interface PostableNGalertConfig
 */
export interface PostableNGalertConfig {
    /**
     * 
     * @type {string}
     * @memberof PostableNGalertConfig
     */
    'alertmanagersChoice'?: PostableNGalertConfigAlertmanagersChoiceEnum;
}

export const PostableNGalertConfigAlertmanagersChoiceEnum = {
    All: 'all',
    Internal: 'internal',
    External: 'external'
} as const;

export type PostableNGalertConfigAlertmanagersChoiceEnum = typeof PostableNGalertConfigAlertmanagersChoiceEnum[keyof typeof PostableNGalertConfigAlertmanagersChoiceEnum];

/**
 * 
 * @export
 * @interface PostableRuleGroupConfig
 */
export interface PostableRuleGroupConfig {
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof PostableRuleGroupConfig
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof PostableRuleGroupConfig
     */
    'name'?: string;
    /**
     * 
     * @type {Array<PostableExtendedRuleNode>}
     * @memberof PostableRuleGroupConfig
     */
    'rules'?: Array<PostableExtendedRuleNode>;
}
/**
 * PostableSilence postable silence
 * @export
 * @interface PostableSilence
 */
export interface PostableSilence {
    /**
     * comment
     * @type {string}
     * @memberof PostableSilence
     */
    'comment': string;
    /**
     * created by
     * @type {string}
     * @memberof PostableSilence
     */
    'createdBy': string;
    /**
     * ends at
     * @type {string}
     * @memberof PostableSilence
     */
    'endsAt': string;
    /**
     * id
     * @type {string}
     * @memberof PostableSilence
     */
    'id'?: string;
    /**
     * Matchers matchers
     * @type {Array<Matcher>}
     * @memberof PostableSilence
     */
    'matchers': Array<Matcher>;
    /**
     * starts at
     * @type {string}
     * @memberof PostableSilence
     */
    'startsAt': string;
}
/**
 * 
 * @export
 * @interface PostableTimeIntervals
 */
export interface PostableTimeIntervals {
    /**
     * 
     * @type {string}
     * @memberof PostableTimeIntervals
     */
    'name'?: string;
    /**
     * 
     * @type {Array<TimeIntervalItem>}
     * @memberof PostableTimeIntervals
     */
    'time_intervals'?: Array<TimeIntervalItem>;
    /**
     * 
     * @type {string}
     * @memberof PostableTimeIntervals
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface PostableUserConfig
 */
export interface PostableUserConfig {
    /**
     * 
     * @type {PostableApiAlertingConfig}
     * @memberof PostableUserConfig
     */
    'alertmanager_config'?: PostableApiAlertingConfig;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PostableUserConfig
     */
    'template_files'?: { [key: string]: string; };
}
/**
 * Spec defines user, team or org Grafana preferences
 * @export
 * @interface Preferences
 */
export interface Preferences {
    /**
     * 
     * @type {CookiePreferences}
     * @memberof Preferences
     */
    'cookiePreferences'?: CookiePreferences;
    /**
     * UID for the home dashboard
     * @type {string}
     * @memberof Preferences
     */
    'homeDashboardUID'?: string;
    /**
     * Selected language (beta)
     * @type {string}
     * @memberof Preferences
     */
    'language'?: string;
    /**
     * 
     * @type {NavbarPreference}
     * @memberof Preferences
     */
    'navbar'?: NavbarPreference;
    /**
     * 
     * @type {QueryHistoryPreference}
     * @memberof Preferences
     */
    'queryHistory'?: QueryHistoryPreference;
    /**
     * Theme light, dark, empty is default
     * @type {string}
     * @memberof Preferences
     */
    'theme'?: string;
    /**
     * The timezone selection TODO: this should use the timezone defined in common
     * @type {string}
     * @memberof Preferences
     */
    'timezone'?: string;
    /**
     * WeekStart day of the week (sunday, monday, etc)
     * @type {string}
     * @memberof Preferences
     */
    'weekStart'?: string;
}
/**
 * 
 * @export
 * @interface PrometheusRemoteWriteTargetJSON
 */
export interface PrometheusRemoteWriteTargetJSON {
    /**
     * 
     * @type {string}
     * @memberof PrometheusRemoteWriteTargetJSON
     */
    'data_source_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrometheusRemoteWriteTargetJSON
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrometheusRemoteWriteTargetJSON
     */
    'remote_write_path'?: string;
}
/**
 * 
 * @export
 * @interface ProvisionedAlertRule
 */
export interface ProvisionedAlertRule {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionedAlertRule
     */
    'annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'condition': string;
    /**
     * 
     * @type {Array<AlertQuery>}
     * @memberof ProvisionedAlertRule
     */
    'data': Array<AlertQuery>;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'execErrState': ProvisionedAlertRuleExecErrStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'folderUID': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'for': string;
    /**
     * 
     * @type {number}
     * @memberof ProvisionedAlertRule
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProvisionedAlertRule
     */
    'isPaused'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProvisionedAlertRule
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'noDataState': ProvisionedAlertRuleNoDataStateEnum;
    /**
     * 
     * @type {AlertRuleNotificationSettings}
     * @memberof ProvisionedAlertRule
     */
    'notification_settings'?: AlertRuleNotificationSettings;
    /**
     * 
     * @type {number}
     * @memberof ProvisionedAlertRule
     */
    'orgID': number;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'provenance'?: string;
    /**
     * 
     * @type {Record}
     * @memberof ProvisionedAlertRule
     */
    'record'?: Record;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'ruleGroup': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProvisionedAlertRule
     */
    'updated'?: string;
}

export const ProvisionedAlertRuleExecErrStateEnum = {
    Ok: 'OK',
    Alerting: 'Alerting',
    Error: 'Error'
} as const;

export type ProvisionedAlertRuleExecErrStateEnum = typeof ProvisionedAlertRuleExecErrStateEnum[keyof typeof ProvisionedAlertRuleExecErrStateEnum];
export const ProvisionedAlertRuleNoDataStateEnum = {
    Alerting: 'Alerting',
    NoData: 'NoData',
    Ok: 'OK'
} as const;

export type ProvisionedAlertRuleNoDataStateEnum = typeof ProvisionedAlertRuleNoDataStateEnum[keyof typeof ProvisionedAlertRuleNoDataStateEnum];

/**
 * 
 * @export
 * @interface ProxyConfig
 */
export interface ProxyConfig {
    /**
     * NoProxy contains addresses that should not use a proxy.
     * @type {string}
     * @memberof ProxyConfig
     */
    'no_proxy'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ProxyConfig
     */
    'proxy_connect_header'?: { [key: string]: Array<string>; };
    /**
     * ProxyFromEnvironment makes use of net/http ProxyFromEnvironment function to determine proxies.
     * @type {boolean}
     * @memberof ProxyConfig
     */
    'proxy_from_environment'?: boolean;
    /**
     * 
     * @type {URL}
     * @memberof ProxyConfig
     */
    'proxy_url'?: URL;
}
/**
 * 
 * @export
 * @interface PublicDashboard
 */
export interface PublicDashboard {
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'accessToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboard
     */
    'annotationsEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicDashboard
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'dashboardUid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboard
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {Array<EmailDTO>}
     * @memberof PublicDashboard
     */
    'recipients'?: Array<EmailDTO>;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'share'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboard
     */
    'timeSelectionEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboard
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof PublicDashboard
     */
    'updatedBy'?: number;
}
/**
 * 
 * @export
 * @interface PublicDashboardDTO
 */
export interface PublicDashboardDTO {
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardDTO
     */
    'accessToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboardDTO
     */
    'annotationsEnabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboardDTO
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardDTO
     */
    'share'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboardDTO
     */
    'timeSelectionEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardDTO
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface PublicDashboardListResponse
 */
export interface PublicDashboardListResponse {
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardListResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardListResponse
     */
    'dashboardUid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PublicDashboardListResponse
     */
    'isEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardListResponse
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardListResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicDashboardListResponse
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface PublicDashboardListResponseWithPagination
 */
export interface PublicDashboardListResponseWithPagination {
    /**
     * 
     * @type {number}
     * @memberof PublicDashboardListResponseWithPagination
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PublicDashboardListResponseWithPagination
     */
    'perPage'?: number;
    /**
     * 
     * @type {Array<PublicDashboardListResponse>}
     * @memberof PublicDashboardListResponseWithPagination
     */
    'publicDashboards'?: Array<PublicDashboardListResponse>;
    /**
     * 
     * @type {number}
     * @memberof PublicDashboardListResponseWithPagination
     */
    'totalCount'?: number;
}
/**
 * PublicError is derived from Error and only contains information available to the end user.
 * @export
 * @interface PublicError
 */
export interface PublicError {
    /**
     * Extra Additional information about the error
     * @type {{ [key: string]: any; }}
     * @memberof PublicError
     */
    'extra'?: { [key: string]: any; };
    /**
     * Message A human readable message
     * @type {string}
     * @memberof PublicError
     */
    'message'?: string;
    /**
     * MessageID A unique identifier for the error
     * @type {string}
     * @memberof PublicError
     */
    'messageId': string;
    /**
     * StatusCode The HTTP status code returned
     * @type {number}
     * @memberof PublicError
     */
    'statusCode': number;
}
/**
 * 
 * @export
 * @interface PushoverConfig
 */
export interface PushoverConfig {
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'device'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'expire'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PushoverConfig
     */
    'html'?: boolean;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof PushoverConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'priority'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'retry'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PushoverConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'sound'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'token_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'ttl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'url_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'user_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PushoverConfig
     */
    'user_key_file'?: string;
}
/**
 * It is the return type of a QueryData call.
 * @export
 * @interface QueryDataResponse
 */
export interface QueryDataResponse {
    /**
     * The QueryData method the QueryDataHandler method will set the RefId property on the DataResponses\' frames based on these RefIDs.
     * @type {{ [key: string]: DataResponse; }}
     * @memberof QueryDataResponse
     */
    'results'?: { [key: string]: DataResponse; };
}
/**
 * 
 * @export
 * @interface QueryHistoryDTO
 */
export interface QueryHistoryDTO {
    /**
     * 
     * @type {string}
     * @memberof QueryHistoryDTO
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryHistoryDTO
     */
    'createdAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryHistoryDTO
     */
    'createdBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryHistoryDTO
     */
    'datasourceUid'?: string;
    /**
     * 
     * @type {object}
     * @memberof QueryHistoryDTO
     */
    'queries'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof QueryHistoryDTO
     */
    'starred'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QueryHistoryDTO
     */
    'uid'?: string;
}
/**
 * QueryHistoryDeleteQueryResponse is the response struct for deleting a query from query history
 * @export
 * @interface QueryHistoryDeleteQueryResponse
 */
export interface QueryHistoryDeleteQueryResponse {
    /**
     * 
     * @type {number}
     * @memberof QueryHistoryDeleteQueryResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QueryHistoryDeleteQueryResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface QueryHistoryPreference
 */
export interface QueryHistoryPreference {
    /**
     * HomeTab one of: \'\' | \'query\' | \'starred\';
     * @type {string}
     * @memberof QueryHistoryPreference
     */
    'homeTab'?: string;
}
/**
 * QueryHistoryResponse is a response struct for QueryHistoryDTO
 * @export
 * @interface QueryHistoryResponse
 */
export interface QueryHistoryResponse {
    /**
     * 
     * @type {QueryHistoryDTO}
     * @memberof QueryHistoryResponse
     */
    'result'?: QueryHistoryDTO;
}
/**
 * 
 * @export
 * @interface QueryHistorySearchResponse
 */
export interface QueryHistorySearchResponse {
    /**
     * 
     * @type {QueryHistorySearchResult}
     * @memberof QueryHistorySearchResponse
     */
    'result'?: QueryHistorySearchResult;
}
/**
 * 
 * @export
 * @interface QueryHistorySearchResult
 */
export interface QueryHistorySearchResult {
    /**
     * 
     * @type {number}
     * @memberof QueryHistorySearchResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof QueryHistorySearchResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {Array<QueryHistoryDTO>}
     * @memberof QueryHistorySearchResult
     */
    'queryHistory'?: Array<QueryHistoryDTO>;
    /**
     * 
     * @type {number}
     * @memberof QueryHistorySearchResult
     */
    'totalCount'?: number;
}
/**
 * The embedded FieldConfig\'s display name must be set. It corresponds to the QueryResultMetaStat on the frontend (https://github.com/grafana/grafana/blob/master/packages/grafana-data/src/types/data.ts#L53).
 * @export
 * @interface QueryStat
 */
export interface QueryStat {
    /**
     * Map values to a display color NOTE: this interface is under development in the frontend... so simple map for now
     * @type {{ [key: string]: any; }}
     * @memberof QueryStat
     */
    'color'?: { [key: string]: any; };
    /**
     * Panel Specific Values
     * @type {{ [key: string]: any; }}
     * @memberof QueryStat
     */
    'custom'?: { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof QueryStat
     */
    'decimals'?: number;
    /**
     * Description is human readable field metadata
     * @type {string}
     * @memberof QueryStat
     */
    'description'?: string;
    /**
     * DisplayName overrides Grafana default naming, should not be used from a data source
     * @type {string}
     * @memberof QueryStat
     */
    'displayName'?: string;
    /**
     * DisplayNameFromDS overrides Grafana default naming strategy.
     * @type {string}
     * @memberof QueryStat
     */
    'displayNameFromDS'?: string;
    /**
     * Filterable indicates if the Field\'s data can be filtered by additional calls.
     * @type {boolean}
     * @memberof QueryStat
     */
    'filterable'?: boolean;
    /**
     * Interval indicates the expected regular step between values in the series. When an interval exists, consumers can identify \"missing\" values when the expected value is not present. The grafana timeseries visualization will render disconnected values when missing values are found it the time field. The interval uses the same units as the values.  For time.Time, this is defined in milliseconds.
     * @type {number}
     * @memberof QueryStat
     */
    'interval'?: number;
    /**
     * The behavior when clicking on a result
     * @type {Array<DataLink>}
     * @memberof QueryStat
     */
    'links'?: Array<DataLink>;
    /**
     * 
     * @type {Array<object>}
     * @memberof QueryStat
     */
    'mappings'?: Array<object>;
    /**
     * ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf to null.
     * @type {number}
     * @memberof QueryStat
     */
    'max'?: number;
    /**
     * ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf to null.
     * @type {number}
     * @memberof QueryStat
     */
    'min'?: number;
    /**
     * Alternative to empty string
     * @type {string}
     * @memberof QueryStat
     */
    'noValue'?: string;
    /**
     * Path is an explicit path to the field in the datasource. When the frame meta includes a path, this will default to `${frame.meta.path}/${field.name}  When defined, this value can be used as an identifier within the datasource scope, and may be used as an identifier to update values in a subsequent request
     * @type {string}
     * @memberof QueryStat
     */
    'path'?: string;
    /**
     * 
     * @type {ThresholdsConfig}
     * @memberof QueryStat
     */
    'thresholds'?: ThresholdsConfig;
    /**
     * 
     * @type {FieldTypeConfig}
     * @memberof QueryStat
     */
    'type'?: FieldTypeConfig;
    /**
     * Numeric Options
     * @type {string}
     * @memberof QueryStat
     */
    'unit'?: string;
    /**
     * 
     * @type {number}
     * @memberof QueryStat
     */
    'value'?: number;
    /**
     * Writeable indicates that the datasource knows how to update this value
     * @type {boolean}
     * @memberof QueryStat
     */
    'writeable'?: boolean;
}
/**
 * 
 * @export
 * @interface QuotaDTO
 */
export interface QuotaDTO {
    /**
     * 
     * @type {number}
     * @memberof QuotaDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaDTO
     */
    'org_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuotaDTO
     */
    'target'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuotaDTO
     */
    'used'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaDTO
     */
    'user_id'?: number;
}
/**
 * Receiver receiver
 * @export
 * @interface Receiver
 */
export interface Receiver {
    /**
     * name
     * @type {string}
     * @memberof Receiver
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ReceiverExport
 */
export interface ReceiverExport {
    /**
     * 
     * @type {boolean}
     * @memberof ReceiverExport
     */
    'disableResolveMessage'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof ReceiverExport
     */
    'settings'?: object;
    /**
     * 
     * @type {string}
     * @memberof ReceiverExport
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReceiverExport
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * Which expression node should be used as the input for the recorded metric.
     * @type {string}
     * @memberof Record
     */
    'from': string;
    /**
     * Name of the recorded metric.
     * @type {string}
     * @memberof Record
     */
    'metric': string;
}
/**
 * RecordingRuleJSON is the external representation of a recording rule
 * @export
 * @interface RecordingRuleJSON
 */
export interface RecordingRuleJSON {
    /**
     * 
     * @type {boolean}
     * @memberof RecordingRuleJSON
     */
    'active'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecordingRuleJSON
     */
    'count'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'dest_data_source_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof RecordingRuleJSON
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'prom_name'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof RecordingRuleJSON
     */
    'queries'?: Array<{ [key: string]: any; }>;
    /**
     * 
     * @type {number}
     * @memberof RecordingRuleJSON
     */
    'range'?: number;
    /**
     * 
     * @type {string}
     * @memberof RecordingRuleJSON
     */
    'target_ref_id'?: string;
}
/**
 * RelativeTimeRange is the per query start and end time for requests.
 * @export
 * @interface RelativeTimeRange
 */
export interface RelativeTimeRange {
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof RelativeTimeRange
     */
    'from'?: number;
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof RelativeTimeRange
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface RelativeTimeRangeExport
 */
export interface RelativeTimeRangeExport {
    /**
     * 
     * @type {number}
     * @memberof RelativeTimeRangeExport
     */
    'from'?: number;
    /**
     * 
     * @type {number}
     * @memberof RelativeTimeRangeExport
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface Report
 */
export interface Report {
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'created'?: string;
    /**
     * 
     * @type {Array<ReportDashboard>}
     * @memberof Report
     */
    'dashboards'?: Array<ReportDashboard>;
    /**
     * 
     * @type {boolean}
     * @memberof Report
     */
    'enableCsv'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Report
     */
    'enableDashboardUrl'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Report
     */
    'formats'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'name'?: string;
    /**
     * 
     * @type {ReportOptions}
     * @memberof Report
     */
    'options'?: ReportOptions;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'recipients'?: string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'replyTo'?: string;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'scaleFactor'?: number;
    /**
     * 
     * @type {ReportSchedule}
     * @memberof Report
     */
    'schedule'?: ReportSchedule;
    /**
     * +enum
     * @type {string}
     * @memberof Report
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Report
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof Report
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface ReportBrandingOptions
 */
export interface ReportBrandingOptions {
    /**
     * 
     * @type {string}
     * @memberof ReportBrandingOptions
     */
    'emailFooterLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportBrandingOptions
     */
    'emailFooterMode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportBrandingOptions
     */
    'emailFooterText'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportBrandingOptions
     */
    'emailLogoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportBrandingOptions
     */
    'reportLogoUrl'?: string;
}
/**
 * 
 * @export
 * @interface ReportDashboard
 */
export interface ReportDashboard {
    /**
     * 
     * @type {ReportDashboardID}
     * @memberof ReportDashboard
     */
    'dashboard'?: ReportDashboardID;
    /**
     * 
     * @type {object}
     * @memberof ReportDashboard
     */
    'reportVariables'?: object;
    /**
     * 
     * @type {ReportTimeRange}
     * @memberof ReportDashboard
     */
    'timeRange'?: ReportTimeRange;
}
/**
 * 
 * @export
 * @interface ReportDashboardID
 */
export interface ReportDashboardID {
    /**
     * 
     * @type {number}
     * @memberof ReportDashboardID
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportDashboardID
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportDashboardID
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface ReportEmail
 */
export interface ReportEmail {
    /**
     * Comma-separated list of emails to which to send the report to.
     * @type {string}
     * @memberof ReportEmail
     */
    'emails'?: string;
    /**
     * Send the report to the emails specified in the report. Required if emails is not present.
     * @type {string}
     * @memberof ReportEmail
     */
    'id'?: string;
    /**
     * Send the report to the emails specified in the report. Required if emails is not present.
     * @type {boolean}
     * @memberof ReportEmail
     */
    'useEmailsFromReport'?: boolean;
}
/**
 * 
 * @export
 * @interface ReportOptions
 */
export interface ReportOptions {
    /**
     * 
     * @type {string}
     * @memberof ReportOptions
     */
    'layout'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportOptions
     */
    'orientation'?: string;
    /**
     * 
     * @type {ReportTimeRange}
     * @memberof ReportOptions
     */
    'timeRange'?: ReportTimeRange;
}
/**
 * 
 * @export
 * @interface ReportSchedule
 */
export interface ReportSchedule {
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'dayOfMonth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'frequency'?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportSchedule
     */
    'intervalAmount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'intervalFrequency'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportSchedule
     */
    'timeZone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReportSchedule
     */
    'workdaysOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface ReportSettings
 */
export interface ReportSettings {
    /**
     * 
     * @type {ReportBrandingOptions}
     * @memberof ReportSettings
     */
    'branding'?: ReportBrandingOptions;
    /**
     * 
     * @type {number}
     * @memberof ReportSettings
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReportSettings
     */
    'orgId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ReportSettings
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface ReportTimeRange
 */
export interface ReportTimeRange {
    /**
     * 
     * @type {string}
     * @memberof ReportTimeRange
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportTimeRange
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface ResourcePermissionDTO
 */
export interface ResourcePermissionDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResourcePermissionDTO
     */
    'actions'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'builtInRole'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePermissionDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcePermissionDTO
     */
    'isInherited'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcePermissionDTO
     */
    'isManaged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResourcePermissionDTO
     */
    'isServiceAccount'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'roleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'team'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'teamAvatarUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePermissionDTO
     */
    'teamId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'userAvatarUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ResourcePermissionDTO
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResourcePermissionDTO
     */
    'userLogin'?: string;
}
/**
 * 
 * @export
 * @interface ResponseDetails
 */
export interface ResponseDetails {
    /**
     * 
     * @type {string}
     * @memberof ResponseDetails
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface RestoreDashboardVersionCommand
 */
export interface RestoreDashboardVersionCommand {
    /**
     * 
     * @type {number}
     * @memberof RestoreDashboardVersionCommand
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface RestoreDeletedDashboardCommand
 */
export interface RestoreDeletedDashboardCommand {
    /**
     * 
     * @type {string}
     * @memberof RestoreDeletedDashboardCommand
     */
    'folderUid'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveJWKS200Response
 */
export interface RetrieveJWKS200Response {
    /**
     * 
     * @type {Array<JSONWebKey>}
     * @memberof RetrieveJWKS200Response
     */
    'keys'?: Array<JSONWebKey>;
}
/**
 * 
 * @export
 * @interface RevokeAuthTokenCmd
 */
export interface RevokeAuthTokenCmd {
    /**
     * 
     * @type {number}
     * @memberof RevokeAuthTokenCmd
     */
    'authTokenId'?: number;
}
/**
 * 
 * @export
 * @interface RoleAssignmentsDTO
 */
export interface RoleAssignmentsDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleAssignmentsDTO
     */
    'role_uid'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RoleAssignmentsDTO
     */
    'service_accounts'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RoleAssignmentsDTO
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RoleAssignmentsDTO
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface RoleDTO
 */
export interface RoleDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'created'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDTO
     */
    'delegatable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'displayName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDTO
     */
    'global'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'group'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RoleDTO
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof RoleDTO
     */
    'permissions'?: Array<Permission>;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleDTO
     */
    'updated'?: string;
    /**
     * 
     * @type {number}
     * @memberof RoleDTO
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface RolesSearchQuery
 */
export interface RolesSearchQuery {
    /**
     * 
     * @type {boolean}
     * @memberof RolesSearchQuery
     */
    'includeHidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RolesSearchQuery
     */
    'orgId'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof RolesSearchQuery
     */
    'teamIds'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RolesSearchQuery
     */
    'userIds'?: Array<number>;
}
/**
 * A Route is a node that contains definitions of how to handle alerts. This is modified from the upstream alertmanager in that it adds the ObjectMatchers property.
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * 
     * @type {Array<string>}
     * @memberof Route
     */
    'active_time_intervals'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Route
     */
    'continue'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Route
     */
    'group_by'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'group_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'group_wait'?: string;
    /**
     * Deprecated. Remove before v1.0 release.
     * @type {{ [key: string]: string; }}
     * @memberof Route
     */
    'match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Route
     */
    'match_re'?: { [key: string]: string; };
    /**
     * Matchers is a slice of Matchers that is sortable, implements Stringer, and provides a Matches method to match a LabelSet against all Matchers in the slice. Note that some users of Matchers might require it to be sorted.
     * @type {Array<Matcher>}
     * @memberof Route
     */
    'matchers'?: Array<Matcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Route
     */
    'mute_time_intervals'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof Route
     */
    'object_matchers'?: Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'provenance'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    'repeat_interval'?: string;
    /**
     * 
     * @type {Array<Route>}
     * @memberof Route
     */
    'routes'?: Array<Route>;
}
/**
 * RouteExport is the provisioned file export of definitions.Route. This is needed to hide fields that aren\'t useable in provisioning file format. An alternative would be to define a custom MarshalJSON and MarshalYAML that excludes them.
 * @export
 * @interface RouteExport
 */
export interface RouteExport {
    /**
     * 
     * @type {boolean}
     * @memberof RouteExport
     */
    'continue'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteExport
     */
    'group_by'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RouteExport
     */
    'group_interval'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteExport
     */
    'group_wait'?: string;
    /**
     * Deprecated. Remove before v1.0 release.
     * @type {{ [key: string]: string; }}
     * @memberof RouteExport
     */
    'match'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RouteExport
     */
    'match_re'?: { [key: string]: string; };
    /**
     * Matchers is a slice of Matchers that is sortable, implements Stringer, and provides a Matches method to match a LabelSet against all Matchers in the slice. Note that some users of Matchers might require it to be sorted.
     * @type {Array<Matcher>}
     * @memberof RouteExport
     */
    'matchers'?: Array<Matcher>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RouteExport
     */
    'mute_time_intervals'?: Array<string>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof RouteExport
     */
    'object_matchers'?: Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof RouteExport
     */
    'receiver'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteExport
     */
    'repeat_interval'?: string;
    /**
     * 
     * @type {Array<RouteExport>}
     * @memberof RouteExport
     */
    'routes'?: Array<RouteExport>;
}
/**
 * adapted from cortex
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    'evaluationTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'health': string;
    /**
     * Labels is a sorted set of labels. Order has to be guaranteed upon instantiation.
     * @type {Array<Label>}
     * @memberof Rule
     */
    'labels'?: Array<Label>;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'lastError'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'lastEvaluation'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'query': string;
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface RuleDiscovery
 */
export interface RuleDiscovery {
    /**
     * 
     * @type {Array<RuleGroup>}
     * @memberof RuleDiscovery
     */
    'groups': Array<RuleGroup>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RuleDiscovery
     */
    'totals'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     * 
     * @type {number}
     * @memberof RuleGroup
     */
    'evaluationTime'?: number;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'file': string;
    /**
     * 
     * @type {number}
     * @memberof RuleGroup
     */
    'interval': number;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'lastEvaluation'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleGroup
     */
    'name': string;
    /**
     * In order to preserve rule ordering, while exposing type (alerting or recording) specific properties, both alerting and recording rules are exposed in the same array.
     * @type {Array<AlertingRule>}
     * @memberof RuleGroup
     */
    'rules': Array<AlertingRule>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof RuleGroup
     */
    'totals'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface RuleGroupConfigResponse
 */
export interface RuleGroupConfigResponse {
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof RuleGroupConfigResponse
     */
    'interval'?: number;
    /**
     * 
     * @type {string}
     * @memberof RuleGroupConfigResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<GettableExtendedRuleNode>}
     * @memberof RuleGroupConfigResponse
     */
    'rules'?: Array<GettableExtendedRuleNode>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RuleGroupConfigResponse
     */
    'source_tenants'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RuleResponse
 */
export interface RuleResponse {
    /**
     * 
     * @type {RuleDiscovery}
     * @memberof RuleResponse
     */
    'data'?: RuleDiscovery;
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'errorType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SNSConfig
 */
export interface SNSConfig {
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'api_url'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SNSConfig
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof SNSConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'phone_number'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SNSConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {SigV4Config}
     * @memberof SNSConfig
     */
    'sigv4'?: SigV4Config;
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'target_arn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SNSConfig
     */
    'topic_arn'?: string;
}
/**
 * Sample is a single sample belonging to a metric. It represents either a float sample or a histogram sample. If H is nil, it is a float sample. Otherwise, it is a histogram sample.
 * @export
 * @interface Sample
 */
export interface Sample {
    /**
     * 
     * @type {number}
     * @memberof Sample
     */
    'F'?: number;
    /**
     * 
     * @type {FloatHistogram}
     * @memberof Sample
     */
    'H'?: FloatHistogram;
    /**
     * Labels is a sorted set of labels. Order has to be guaranteed upon instantiation.
     * @type {Array<Label>}
     * @memberof Sample
     */
    'Metric'?: Array<Label>;
    /**
     * 
     * @type {number}
     * @memberof Sample
     */
    'T'?: number;
}
/**
 * 
 * @export
 * @interface SaveDashboardCommand
 */
export interface SaveDashboardCommand {
    /**
     * 
     * @type {string}
     * @memberof SaveDashboardCommand
     */
    'UpdatedAt'?: string;
    /**
     * 
     * @type {object}
     * @memberof SaveDashboardCommand
     */
    'dashboard'?: object;
    /**
     * Deprecated: use FolderUID instead
     * @type {number}
     * @memberof SaveDashboardCommand
     */
    'folderId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SaveDashboardCommand
     */
    'folderUid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveDashboardCommand
     */
    'isFolder'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SaveDashboardCommand
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveDashboardCommand
     */
    'overwrite'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SaveDashboardCommand
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface SearchDTO
 */
export interface SearchDTO {
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'basicRole'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchDTO
     */
    'onlyRoles'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'roleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'teamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchDTO
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface SearchDeviceQueryResult
 */
export interface SearchDeviceQueryResult {
    /**
     * 
     * @type {Array<DeviceSearchHitDTO>}
     * @memberof SearchDeviceQueryResult
     */
    'devices'?: Array<DeviceSearchHitDTO>;
    /**
     * 
     * @type {number}
     * @memberof SearchDeviceQueryResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchDeviceQueryResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchDeviceQueryResult
     */
    'totalCount'?: number;
}
/**
 * swagger: model
 * @export
 * @interface SearchOrgServiceAccountsResult
 */
export interface SearchOrgServiceAccountsResult {
    /**
     * 
     * @type {number}
     * @memberof SearchOrgServiceAccountsResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchOrgServiceAccountsResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {Array<ServiceAccountDTO>}
     * @memberof SearchOrgServiceAccountsResult
     */
    'serviceAccounts'?: Array<ServiceAccountDTO>;
    /**
     * It can be used for pagination of the user list E.g. if totalCount is equal to 100 users and the perpage parameter is set to 10 then there are 10 pages of users.
     * @type {number}
     * @memberof SearchOrgServiceAccountsResult
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface SearchOrgUsersQueryResult
 */
export interface SearchOrgUsersQueryResult {
    /**
     * 
     * @type {Array<OrgUserDTO>}
     * @memberof SearchOrgUsersQueryResult
     */
    'orgUsers'?: Array<OrgUserDTO>;
    /**
     * 
     * @type {number}
     * @memberof SearchOrgUsersQueryResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchOrgUsersQueryResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchOrgUsersQueryResult
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     * 
     * @type {Array<SearchResultItem>}
     * @memberof SearchResult
     */
    'result'?: Array<SearchResultItem>;
}
/**
 * 
 * @export
 * @interface SearchResultItem
 */
export interface SearchResultItem {
    /**
     * 
     * @type {string}
     * @memberof SearchResultItem
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultItem
     */
    'basicRole'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchResultItem
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SearchResultItem
     */
    'roleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchResultItem
     */
    'scope'?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchResultItem
     */
    'teamId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchResultItem
     */
    'userId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchResultItem
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface SearchTeamQueryResult
 */
export interface SearchTeamQueryResult {
    /**
     * 
     * @type {number}
     * @memberof SearchTeamQueryResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchTeamQueryResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {Array<TeamDTO>}
     * @memberof SearchTeamQueryResult
     */
    'teams'?: Array<TeamDTO>;
    /**
     * 
     * @type {number}
     * @memberof SearchTeamQueryResult
     */
    'totalCount'?: number;
}
/**
 * 
 * @export
 * @interface SearchUserQueryResult
 */
export interface SearchUserQueryResult {
    /**
     * 
     * @type {number}
     * @memberof SearchUserQueryResult
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchUserQueryResult
     */
    'perPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchUserQueryResult
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<UserSearchHitDTO>}
     * @memberof SearchUserQueryResult
     */
    'users'?: Array<UserSearchHitDTO>;
}
/**
 * swagger: model
 * @export
 * @interface ServiceAccountDTO
 */
export interface ServiceAccountDTO {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof ServiceAccountDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAccountDTO
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAccountDTO
     */
    'isExternal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountDTO
     */
    'role'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountDTO
     */
    'tokens'?: number;
}
/**
 * 
 * @export
 * @interface ServiceAccountProfileDTO
 */
export interface ServiceAccountProfileDTO {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof ServiceAccountProfileDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountProfileDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAccountProfileDTO
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceAccountProfileDTO
     */
    'isExternal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountProfileDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'requiredBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'role'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceAccountProfileDTO
     */
    'teams'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ServiceAccountProfileDTO
     */
    'tokens'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServiceAccountProfileDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface SetPermissionCommand
 */
export interface SetPermissionCommand {
    /**
     * 
     * @type {string}
     * @memberof SetPermissionCommand
     */
    'permission'?: string;
}
/**
 * 
 * @export
 * @interface SetPermissionsCommand
 */
export interface SetPermissionsCommand {
    /**
     * 
     * @type {Array<SetResourcePermissionCommand>}
     * @memberof SetPermissionsCommand
     */
    'permissions'?: Array<SetResourcePermissionCommand>;
}
/**
 * 
 * @export
 * @interface SetResourcePermissionCommand
 */
export interface SetResourcePermissionCommand {
    /**
     * 
     * @type {string}
     * @memberof SetResourcePermissionCommand
     */
    'builtInRole'?: string;
    /**
     * 
     * @type {string}
     * @memberof SetResourcePermissionCommand
     */
    'permission'?: string;
    /**
     * 
     * @type {number}
     * @memberof SetResourcePermissionCommand
     */
    'teamId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SetResourcePermissionCommand
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface SetRoleAssignmentsCommand
 */
export interface SetRoleAssignmentsCommand {
    /**
     * 
     * @type {Array<number>}
     * @memberof SetRoleAssignmentsCommand
     */
    'service_accounts'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof SetRoleAssignmentsCommand
     */
    'teams'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof SetRoleAssignmentsCommand
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface SetTeamMembershipsCommand
 */
export interface SetTeamMembershipsCommand {
    /**
     * 
     * @type {Array<string>}
     * @memberof SetTeamMembershipsCommand
     */
    'admins'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetTeamMembershipsCommand
     */
    'members'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SetUserRolesCommand
 */
export interface SetUserRolesCommand {
    /**
     * 
     * @type {boolean}
     * @memberof SetUserRolesCommand
     */
    'global'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SetUserRolesCommand
     */
    'includeHidden'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SetUserRolesCommand
     */
    'roleUids'?: Array<string>;
}
/**
 * SigV4Config is the configuration for signing remote write requests with AWS\'s SigV4 verification process. Empty values will be retrieved using the AWS default credentials chain.
 * @export
 * @interface SigV4Config
 */
export interface SigV4Config {
    /**
     * 
     * @type {string}
     * @memberof SigV4Config
     */
    'AccessKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof SigV4Config
     */
    'Profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof SigV4Config
     */
    'Region'?: string;
    /**
     * 
     * @type {string}
     * @memberof SigV4Config
     */
    'RoleARN'?: string;
    /**
     * 
     * @type {string}
     * @memberof SigV4Config
     */
    'SecretKey'?: string;
}
/**
 * Silence silence
 * @export
 * @interface Silence
 */
export interface Silence {
    /**
     * comment
     * @type {string}
     * @memberof Silence
     */
    'comment': string;
    /**
     * created by
     * @type {string}
     * @memberof Silence
     */
    'createdBy': string;
    /**
     * ends at
     * @type {string}
     * @memberof Silence
     */
    'endsAt': string;
    /**
     * Matchers matchers
     * @type {Array<Matcher>}
     * @memberof Silence
     */
    'matchers': Array<Matcher>;
    /**
     * starts at
     * @type {string}
     * @memberof Silence
     */
    'startsAt': string;
}
/**
 * 
 * @export
 * @interface SilenceMetadata
 */
export interface SilenceMetadata {
    /**
     * 
     * @type {string}
     * @memberof SilenceMetadata
     */
    'folder_uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SilenceMetadata
     */
    'rule_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SilenceMetadata
     */
    'rule_uid'?: string;
}
/**
 * SilenceStatus silence status
 * @export
 * @interface SilenceStatus
 */
export interface SilenceStatus {
    /**
     * state
     * @type {string}
     * @memberof SilenceStatus
     */
    'state': SilenceStatusStateEnum;
}

export const SilenceStatusStateEnum = {
    ExpiredActivePending: '[expired active pending]'
} as const;

export type SilenceStatusStateEnum = typeof SilenceStatusStateEnum[keyof typeof SilenceStatusStateEnum];

/**
 * See https://api.slack.com/docs/message-attachments#action_fields and https://api.slack.com/docs/message-buttons for more information.
 * @export
 * @interface SlackAction
 */
export interface SlackAction {
    /**
     * 
     * @type {SlackConfirmationField}
     * @memberof SlackAction
     */
    'confirm'?: SlackConfirmationField;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'style'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackAction
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface SlackConfig
 */
export interface SlackConfig {
    /**
     * 
     * @type {Array<SlackAction>}
     * @memberof SlackConfig
     */
    'actions'?: Array<SlackAction>;
    /**
     * 
     * @type {URL}
     * @memberof SlackConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'api_url_file'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'callback_id'?: string;
    /**
     * Slack channel override, (like #other-channel or @username).
     * @type {string}
     * @memberof SlackConfig
     */
    'channel'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'fallback'?: string;
    /**
     * 
     * @type {Array<SlackField>}
     * @memberof SlackConfig
     */
    'fields'?: Array<SlackField>;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'footer'?: string;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof SlackConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'icon_emoji'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'icon_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'image_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SlackConfig
     */
    'link_names'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SlackConfig
     */
    'mrkdwn_in'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'pretext'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SlackConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SlackConfig
     */
    'short_fields'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'thumb_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'title_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfig
     */
    'username'?: string;
}
/**
 * SlackConfirmationField protect users from destructive actions or particularly distinguished decisions by asking them to confirm their button click one more time. See https://api.slack.com/docs/interactive-message-field-guide#confirmation_fields for more information.
 * @export
 * @interface SlackConfirmationField
 */
export interface SlackConfirmationField {
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmationField
     */
    'dismiss_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmationField
     */
    'ok_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmationField
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackConfirmationField
     */
    'title'?: string;
}
/**
 * Each field must contain a title, value, and optionally, a boolean value to indicate if the field is short enough to be displayed next to other fields designated as short. See https://api.slack.com/docs/message-attachments#fields for more information.
 * @export
 * @interface SlackField
 */
export interface SlackField {
    /**
     * 
     * @type {boolean}
     * @memberof SlackField
     */
    'short'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SlackField
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof SlackField
     */
    'value'?: string;
}
/**
 * Base snapshot without results
 * @export
 * @interface SnapshotDTO
 */
export interface SnapshotDTO {
    /**
     * 
     * @type {string}
     * @memberof SnapshotDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotDTO
     */
    'finished'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotDTO
     */
    'sessionUid'?: string;
    /**
     * 
     * @type {string}
     * @memberof SnapshotDTO
     */
    'status'?: SnapshotDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SnapshotDTO
     */
    'uid'?: string;
}

export const SnapshotDTOStatusEnum = {
    Initializing: 'INITIALIZING',
    Creating: 'CREATING',
    PendingUpload: 'PENDING_UPLOAD',
    Uploading: 'UPLOADING',
    PendingProcessing: 'PENDING_PROCESSING',
    Processing: 'PROCESSING',
    Finished: 'FINISHED',
    Canceled: 'CANCELED',
    Error: 'ERROR',
    Unknown: 'UNKNOWN'
} as const;

export type SnapshotDTOStatusEnum = typeof SnapshotDTOStatusEnum[keyof typeof SnapshotDTOStatusEnum];

/**
 * 
 * @export
 * @interface SnapshotListResponseDTO
 */
export interface SnapshotListResponseDTO {
    /**
     * 
     * @type {Array<SnapshotDTO>}
     * @memberof SnapshotListResponseDTO
     */
    'snapshots'?: Array<SnapshotDTO>;
}
/**
 * 
 * @export
 * @interface SnapshotResourceStats
 */
export interface SnapshotResourceStats {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof SnapshotResourceStats
     */
    'statuses'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof SnapshotResourceStats
     */
    'total'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof SnapshotResourceStats
     */
    'types'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface Span
 */
export interface Span {
    /**
     * Length of the span.
     * @type {number}
     * @memberof Span
     */
    'Length'?: number;
    /**
     * Gap to previous span (always positive), or starting index for the 1st span (which can be negative).
     * @type {number}
     * @memberof Span
     */
    'Offset'?: number;
}
/**
 * 
 * @export
 * @interface SuccessResponseBody
 */
export interface SuccessResponseBody {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponseBody
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface SyncResult
 */
export interface SyncResult {
    /**
     * A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years.
     * @type {number}
     * @memberof SyncResult
     */
    'Elapsed'?: number;
    /**
     * 
     * @type {Array<FailedUser>}
     * @memberof SyncResult
     */
    'FailedUsers'?: Array<FailedUser>;
    /**
     * 
     * @type {Array<number>}
     * @memberof SyncResult
     */
    'MissingUserIds'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof SyncResult
     */
    'Started'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SyncResult
     */
    'UpdatedUserIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TLSConfig
 */
export interface TLSConfig {
    /**
     * Text of the CA cert to use for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'ca'?: string;
    /**
     * The CA cert to use for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'ca_file'?: string;
    /**
     * CARef is the name of the secret within the secret manager to use as the CA cert for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'ca_ref'?: string;
    /**
     * Text of the client cert file for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'cert'?: string;
    /**
     * The client cert file for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'cert_file'?: string;
    /**
     * CertRef is the name of the secret within the secret manager to use as the client cert for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'cert_ref'?: string;
    /**
     * Disable target certificate validation.
     * @type {boolean}
     * @memberof TLSConfig
     */
    'insecure_skip_verify'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TLSConfig
     */
    'key'?: string;
    /**
     * The client key file for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'key_file'?: string;
    /**
     * KeyRef is the name of the secret within the secret manager to use as the client key for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'key_ref'?: string;
    /**
     * 
     * @type {number}
     * @memberof TLSConfig
     */
    'max_version'?: number;
    /**
     * 
     * @type {number}
     * @memberof TLSConfig
     */
    'min_version'?: number;
    /**
     * Used to verify the hostname for the targets.
     * @type {string}
     * @memberof TLSConfig
     */
    'server_name'?: string;
}
/**
 * 
 * @export
 * @interface TagsDTO
 */
export interface TagsDTO {
    /**
     * 
     * @type {number}
     * @memberof TagsDTO
     */
    'count'?: number;
    /**
     * 
     * @type {string}
     * @memberof TagsDTO
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface TeamDTO
 */
export interface TeamDTO {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof TeamDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {string}
     * @memberof TeamDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamDTO
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamDTO
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamDTO
     */
    'memberCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamDTO
     */
    'permission'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamDTO
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface TeamGroupDTO
 */
export interface TeamGroupDTO {
    /**
     * 
     * @type {string}
     * @memberof TeamGroupDTO
     */
    'groupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamGroupDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamGroupDTO
     */
    'teamId'?: number;
}
/**
 * 
 * @export
 * @interface TeamGroupMapping
 */
export interface TeamGroupMapping {
    /**
     * 
     * @type {string}
     * @memberof TeamGroupMapping
     */
    'groupId'?: string;
}
/**
 * 
 * @export
 * @interface TeamLBACRule
 */
export interface TeamLBACRule {
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamLBACRule
     */
    'rules'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TeamLBACRule
     */
    'teamId'?: string;
}
/**
 * 
 * @export
 * @interface TeamLBACRules
 */
export interface TeamLBACRules {
    /**
     * 
     * @type {Array<TeamLBACRule>}
     * @memberof TeamLBACRules
     */
    'rules'?: Array<TeamLBACRule>;
}
/**
 * 
 * @export
 * @interface TeamMemberDTO
 */
export interface TeamMemberDTO {
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'auth_module'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TeamMemberDTO
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDTO
     */
    'permission'?: number;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDTO
     */
    'teamId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TeamMemberDTO
     */
    'teamUID'?: string;
    /**
     * 
     * @type {number}
     * @memberof TeamMemberDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface TelegramConfig
 */
export interface TelegramConfig {
    /**
     * 
     * @type {URL}
     * @memberof TelegramConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {number}
     * @memberof TelegramConfig
     */
    'chat'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TelegramConfig
     */
    'disable_notifications'?: boolean;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof TelegramConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof TelegramConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelegramConfig
     */
    'parse_mode'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TelegramConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TelegramConfig
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof TelegramConfig
     */
    'token_file'?: string;
}
/**
 * 
 * @export
 * @interface TempUserDTO
 */
export interface TempUserDTO {
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'createdOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TempUserDTO
     */
    'emailSent'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'emailSentOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof TempUserDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'invitedByEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'invitedByLogin'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'invitedByName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TempUserDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'role'?: TempUserDTORoleEnum;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TempUserDTO
     */
    'url'?: string;
}

export const TempUserDTORoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type TempUserDTORoleEnum = typeof TempUserDTORoleEnum[keyof typeof TempUserDTORoleEnum];

/**
 * 
 * @export
 * @interface TestReceiverConfigResult
 */
export interface TestReceiverConfigResult {
    /**
     * 
     * @type {string}
     * @memberof TestReceiverConfigResult
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestReceiverConfigResult
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestReceiverConfigResult
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof TestReceiverConfigResult
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface TestReceiverResult
 */
export interface TestReceiverResult {
    /**
     * 
     * @type {Array<TestReceiverConfigResult>}
     * @memberof TestReceiverResult
     */
    'grafana_managed_receiver_configs'?: Array<TestReceiverConfigResult>;
    /**
     * 
     * @type {string}
     * @memberof TestReceiverResult
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TestReceiversConfigAlertParams
 */
export interface TestReceiversConfigAlertParams {
    /**
     * A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet may be fully-qualified down to the point where it may resolve to a single Metric in the data store or not.  All operations that occur within the realm of a LabelSet can emit a vector of Metric entities to which the LabelSet may match.
     * @type {{ [key: string]: string; }}
     * @memberof TestReceiversConfigAlertParams
     */
    'annotations'?: { [key: string]: string; };
    /**
     * A LabelSet is a collection of LabelName and LabelValue pairs.  The LabelSet may be fully-qualified down to the point where it may resolve to a single Metric in the data store or not.  All operations that occur within the realm of a LabelSet can emit a vector of Metric entities to which the LabelSet may match.
     * @type {{ [key: string]: string; }}
     * @memberof TestReceiversConfigAlertParams
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface TestReceiversConfigBodyParams
 */
export interface TestReceiversConfigBodyParams {
    /**
     * 
     * @type {TestReceiversConfigAlertParams}
     * @memberof TestReceiversConfigBodyParams
     */
    'alert'?: TestReceiversConfigAlertParams;
    /**
     * 
     * @type {Array<PostableApiReceiver>}
     * @memberof TestReceiversConfigBodyParams
     */
    'receivers'?: Array<PostableApiReceiver>;
}
/**
 * 
 * @export
 * @interface TestReceiversResult
 */
export interface TestReceiversResult {
    /**
     * 
     * @type {TestReceiversConfigAlertParams}
     * @memberof TestReceiversResult
     */
    'alert'?: TestReceiversConfigAlertParams;
    /**
     * 
     * @type {string}
     * @memberof TestReceiversResult
     */
    'notified_at'?: string;
    /**
     * 
     * @type {Array<TestReceiverResult>}
     * @memberof TestReceiversResult
     */
    'receivers'?: Array<TestReceiverResult>;
}
/**
 * 
 * @export
 * @interface TestRulePayload
 */
export interface TestRulePayload {
    /**
     * 
     * @type {string}
     * @memberof TestRulePayload
     */
    'expr'?: string;
    /**
     * 
     * @type {EvalAlertConditionCommand}
     * @memberof TestRulePayload
     */
    'grafana_condition'?: EvalAlertConditionCommand;
}
/**
 * 
 * @export
 * @interface TestRuleResponse
 */
export interface TestRuleResponse {
    /**
     * Vector is basically only an alias for []Sample, but the contract is that in a Vector, all Samples have the same timestamp.
     * @type {Array<Sample>}
     * @memberof TestRuleResponse
     */
    'alerts'?: Array<Sample>;
    /**
     * 
     * @type {AlertInstancesResponse}
     * @memberof TestRuleResponse
     */
    'grafana_alert_instances'?: AlertInstancesResponse;
}
/**
 * 
 * @export
 * @interface TestTemplatesConfigBodyParams
 */
export interface TestTemplatesConfigBodyParams {
    /**
     * Alerts to use as data when testing the template.
     * @type {Array<PostableAlert>}
     * @memberof TestTemplatesConfigBodyParams
     */
    'alerts'?: Array<PostableAlert>;
    /**
     * Name of the template file.
     * @type {string}
     * @memberof TestTemplatesConfigBodyParams
     */
    'name'?: string;
    /**
     * Template string to test.
     * @type {string}
     * @memberof TestTemplatesConfigBodyParams
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface TestTemplatesErrorResult
 */
export interface TestTemplatesErrorResult {
    /**
     * Kind of template error that occurred.
     * @type {string}
     * @memberof TestTemplatesErrorResult
     */
    'kind'?: TestTemplatesErrorResultKindEnum;
    /**
     * Error message.
     * @type {string}
     * @memberof TestTemplatesErrorResult
     */
    'message'?: string;
    /**
     * Name of the associated template for this error. Will be empty if the Kind is \"invalid_template\".
     * @type {string}
     * @memberof TestTemplatesErrorResult
     */
    'name'?: string;
}

export const TestTemplatesErrorResultKindEnum = {
    InvalidTemplate: 'invalid_template',
    ExecutionError: 'execution_error'
} as const;

export type TestTemplatesErrorResultKindEnum = typeof TestTemplatesErrorResultKindEnum[keyof typeof TestTemplatesErrorResultKindEnum];

/**
 * 
 * @export
 * @interface TestTemplatesResult
 */
export interface TestTemplatesResult {
    /**
     * Name of the associated template definition for this result.
     * @type {string}
     * @memberof TestTemplatesResult
     */
    'name'?: string;
    /**
     * Interpolated value of the template.
     * @type {string}
     * @memberof TestTemplatesResult
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface TestTemplatesResults
 */
export interface TestTemplatesResults {
    /**
     * 
     * @type {Array<TestTemplatesErrorResult>}
     * @memberof TestTemplatesResults
     */
    'errors'?: Array<TestTemplatesErrorResult>;
    /**
     * 
     * @type {Array<TestTemplatesResult>}
     * @memberof TestTemplatesResults
     */
    'results'?: Array<TestTemplatesResult>;
}
/**
 * Threshold a single step on the threshold list
 * @export
 * @interface Threshold
 */
export interface Threshold {
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    'state'?: string;
    /**
     * ConfFloat64 is a float64. It Marshals float64 values of NaN of Inf to null.
     * @type {number}
     * @memberof Threshold
     */
    'value'?: number;
}
/**
 * ThresholdsConfig setup thresholds
 * @export
 * @interface ThresholdsConfig
 */
export interface ThresholdsConfig {
    /**
     * ThresholdsMode absolute or percentage
     * @type {string}
     * @memberof ThresholdsConfig
     */
    'mode'?: string;
    /**
     * Must be sorted by \'value\', first value is always -Infinity
     * @type {Array<Threshold>}
     * @memberof ThresholdsConfig
     */
    'steps'?: Array<Threshold>;
}
/**
 * 
 * @export
 * @interface TimeInterval
 */
export interface TimeInterval {
    /**
     * 
     * @type {string}
     * @memberof TimeInterval
     */
    'name'?: string;
    /**
     * 
     * @type {Array<TimeInterval>}
     * @memberof TimeInterval
     */
    'time_intervals'?: Array<TimeInterval>;
}
/**
 * 
 * @export
 * @interface TimeIntervalItem
 */
export interface TimeIntervalItem {
    /**
     * 
     * @type {Array<string>}
     * @memberof TimeIntervalItem
     */
    'days_of_month'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TimeIntervalItem
     */
    'location'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TimeIntervalItem
     */
    'months'?: Array<string>;
    /**
     * 
     * @type {Array<TimeIntervalTimeRange>}
     * @memberof TimeIntervalItem
     */
    'times'?: Array<TimeIntervalTimeRange>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TimeIntervalItem
     */
    'weekdays'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TimeIntervalItem
     */
    'years'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TimeIntervalTimeRange
 */
export interface TimeIntervalTimeRange {
    /**
     * 
     * @type {string}
     * @memberof TimeIntervalTimeRange
     */
    'end_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeIntervalTimeRange
     */
    'start_time'?: string;
}
/**
 * Redefining this to avoid an import cycle
 * @export
 * @interface TimeRange
 */
export interface TimeRange {
    /**
     * 
     * @type {string}
     * @memberof TimeRange
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeRange
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'account'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'anonymousRatio'?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'company'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'details_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'exp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'iat'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'included_users'?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'iss'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'jti'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lexp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'lic_exp_warn_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'lid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'limit_by'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'max_concurrent_user_sessions'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'nbf'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Token
     */
    'prod'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'sub'?: string;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'tok_exp_warn_days'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Token
     */
    'trial'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'trial_exp'?: number;
    /**
     * 
     * @type {number}
     * @memberof Token
     */
    'update_days'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Token
     */
    'usage_billing'?: boolean;
}
/**
 * 
 * @export
 * @interface TokenDTO
 */
export interface TokenDTO {
    /**
     * 
     * @type {string}
     * @memberof TokenDTO
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDTO
     */
    'expiration'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenDTO
     */
    'hasExpired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TokenDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TokenDTO
     */
    'isRevoked'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenDTO
     */
    'lastUsedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenDTO
     */
    'secondsUntilExpiration'?: number;
}
/**
 * 
 * @export
 * @interface Transformation
 */
export interface Transformation {
    /**
     * 
     * @type {string}
     * @memberof Transformation
     */
    'expression'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transformation
     */
    'field'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transformation
     */
    'mapValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Transformation
     */
    'type'?: TransformationTypeEnum;
}

export const TransformationTypeEnum = {
    Regex: 'regex',
    Logfmt: 'logfmt'
} as const;

export type TransformationTypeEnum = typeof TransformationTypeEnum[keyof typeof TransformationTypeEnum];

/**
 * +k8s:deepcopy-gen=false
 * @export
 * @interface TypeMeta
 */
export interface TypeMeta {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof TypeMeta
     */
    'apiVersion'?: string;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof TypeMeta
     */
    'kind'?: string;
}
/**
 * The general form represented is:  [scheme:][//[userinfo@]host][/]path[?query][#fragment]  URLs that do not start with a slash after the scheme are interpreted as:  scheme:opaque[?query][#fragment]  The Host field contains the host and port subcomponents of the URL. When the port is present, it is separated from the host with a colon. When the host is an IPv6 address, it must be enclosed in square brackets: \"[fe80::1]:80\". The [net.JoinHostPort] function combines a host and port into a string suitable for the Host field, adding square brackets to the host when necessary.  Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/. A consequence is that it is impossible to tell which slashes in the Path were slashes in the raw URL and which were %2f. This distinction is rarely important, but when it is, the code should use the [URL.EscapedPath] method, which preserves the original encoding of Path.  The RawPath field is an optional field which is only set when the default encoding of Path is different from the escaped path. See the EscapedPath method for more details.  URL\'s String method uses the EscapedPath method to obtain the path.
 * @export
 * @interface URL
 */
export interface URL {
    /**
     * 
     * @type {boolean}
     * @memberof URL
     */
    'ForceQuery'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'Fragment'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'Host'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof URL
     */
    'OmitHost'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'Opaque'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'Path'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'RawFragment'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'RawPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'RawQuery'?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    'Scheme'?: string;
    /**
     * The Userinfo type is an immutable encapsulation of username and password details for a [URL]. An existing Userinfo value is guaranteed to have a username set (potentially empty, as allowed by RFC 2396), and optionally a password.
     * @type {object}
     * @memberof URL
     */
    'User'?: object;
}
/**
 * Unstructured allows objects that do not have Golang structs registered to be manipulated generically.
 * @export
 * @interface Unstructured
 */
export interface Unstructured {
    /**
     * Object is a JSON compatible map with string, float, int, bool, []interface{}, or map[string]interface{} children.
     * @type {{ [key: string]: any; }}
     * @memberof Unstructured
     */
    'Object'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateAnnotationsCmd
 */
export interface UpdateAnnotationsCmd {
    /**
     * 
     * @type {object}
     * @memberof UpdateAnnotationsCmd
     */
    'data'?: object;
    /**
     * 
     * @type {number}
     * @memberof UpdateAnnotationsCmd
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAnnotationsCmd
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateAnnotationsCmd
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAnnotationsCmd
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateAnnotationsCmd
     */
    'timeEnd'?: number;
}
/**
 * UpdateCorrelationCommand is the command for updating a correlation
 * @export
 * @interface UpdateCorrelationCommand
 */
export interface UpdateCorrelationCommand {
    /**
     * 
     * @type {CorrelationConfigUpdateDTO}
     * @memberof UpdateCorrelationCommand
     */
    'config'?: CorrelationConfigUpdateDTO;
    /**
     * Optional description of the correlation
     * @type {string}
     * @memberof UpdateCorrelationCommand
     */
    'description'?: string;
    /**
     * Optional label identifying the correlation
     * @type {string}
     * @memberof UpdateCorrelationCommand
     */
    'label'?: string;
    /**
     * the type of correlation, either query for containing query information, or external for containing an external URL +enum
     * @type {string}
     * @memberof UpdateCorrelationCommand
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface UpdateCorrelationResponseBody
 */
export interface UpdateCorrelationResponseBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateCorrelationResponseBody
     */
    'message'?: string;
    /**
     * 
     * @type {Correlation}
     * @memberof UpdateCorrelationResponseBody
     */
    'result'?: Correlation;
}
/**
 * 
 * @export
 * @interface UpdateDashboardACLCommand
 */
export interface UpdateDashboardACLCommand {
    /**
     * 
     * @type {Array<DashboardACLUpdateItem>}
     * @memberof UpdateDashboardACLCommand
     */
    'items'?: Array<DashboardACLUpdateItem>;
}
/**
 * Also acts as api DTO
 * @export
 * @interface UpdateDataSourceCommand
 */
export interface UpdateDataSourceCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'access'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDataSourceCommand
     */
    'basicAuth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'basicAuthUser'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'database'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDataSourceCommand
     */
    'isDefault'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof UpdateDataSourceCommand
     */
    'jsonData'?: object;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateDataSourceCommand
     */
    'secureJsonData'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataSourceCommand
     */
    'user'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateDataSourceCommand
     */
    'version'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDataSourceCommand
     */
    'withCredentials'?: boolean;
}
/**
 * UpdateFolderCommand captures the information required by the folder service to update a folder. Use Move to update a folder\'s parent folder.
 * @export
 * @interface UpdateFolderCommand
 */
export interface UpdateFolderCommand {
    /**
     * NewDescription it\'s an optional parameter used for overriding the existing folder description
     * @type {string}
     * @memberof UpdateFolderCommand
     */
    'description'?: string;
    /**
     * Overwrite only used by the legacy folder implementation
     * @type {boolean}
     * @memberof UpdateFolderCommand
     */
    'overwrite'?: boolean;
    /**
     * NewTitle it\'s an optional parameter used for overriding the existing folder title
     * @type {string}
     * @memberof UpdateFolderCommand
     */
    'title'?: string;
    /**
     * Version only used by the legacy folder implementation
     * @type {number}
     * @memberof UpdateFolderCommand
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface UpdateOrgAddressForm
 */
export interface UpdateOrgAddressForm {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgAddressForm
     */
    'zipcode'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrgForm
 */
export interface UpdateOrgForm {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgForm
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateOrgUserCommand
 */
export interface UpdateOrgUserCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrgUserCommand
     */
    'role'?: UpdateOrgUserCommandRoleEnum;
}

export const UpdateOrgUserCommandRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type UpdateOrgUserCommandRoleEnum = typeof UpdateOrgUserCommandRoleEnum[keyof typeof UpdateOrgUserCommandRoleEnum];

/**
 * 
 * @export
 * @interface UpdatePlaylistCommand
 */
export interface UpdatePlaylistCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdatePlaylistCommand
     */
    'interval'?: string;
    /**
     * 
     * @type {Array<PlaylistItem>}
     * @memberof UpdatePlaylistCommand
     */
    'items'?: Array<PlaylistItem>;
    /**
     * 
     * @type {string}
     * @memberof UpdatePlaylistCommand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePlaylistCommand
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface UpdatePrefsCmd
 */
export interface UpdatePrefsCmd {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdatePrefsCmd
     */
    'cookies'?: Array<string>;
    /**
     * The numerical :id of a favorited dashboard
     * @type {number}
     * @memberof UpdatePrefsCmd
     */
    'homeDashboardId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdatePrefsCmd
     */
    'homeDashboardUID'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePrefsCmd
     */
    'language'?: string;
    /**
     * 
     * @type {NavbarPreference}
     * @memberof UpdatePrefsCmd
     */
    'navbar'?: NavbarPreference;
    /**
     * 
     * @type {QueryHistoryPreference}
     * @memberof UpdatePrefsCmd
     */
    'queryHistory'?: QueryHistoryPreference;
    /**
     * 
     * @type {string}
     * @memberof UpdatePrefsCmd
     */
    'theme'?: UpdatePrefsCmdThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePrefsCmd
     */
    'timezone'?: UpdatePrefsCmdTimezoneEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdatePrefsCmd
     */
    'weekStart'?: string;
}

export const UpdatePrefsCmdThemeEnum = {
    Light: 'light',
    Dark: 'dark',
    System: 'system'
} as const;

export type UpdatePrefsCmdThemeEnum = typeof UpdatePrefsCmdThemeEnum[keyof typeof UpdatePrefsCmdThemeEnum];
export const UpdatePrefsCmdTimezoneEnum = {
    Utc: 'utc',
    Browser: 'browser'
} as const;

export type UpdatePrefsCmdTimezoneEnum = typeof UpdatePrefsCmdTimezoneEnum[keyof typeof UpdatePrefsCmdTimezoneEnum];

/**
 * 
 * @export
 * @interface UpdateProviderSettingsRequest
 */
export interface UpdateProviderSettingsRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateProviderSettingsRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProviderSettingsRequest
     */
    'provider'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateProviderSettingsRequest
     */
    'settings'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateQuotaCmd
 */
export interface UpdateQuotaCmd {
    /**
     * 
     * @type {number}
     * @memberof UpdateQuotaCmd
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateQuotaCmd
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface UpdateRoleCommand
 */
export interface UpdateRoleCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleCommand
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleCommand
     */
    'displayName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoleCommand
     */
    'global'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleCommand
     */
    'group'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRoleCommand
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateRoleCommand
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Permission>}
     * @memberof UpdateRoleCommand
     */
    'permissions'?: Array<Permission>;
    /**
     * 
     * @type {number}
     * @memberof UpdateRoleCommand
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface UpdateRuleGroupResponse
 */
export interface UpdateRuleGroupResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRuleGroupResponse
     */
    'created'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRuleGroupResponse
     */
    'deleted'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateRuleGroupResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateRuleGroupResponse
     */
    'updated'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateServiceAccount200Response
 */
export interface UpdateServiceAccount200Response {
    /**
     * 
     * @type {number}
     * @memberof UpdateServiceAccount200Response
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceAccount200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceAccount200Response
     */
    'name'?: string;
    /**
     * 
     * @type {ServiceAccountProfileDTO}
     * @memberof UpdateServiceAccount200Response
     */
    'serviceaccount'?: ServiceAccountProfileDTO;
}
/**
 * 
 * @export
 * @interface UpdateServiceAccountForm
 */
export interface UpdateServiceAccountForm {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateServiceAccountForm
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceAccountForm
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateServiceAccountForm
     */
    'role'?: UpdateServiceAccountFormRoleEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateServiceAccountForm
     */
    'serviceAccountId'?: number;
}

export const UpdateServiceAccountFormRoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type UpdateServiceAccountFormRoleEnum = typeof UpdateServiceAccountFormRoleEnum[keyof typeof UpdateServiceAccountFormRoleEnum];

/**
 * 
 * @export
 * @interface UpdateTeamCommand
 */
export interface UpdateTeamCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamCommand
     */
    'Email'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamCommand
     */
    'ID'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamCommand
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTeamLBACCommand
 */
export interface UpdateTeamLBACCommand {
    /**
     * 
     * @type {Array<TeamLBACRule>}
     * @memberof UpdateTeamLBACCommand
     */
    'rules'?: Array<TeamLBACRule>;
}
/**
 * 
 * @export
 * @interface UpdateTeamLBACRulesApi200Response
 */
export interface UpdateTeamLBACRulesApi200Response {
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamLBACRulesApi200Response
     */
    'id'?: number;
    /**
     * 
     * @type {TeamLBACRules}
     * @memberof UpdateTeamLBACRulesApi200Response
     */
    'lbacRules'?: TeamLBACRules;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamLBACRulesApi200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamLBACRulesApi200Response
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTeamLBACRulesApi200Response
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface UpdateTeamMemberCommand
 */
export interface UpdateTeamMemberCommand {
    /**
     * 
     * @type {number}
     * @memberof UpdateTeamMemberCommand
     */
    'permission'?: number;
}
/**
 * 
 * @export
 * @interface UpdateUserCommand
 */
export interface UpdateUserCommand {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserCommand
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserCommand
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserCommand
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserCommand
     */
    'theme'?: string;
}
/**
 * 
 * @export
 * @interface UserLookupDTO
 */
export interface UserLookupDTO {
    /**
     * 
     * @type {string}
     * @memberof UserLookupDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLookupDTO
     */
    'login'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserLookupDTO
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface UserOrgDTO
 */
export interface UserOrgDTO {
    /**
     * 
     * @type {string}
     * @memberof UserOrgDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserOrgDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserOrgDTO
     */
    'role'?: UserOrgDTORoleEnum;
}

export const UserOrgDTORoleEnum = {
    None: 'None',
    Viewer: 'Viewer',
    Editor: 'Editor',
    Admin: 'Admin'
} as const;

export type UserOrgDTORoleEnum = typeof UserOrgDTORoleEnum[keyof typeof UserOrgDTORoleEnum];

/**
 * 
 * @export
 * @interface UserProfileDTO
 */
export interface UserProfileDTO {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof UserProfileDTO
     */
    'accessControl'?: { [key: string]: boolean; };
    /**
     * 
     * @type {Array<string>}
     * @memberof UserProfileDTO
     */
    'authLabels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDTO
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDTO
     */
    'isExternal'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDTO
     */
    'isExternallySynced'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDTO
     */
    'isGrafanaAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserProfileDTO
     */
    'isGrafanaAdminExternallySynced'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserProfileDTO
     */
    'orgId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserSearchHitDTO
 */
export interface UserSearchHitDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchHitDTO
     */
    'authLabels'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSearchHitDTO
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSearchHitDTO
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSearchHitDTO
     */
    'isDisabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'lastSeenAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'lastSeenAtAge'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'login'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchHitDTO
     */
    'uid'?: string;
}
/**
 * UserToken represents a user token
 * @export
 * @interface UserToken
 */
export interface UserToken {
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'AuthToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserToken
     */
    'AuthTokenSeen'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'ClientIp'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'CreatedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'PrevAuthToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'RevokedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'RotatedAt'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'SeenAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'UnhashedToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'UpdatedAt'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'UserAgent'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserToken
     */
    'UserId'?: number;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'message'?: string;
}
/**
 * VersionInfo version info
 * @export
 * @interface VersionInfo
 */
export interface VersionInfo {
    /**
     * branch
     * @type {string}
     * @memberof VersionInfo
     */
    'branch': string;
    /**
     * build date
     * @type {string}
     * @memberof VersionInfo
     */
    'buildDate': string;
    /**
     * build user
     * @type {string}
     * @memberof VersionInfo
     */
    'buildUser': string;
    /**
     * go version
     * @type {string}
     * @memberof VersionInfo
     */
    'goVersion': string;
    /**
     * revision
     * @type {string}
     * @memberof VersionInfo
     */
    'revision': string;
    /**
     * version
     * @type {string}
     * @memberof VersionInfo
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface VictorOpsConfig
 */
export interface VictorOpsConfig {
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'api_key_file'?: string;
    /**
     * 
     * @type {URL}
     * @memberof VictorOpsConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VictorOpsConfig
     */
    'custom_fields'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'entity_display_name'?: string;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof VictorOpsConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'message_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'monitoring_tool'?: string;
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'routing_key'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VictorOpsConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VictorOpsConfig
     */
    'state_message'?: string;
}
/**
 * 
 * @export
 * @interface WebexConfig
 */
export interface WebexConfig {
    /**
     * 
     * @type {URL}
     * @memberof WebexConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof WebexConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof WebexConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebexConfig
     */
    'room_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebexConfig
     */
    'send_resolved'?: boolean;
}
/**
 * 
 * @export
 * @interface WebhookConfig
 */
export interface WebhookConfig {
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof WebhookConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * MaxAlerts is the maximum number of alerts to be sent per webhook message. Alerts exceeding this threshold will be truncated. Setting this to 0 allows an unlimited number of alerts.
     * @type {number}
     * @memberof WebhookConfig
     */
    'max_alerts'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {URL}
     * @memberof WebhookConfig
     */
    'url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof WebhookConfig
     */
    'url_file'?: string;
}
/**
 * 
 * @export
 * @interface WechatConfig
 */
export interface WechatConfig {
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'agent_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'api_secret'?: string;
    /**
     * 
     * @type {URL}
     * @memberof WechatConfig
     */
    'api_url'?: URL;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'corp_id'?: string;
    /**
     * 
     * @type {HTTPClientConfig}
     * @memberof WechatConfig
     */
    'http_config'?: HTTPClientConfig;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'message_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WechatConfig
     */
    'send_resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'to_party'?: string;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'to_tag'?: string;
    /**
     * 
     * @type {string}
     * @memberof WechatConfig
     */
    'to_user'?: string;
}

/**
 * AccessControlApi - axios parameter creator
 * @export
 */
export const AccessControlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamRole: async (teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamRole', 'teamId', teamId)
            // verify required parameter 'addTeamRoleCommand' is not null or undefined
            assertParamExists('addTeamRole', 'addTeamRoleCommand', addTeamRoleCommand)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole: async (userId: number, addUserRoleCommand: AddUserRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserRole', 'userId', userId)
            // verify required parameter 'addUserRoleCommand' is not null or undefined
            assertParamExists('addUserRole', 'addUserRoleCommand', addUserRoleCommand)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (createRoleForm: CreateRoleForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleForm' is not null or undefined
            assertParamExists('createRole', 'createRoleForm', createRoleForm)
            const localVarPath = `/access-control/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (roleUID: string, force?: boolean, global?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('deleteRole', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessControlStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-control/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a description of a resource\'s access control properties.
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDescription: async (resource: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('getResourceDescription', 'resource', resource)
            const localVarPath = `/access-control/{resource}/description`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get permissions for a resource.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePermissions: async (resource: string, resourceID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('getResourcePermissions', 'resource', resource)
            // verify required parameter 'resourceID' is not null or undefined
            assertParamExists('getResourcePermissions', 'resourceID', resourceID)
            const localVarPath = `/access-control/{resource}/{resourceID}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceID"}}`, encodeURIComponent(String(resourceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (roleUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('getRole', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments: async (roleUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('getRoleAssignments', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}/assignments`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (delegatable?: boolean, includeHidden?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-control/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (delegatable !== undefined) {
                localVarQueryParameter['delegatable'] = delegatable;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['includeHidden'] = includeHidden;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamRoles: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listTeamRoles', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamsRoles: async (rolesSearchQuery: RolesSearchQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolesSearchQuery' is not null or undefined
            assertParamExists('listTeamsRoles', 'rolesSearchQuery', rolesSearchQuery)
            const localVarPath = `/access-control/teams/roles/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolesSearchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserRoles', 'userId', userId)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersRoles: async (rolesSearchQuery: RolesSearchQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolesSearchQuery' is not null or undefined
            assertParamExists('listUsersRoles', 'rolesSearchQuery', rolesSearchQuery)
            const localVarPath = `/access-control/users/roles/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolesSearchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamRole: async (roleUID: string, teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('removeTeamRole', 'roleUID', roleUID)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamRole', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserRole: async (roleUID: string, userId: number, global?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('removeUserRole', 'roleUID', roleUID)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserRole', 'userId', userId)
            const localVarPath = `/access-control/users/{userId}/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {SetPermissionsCommand} setPermissionsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissions: async (resource: string, resourceID: string, setPermissionsCommand: SetPermissionsCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('setResourcePermissions', 'resource', resource)
            // verify required parameter 'resourceID' is not null or undefined
            assertParamExists('setResourcePermissions', 'resourceID', resourceID)
            // verify required parameter 'setPermissionsCommand' is not null or undefined
            assertParamExists('setResourcePermissions', 'setPermissionsCommand', setPermissionsCommand)
            const localVarPath = `/access-control/{resource}/{resourceID}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceID"}}`, encodeURIComponent(String(resourceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPermissionsCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a built-in role.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {string} builtInRole 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForBuiltInRole: async (resource: string, resourceID: string, builtInRole: string, setPermissionCommand: SetPermissionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('setResourcePermissionsForBuiltInRole', 'resource', resource)
            // verify required parameter 'resourceID' is not null or undefined
            assertParamExists('setResourcePermissionsForBuiltInRole', 'resourceID', resourceID)
            // verify required parameter 'builtInRole' is not null or undefined
            assertParamExists('setResourcePermissionsForBuiltInRole', 'builtInRole', builtInRole)
            // verify required parameter 'setPermissionCommand' is not null or undefined
            assertParamExists('setResourcePermissionsForBuiltInRole', 'setPermissionCommand', setPermissionCommand)
            const localVarPath = `/access-control/{resource}/{resourceID}/builtInRoles/{builtInRole}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceID"}}`, encodeURIComponent(String(resourceID)))
                .replace(`{${"builtInRole"}}`, encodeURIComponent(String(builtInRole)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPermissionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a team.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} teamID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForTeam: async (resource: string, resourceID: string, teamID: number, setPermissionCommand: SetPermissionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('setResourcePermissionsForTeam', 'resource', resource)
            // verify required parameter 'resourceID' is not null or undefined
            assertParamExists('setResourcePermissionsForTeam', 'resourceID', resourceID)
            // verify required parameter 'teamID' is not null or undefined
            assertParamExists('setResourcePermissionsForTeam', 'teamID', teamID)
            // verify required parameter 'setPermissionCommand' is not null or undefined
            assertParamExists('setResourcePermissionsForTeam', 'setPermissionCommand', setPermissionCommand)
            const localVarPath = `/access-control/{resource}/{resourceID}/teams/{teamID}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceID"}}`, encodeURIComponent(String(resourceID)))
                .replace(`{${"teamID"}}`, encodeURIComponent(String(teamID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPermissionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a user.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} userID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForUser: async (resource: string, resourceID: string, userID: number, setPermissionCommand: SetPermissionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resource' is not null or undefined
            assertParamExists('setResourcePermissionsForUser', 'resource', resource)
            // verify required parameter 'resourceID' is not null or undefined
            assertParamExists('setResourcePermissionsForUser', 'resourceID', resourceID)
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('setResourcePermissionsForUser', 'userID', userID)
            // verify required parameter 'setPermissionCommand' is not null or undefined
            assertParamExists('setResourcePermissionsForUser', 'setPermissionCommand', setPermissionCommand)
            const localVarPath = `/access-control/{resource}/{resourceID}/users/{userID}`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)))
                .replace(`{${"resourceID"}}`, encodeURIComponent(String(resourceID)))
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPermissionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAssignments: async (roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('setRoleAssignments', 'roleUID', roleUID)
            // verify required parameter 'setRoleAssignmentsCommand' is not null or undefined
            assertParamExists('setRoleAssignments', 'setRoleAssignmentsCommand', setRoleAssignmentsCommand)
            const localVarPath = `/access-control/roles/{roleUID}/assignments`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRoleAssignmentsCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamRoles: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setTeamRoles', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles: async (userId: number, setUserRolesCommand: SetUserRolesCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserRoles', 'userId', userId)
            // verify required parameter 'setUserRolesCommand' is not null or undefined
            assertParamExists('setUserRoles', 'setUserRolesCommand', setUserRolesCommand)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserRolesCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (roleUID: string, updateRoleCommand: UpdateRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('updateRole', 'roleUID', roleUID)
            // verify required parameter 'updateRoleCommand' is not null or undefined
            assertParamExists('updateRole', 'updateRoleCommand', updateRoleCommand)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessControlApi - functional programming interface
 * @export
 */
export const AccessControlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessControlApiAxiosParamCreator(configuration)
    return {
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamRole(teamId, addTeamRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.addTeamRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRole(userId, addUserRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.addUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(createRoleForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleUID, force, global, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessControlStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessControlStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getAccessControlStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a description of a resource\'s access control properties.
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceDescription(resource: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Description>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceDescription(resource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getResourceDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get permissions for a resource.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourcePermissions(resource: string, resourceID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourcePermissionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourcePermissions(resource, resourceID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getResourcePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(roleUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(roleUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignments(roleUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.getRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(delegatable, includeHidden, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamRoles(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamRoles(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listTeamRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<RoleDTO>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamsRoles(rolesSearchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listTeamsRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRoles(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<RoleDTO>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersRoles(rolesSearchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.listUsersRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamRole(roleUID, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.removeTeamRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserRole(roleUID, userId, global, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.removeUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {SetPermissionsCommand} setPermissionsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setResourcePermissions(resource: string, resourceID: string, setPermissionsCommand: SetPermissionsCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setResourcePermissions(resource, resourceID, setPermissionsCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setResourcePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a built-in role.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {string} builtInRole 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setResourcePermissionsForBuiltInRole(resource: string, resourceID: string, builtInRole: string, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setResourcePermissionsForBuiltInRole(resource, resourceID, builtInRole, setPermissionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setResourcePermissionsForBuiltInRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a team.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} teamID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setResourcePermissionsForTeam(resource: string, resourceID: string, teamID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setResourcePermissionsForTeam(resource, resourceID, teamID, setPermissionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setResourcePermissionsForTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a user.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} userID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setResourcePermissionsForUser(resource: string, resourceID: string, userID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setResourcePermissionsForUser(resource, resourceID, userID, setPermissionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setResourcePermissionsForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoleAssignments(roleUID, setRoleAssignmentsCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTeamRoles(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTeamRoles(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setTeamRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserRoles(userId, setUserRolesCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.setUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(roleUID, updateRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessControlApi - factory interface
 * @export
 */
export const AccessControlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessControlApiFp(configuration)
    return {
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addTeamRole(teamId, addTeamRoleCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addUserRole(userId, addUserRoleCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.createRole(createRoleForm, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRole(roleUID, force, global, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessControlStatus(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getAccessControlStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a description of a resource\'s access control properties.
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceDescription(resource: string, options?: RawAxiosRequestConfig): AxiosPromise<Description> {
            return localVarFp.getResourceDescription(resource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get permissions for a resource.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourcePermissions(resource: string, resourceID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ResourcePermissionDTO>> {
            return localVarFp.getResourcePermissions(resource, resourceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleUID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.getRole(roleUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentsDTO> {
            return localVarFp.getRoleAssignments(roleUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDTO>> {
            return localVarFp.listRoles(delegatable, includeHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamRoles(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.listTeamRoles(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<RoleDTO>; }> {
            return localVarFp.listTeamsRoles(rolesSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDTO>> {
            return localVarFp.listUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<RoleDTO>; }> {
            return localVarFp.listUsersRoles(rolesSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeTeamRole(roleUID, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeUserRole(roleUID, userId, global, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {SetPermissionsCommand} setPermissionsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissions(resource: string, resourceID: string, setPermissionsCommand: SetPermissionsCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setResourcePermissions(resource, resourceID, setPermissionsCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a built-in role.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {string} builtInRole 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForBuiltInRole(resource: string, resourceID: string, builtInRole: string, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setResourcePermissionsForBuiltInRole(resource, resourceID, builtInRole, setPermissionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a team.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} teamID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForTeam(resource: string, resourceID: string, teamID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setResourcePermissionsForTeam(resource, resourceID, teamID, setPermissionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
         * @summary Set resource permissions for a user.
         * @param {string} resource 
         * @param {string} resourceID 
         * @param {number} userID 
         * @param {SetPermissionCommand} setPermissionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setResourcePermissionsForUser(resource: string, resourceID: string, userID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setResourcePermissionsForUser(resource, resourceID, userID, setPermissionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentsDTO> {
            return localVarFp.setRoleAssignments(roleUID, setRoleAssignmentsCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamRoles(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setTeamRoles(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setUserRoles(userId, setUserRolesCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.updateRole(roleUID, updateRoleCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessControlApi - object-oriented interface
 * @export
 * @class AccessControlApi
 * @extends {BaseAPI}
 */
export class AccessControlApi extends BaseAPI {
    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * @summary Add team role.
     * @param {number} teamId 
     * @param {AddTeamRoleCommand} addTeamRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).addTeamRole(teamId, addTeamRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Add a user role assignment.
     * @param {number} userId 
     * @param {AddUserRoleCommand} addUserRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).addUserRole(userId, addUserRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * @summary Create a new custom role.
     * @param {CreateRoleForm} createRoleForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).createRole(createRoleForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * @summary Delete a custom role.
     * @param {string} roleUID 
     * @param {boolean} [force] 
     * @param {boolean} [global] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).deleteRole(roleUID, force, global, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * @summary Get status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getAccessControlStatus(options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getAccessControlStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a description of a resource\'s access control properties.
     * @param {string} resource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getResourceDescription(resource: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getResourceDescription(resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get permissions for a resource.
     * @param {string} resource 
     * @param {string} resourceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getResourcePermissions(resource: string, resourceID: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getResourcePermissions(resource, resourceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * @summary Get a role.
     * @param {string} roleUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getRole(roleUID: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getRole(roleUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * @summary Get role assignments.
     * @param {string} roleUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).getRoleAssignments(roleUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
     * @summary Get all roles.
     * @param {boolean} [delegatable] 
     * @param {boolean} [includeHidden] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listRoles(delegatable, includeHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * @summary Get team roles.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listTeamRoles(teamId: number, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listTeamRoles(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * @summary List roles assigned to multiple teams.
     * @param {RolesSearchQuery} rolesSearchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listTeamsRoles(rolesSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * @summary List roles assigned to a user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listUserRoles(userId: number, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * @summary List roles assigned to multiple users.
     * @param {RolesSearchQuery} rolesSearchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).listUsersRoles(rolesSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * @summary Remove team role.
     * @param {string} roleUID 
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).removeTeamRole(roleUID, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Remove a user role assignment.
     * @param {string} roleUID 
     * @param {number} userId 
     * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).removeUserRole(roleUID, userId, global, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to one or many assignment types. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * @summary Set resource permissions.
     * @param {string} resource 
     * @param {string} resourceID 
     * @param {SetPermissionsCommand} setPermissionsCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setResourcePermissions(resource: string, resourceID: string, setPermissionsCommand: SetPermissionsCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setResourcePermissions(resource, resourceID, setPermissionsCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a built-in role. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * @summary Set resource permissions for a built-in role.
     * @param {string} resource 
     * @param {string} resourceID 
     * @param {string} builtInRole 
     * @param {SetPermissionCommand} setPermissionCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setResourcePermissionsForBuiltInRole(resource: string, resourceID: string, builtInRole: string, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setResourcePermissionsForBuiltInRole(resource, resourceID, builtInRole, setPermissionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a team. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * @summary Set resource permissions for a team.
     * @param {string} resource 
     * @param {string} resourceID 
     * @param {number} teamID 
     * @param {SetPermissionCommand} setPermissionCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setResourcePermissionsForTeam(resource: string, resourceID: string, teamID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setResourcePermissionsForTeam(resource, resourceID, teamID, setPermissionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns permissions for a resource by a given type (`:resource`) and `:resourceID` to a user or a service account. Allowed resources are `datasources`, `teams`, `dashboards`, `folders`, and `serviceaccounts`. Refer to the `/access-control/{resource}/description` endpoint for allowed Permissions.
     * @summary Set resource permissions for a user.
     * @param {string} resource 
     * @param {string} resourceID 
     * @param {number} userID 
     * @param {SetPermissionCommand} setPermissionCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setResourcePermissionsForUser(resource: string, resourceID: string, userID: number, setPermissionCommand: SetPermissionCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setResourcePermissionsForUser(resource, resourceID, userID, setPermissionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * @summary Set role assignments.
     * @param {string} roleUID 
     * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setRoleAssignments(roleUID, setRoleAssignmentsCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * @summary Update team role.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setTeamRoles(teamId: number, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setTeamRoles(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Set user role assignments.
     * @param {number} userId 
     * @param {SetUserRolesCommand} setUserRolesCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).setUserRoles(userId, setUserRolesCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * @summary Update a custom role.
     * @param {string} roleUID 
     * @param {UpdateRoleCommand} updateRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlApi
     */
    public updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig) {
        return AccessControlApiFp(this.configuration).updateRole(roleUID, updateRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccessControlProvisioningApi - axios parameter creator
 * @export
 */
export const AccessControlProvisioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadAccessControl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/provisioning/access-control/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessControlProvisioningApi - functional programming interface
 * @export
 */
export const AccessControlProvisioningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccessControlProvisioningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProvisioningReloadAccessControl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccessControlProvisioningApi.adminProvisioningReloadAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccessControlProvisioningApi - factory interface
 * @export
 */
export const AccessControlProvisioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccessControlProvisioningApiFp(configuration)
    return {
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig): AxiosPromise<ErrorResponseBody> {
            return localVarFp.adminProvisioningReloadAccessControl(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessControlProvisioningApi - object-oriented interface
 * @export
 * @class AccessControlProvisioningApi
 * @extends {BaseAPI}
 */
export class AccessControlProvisioningApi extends BaseAPI {
    /**
     * 
     * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessControlProvisioningApi
     */
    public adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig) {
        return AccessControlProvisioningApiFp(this.configuration).adminProvisioningReloadAccessControl(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
         * @summary Fetch settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
         * @summary Fetch Grafana Stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
         * @summary Fetch settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: string; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
         * @summary Fetch Grafana Stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminGetStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
         * @summary Fetch settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetSettings(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: string; }; }> {
            return localVarFp.adminGetSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
         * @summary Fetch Grafana Stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetStats(options?: RawAxiosRequestConfig): AxiosPromise<AdminStats> {
            return localVarFp.adminGetStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `settings:read` and scopes: `settings:*`, `settings:auth.saml:` and `settings:auth.saml:enabled` (property level).
     * @summary Fetch settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetSettings(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `server:stats:read`.
     * @summary Fetch Grafana Stats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminGetStats(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminGetStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminLdapApi - axios parameter creator
 * @export
 */
export const AdminLdapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
         * @summary Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/ldap/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
         * @summary Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFromLDAP: async (userName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userName' is not null or undefined
            assertParamExists('getUserFromLDAP', 'userName', userName)
            const localVarPath = `/admin/ldap/{user_name}`
                .replace(`{${"user_name"}}`, encodeURIComponent(String(userName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
         * @summary Enables a single Grafana user to be synchronized against LDAP.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSyncUserWithLDAP: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postSyncUserWithLDAP', 'userId', userId)
            const localVarPath = `/admin/ldap/sync/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
         * @summary Reloads the LDAP configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadLDAPCfg: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/ldap/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLdapApi - functional programming interface
 * @export
 */
export const AdminLdapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLdapApiAxiosParamCreator(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
         * @summary Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLDAPStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLDAPStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLdapApi.getLDAPStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
         * @summary Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFromLDAP(userName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFromLDAP(userName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLdapApi.getUserFromLDAP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
         * @summary Enables a single Grafana user to be synchronized against LDAP.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSyncUserWithLDAP(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSyncUserWithLDAP(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLdapApi.postSyncUserWithLDAP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
         * @summary Reloads the LDAP configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reloadLDAPCfg(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reloadLDAPCfg(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLdapApi.reloadLDAPCfg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLdapApi - factory interface
 * @export
 */
export const AdminLdapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLdapApiFp(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
         * @summary Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLDAPStatus(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.getLDAPStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
         * @summary Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
         * @param {string} userName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFromLDAP(userName: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.getUserFromLDAP(userName, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
         * @summary Enables a single Grafana user to be synchronized against LDAP.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSyncUserWithLDAP(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.postSyncUserWithLDAP(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
         * @summary Reloads the LDAP configuration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reloadLDAPCfg(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.reloadLDAPCfg(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLdapApi - object-oriented interface
 * @export
 * @class AdminLdapApi
 * @extends {BaseAPI}
 */
export class AdminLdapApi extends BaseAPI {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.status:read`.
     * @summary Attempts to connect to all the configured LDAP servers and returns information on whenever they\'re available or not.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLdapApi
     */
    public getLDAPStatus(options?: RawAxiosRequestConfig) {
        return AdminLdapApiFp(this.configuration).getLDAPStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:read`.
     * @summary Finds an user based on a username in LDAP. This helps illustrate how would the particular user be mapped in Grafana when synced.
     * @param {string} userName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLdapApi
     */
    public getUserFromLDAP(userName: string, options?: RawAxiosRequestConfig) {
        return AdminLdapApiFp(this.configuration).getUserFromLDAP(userName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.user:sync`.
     * @summary Enables a single Grafana user to be synchronized against LDAP.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLdapApi
     */
    public postSyncUserWithLDAP(userId: number, options?: RawAxiosRequestConfig) {
        return AdminLdapApiFp(this.configuration).postSyncUserWithLDAP(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `ldap.config:reload`.
     * @summary Reloads the LDAP configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminLdapApi
     */
    public reloadLDAPCfg(options?: RawAxiosRequestConfig) {
        return AdminLdapApiFp(this.configuration).reloadLDAPCfg(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminProvisioningApi - axios parameter creator
 * @export
 */
export const AdminProvisioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
         * @summary Reload dashboard provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadDashboards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/provisioning/dashboards/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
         * @summary Reload datasource provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadDatasources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/provisioning/datasources/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
         * @summary Reload plugin provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadPlugins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/provisioning/plugins/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminProvisioningApi - functional programming interface
 * @export
 */
export const AdminProvisioningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminProvisioningApiAxiosParamCreator(configuration)
    return {
        /**
         * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
         * @summary Reload dashboard provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProvisioningReloadDashboards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProvisioningReloadDashboards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProvisioningApi.adminProvisioningReloadDashboards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
         * @summary Reload datasource provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProvisioningReloadDatasources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProvisioningReloadDatasources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProvisioningApi.adminProvisioningReloadDatasources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
         * @summary Reload plugin provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProvisioningReloadPlugins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProvisioningReloadPlugins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminProvisioningApi.adminProvisioningReloadPlugins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminProvisioningApi - factory interface
 * @export
 */
export const AdminProvisioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminProvisioningApiFp(configuration)
    return {
        /**
         * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
         * @summary Reload dashboard provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadDashboards(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminProvisioningReloadDashboards(options).then((request) => request(axios, basePath));
        },
        /**
         * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
         * @summary Reload datasource provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadDatasources(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminProvisioningReloadDatasources(options).then((request) => request(axios, basePath));
        },
        /**
         * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
         * @summary Reload plugin provisioning configurations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadPlugins(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminProvisioningReloadPlugins(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminProvisioningApi - object-oriented interface
 * @export
 * @class AdminProvisioningApi
 * @extends {BaseAPI}
 */
export class AdminProvisioningApi extends BaseAPI {
    /**
     * Reloads the provisioning config files for dashboards again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:dashboards`.
     * @summary Reload dashboard provisioning configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProvisioningApi
     */
    public adminProvisioningReloadDashboards(options?: RawAxiosRequestConfig) {
        return AdminProvisioningApiFp(this.configuration).adminProvisioningReloadDashboards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reloads the provisioning config files for datasources again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:datasources`.
     * @summary Reload datasource provisioning configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProvisioningApi
     */
    public adminProvisioningReloadDatasources(options?: RawAxiosRequestConfig) {
        return AdminProvisioningApiFp(this.configuration).adminProvisioningReloadDatasources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reloads the provisioning config files for plugins again. It won’t return until the new provisioned entities are already stored in the database. In case of dashboards, it will stop polling for changes in dashboard files and then restart it with new configurations after returning. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `provisioning:reload` and scope `provisioners:plugin`.
     * @summary Reload plugin provisioning configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminProvisioningApi
     */
    public adminProvisioningReloadPlugins(options?: RawAxiosRequestConfig) {
        return AdminProvisioningApiFp(this.configuration).adminProvisioningReloadPlugins(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminUsersApi - axios parameter creator
 * @export
 */
export const AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
         * @summary Create new user.
         * @param {AdminCreateUserForm} adminCreateUserForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser: async (adminCreateUserForm: AdminCreateUserForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreateUserForm' is not null or undefined
            assertParamExists('adminCreateUser', 'adminCreateUserForm', adminCreateUserForm)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreateUserForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
         * @summary Delete global User.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminDeleteUser', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
         * @summary Disable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDisableUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminDisableUser', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}/disable`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
         * @summary Enable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEnableUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminEnableUser', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}/enable`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
         * @summary Return a list of all auth tokens (devices) that the user currently have logged in from.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUserAuthTokens: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminGetUserAuthTokens', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}/auth-tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
         * @summary Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogoutUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminLogoutUser', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}/logout`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
         * @summary Revoke auth token for user.
         * @param {number} userId 
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRevokeUserAuthToken: async (userId: number, revokeAuthTokenCmd: RevokeAuthTokenCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminRevokeUserAuthToken', 'userId', userId)
            // verify required parameter 'revokeAuthTokenCmd' is not null or undefined
            assertParamExists('adminRevokeUserAuthToken', 'revokeAuthTokenCmd', revokeAuthTokenCmd)
            const localVarPath = `/admin/users/{user_id}/revoke-auth-token`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeAuthTokenCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
         * @summary Set password for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPasswordForm} adminUpdateUserPasswordForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUserPassword: async (userId: number, adminUpdateUserPasswordForm: AdminUpdateUserPasswordForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUpdateUserPassword', 'userId', userId)
            // verify required parameter 'adminUpdateUserPasswordForm' is not null or undefined
            assertParamExists('adminUpdateUserPassword', 'adminUpdateUserPasswordForm', adminUpdateUserPasswordForm)
            const localVarPath = `/admin/users/{user_id}/password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateUserPasswordForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
         * @summary Set permissions for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPermissionsForm} adminUpdateUserPermissionsForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUserPermissions: async (userId: number, adminUpdateUserPermissionsForm: AdminUpdateUserPermissionsForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('adminUpdateUserPermissions', 'userId', userId)
            // verify required parameter 'adminUpdateUserPermissionsForm' is not null or undefined
            assertParamExists('adminUpdateUserPermissions', 'adminUpdateUserPermissionsForm', adminUpdateUserPermissionsForm)
            const localVarPath = `/admin/users/{user_id}/permissions`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminUpdateUserPermissionsForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
         * @summary Fetch user quota.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuota: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserQuota', 'userId', userId)
            const localVarPath = `/admin/users/{user_id}/quotas`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} userId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota: async (quotaTarget: string, userId: number, updateQuotaCmd: UpdateQuotaCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quotaTarget' is not null or undefined
            assertParamExists('updateUserQuota', 'quotaTarget', quotaTarget)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserQuota', 'userId', userId)
            // verify required parameter 'updateQuotaCmd' is not null or undefined
            assertParamExists('updateUserQuota', 'updateQuotaCmd', updateQuotaCmd)
            const localVarPath = `/admin/users/{user_id}/quotas/{quota_target}`
                .replace(`{${"quota_target"}}`, encodeURIComponent(String(quotaTarget)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateQuotaCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUsersApi - functional programming interface
 * @export
 */
export const AdminUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
         * @summary Create new user.
         * @param {AdminCreateUserForm} adminCreateUserForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminCreateUser(adminCreateUserForm: AdminCreateUserForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminCreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminCreateUser(adminCreateUserForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
         * @summary Delete global User.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDeleteUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDeleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
         * @summary Disable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminDisableUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminDisableUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminDisableUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
         * @summary Enable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminEnableUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminEnableUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminEnableUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
         * @summary Return a list of all auth tokens (devices) that the user currently have logged in from.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminGetUserAuthTokens(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminGetUserAuthTokens(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminGetUserAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
         * @summary Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminLogoutUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminLogoutUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminLogoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
         * @summary Revoke auth token for user.
         * @param {number} userId 
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminRevokeUserAuthToken(userId: number, revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminRevokeUserAuthToken(userId, revokeAuthTokenCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminRevokeUserAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
         * @summary Set password for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPasswordForm} adminUpdateUserPasswordForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUserPassword(userId: number, adminUpdateUserPasswordForm: AdminUpdateUserPasswordForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUserPassword(userId, adminUpdateUserPasswordForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminUpdateUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
         * @summary Set permissions for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPermissionsForm} adminUpdateUserPermissionsForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUpdateUserPermissions(userId: number, adminUpdateUserPermissionsForm: AdminUpdateUserPermissionsForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUpdateUserPermissions(userId, adminUpdateUserPermissionsForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.adminUpdateUserPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
         * @summary Fetch user quota.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserQuota(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuotaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserQuota(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.getUserQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} userId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserQuota(quotaTarget: string, userId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserQuota(quotaTarget, userId, updateQuotaCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.updateUserQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUsersApi - factory interface
 * @export
 */
export const AdminUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUsersApiFp(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
         * @summary Create new user.
         * @param {AdminCreateUserForm} adminCreateUserForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminCreateUser(adminCreateUserForm: AdminCreateUserForm, options?: RawAxiosRequestConfig): AxiosPromise<AdminCreateUserResponse> {
            return localVarFp.adminCreateUser(adminCreateUserForm, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
         * @summary Delete global User.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDeleteUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminDeleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
         * @summary Disable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminDisableUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminDisableUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
         * @summary Enable user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEnableUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminEnableUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
         * @summary Return a list of all auth tokens (devices) that the user currently have logged in from.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminGetUserAuthTokens(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserToken>> {
            return localVarFp.adminGetUserAuthTokens(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
         * @summary Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminLogoutUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminLogoutUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
         * @summary Revoke auth token for user.
         * @param {number} userId 
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminRevokeUserAuthToken(userId: number, revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminRevokeUserAuthToken(userId, revokeAuthTokenCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
         * @summary Set password for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPasswordForm} adminUpdateUserPasswordForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUserPassword(userId: number, adminUpdateUserPasswordForm: AdminUpdateUserPasswordForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminUpdateUserPassword(userId, adminUpdateUserPasswordForm, options).then((request) => request(axios, basePath));
        },
        /**
         * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
         * @summary Set permissions for user.
         * @param {number} userId 
         * @param {AdminUpdateUserPermissionsForm} adminUpdateUserPermissionsForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUpdateUserPermissions(userId: number, adminUpdateUserPermissionsForm: AdminUpdateUserPermissionsForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.adminUpdateUserPermissions(userId, adminUpdateUserPermissionsForm, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
         * @summary Fetch user quota.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuota(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<QuotaDTO>> {
            return localVarFp.getUserQuota(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} userId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota(quotaTarget: string, userId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateUserQuota(quotaTarget, userId, updateQuotaCmd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUsersApi - object-oriented interface
 * @export
 * @class AdminUsersApi
 * @extends {BaseAPI}
 */
export class AdminUsersApi extends BaseAPI {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:create`. Note that OrgId is an optional parameter that can be used to assign a new user to a different organization when `auto_assign_org` is set to `true`.
     * @summary Create new user.
     * @param {AdminCreateUserForm} adminCreateUserForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminCreateUser(adminCreateUserForm: AdminCreateUserForm, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminCreateUser(adminCreateUserForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:delete` and scope `global.users:*`.
     * @summary Delete global User.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminDeleteUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminDeleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:disable` and scope `global.users:1` (userIDScope).
     * @summary Disable user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminDisableUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminDisableUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users:enable` and scope `global.users:1` (userIDScope).
     * @summary Enable user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminEnableUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminEnableUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:list` and scope `global.users:*`.
     * @summary Return a list of all auth tokens (devices) that the user currently have logged in from.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminGetUserAuthTokens(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminGetUserAuthTokens(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.logout` and scope `global.users:*`.
     * @summary Logout user revokes all auth tokens (devices) for the user. User of issued auth tokens (devices) will no longer be logged in and will be required to authenticate again upon next activity.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminLogoutUser(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminLogoutUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes the given auth token (device) for the user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.authtoken:update` and scope `global.users:*`.
     * @summary Revoke auth token for user.
     * @param {number} userId 
     * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminRevokeUserAuthToken(userId: number, revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminRevokeUserAuthToken(userId, revokeAuthTokenCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.password:update` and scope `global.users:*`.
     * @summary Set password for user.
     * @param {number} userId 
     * @param {AdminUpdateUserPasswordForm} adminUpdateUserPasswordForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminUpdateUserPassword(userId: number, adminUpdateUserPasswordForm: AdminUpdateUserPasswordForm, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminUpdateUserPassword(userId, adminUpdateUserPasswordForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only works with Basic Authentication (username and password). See introduction for an explanation. If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.permissions:update` and scope `global.users:*`.
     * @summary Set permissions for user.
     * @param {number} userId 
     * @param {AdminUpdateUserPermissionsForm} adminUpdateUserPermissionsForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public adminUpdateUserPermissions(userId: number, adminUpdateUserPermissionsForm: AdminUpdateUserPermissionsForm, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).adminUpdateUserPermissions(userId, adminUpdateUserPermissionsForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:list` and scope `global.users:1` (userIDScope).
     * @summary Fetch user quota.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public getUserQuota(userId: number, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).getUserQuota(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `users.quotas:update` and scope `global.users:1` (userIDScope).
     * @summary Update user quota.
     * @param {string} quotaTarget 
     * @param {number} userId 
     * @param {UpdateQuotaCmd} updateQuotaCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminUsersApi
     */
    public updateUserQuota(quotaTarget: string, userId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).updateUserQuota(quotaTarget, userId, updateQuotaCmd, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnnotationsApi - axios parameter creator
 * @export
 */
export const AnnotationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the annotation that matches the specified ID.
         * @summary Delete Annotation By ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationByID: async (annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('deleteAnnotationByID', 'annotationId', annotationId)
            const localVarPath = `/annotations/{annotation_id}`
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Annotation by ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationByID: async (annotationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('getAnnotationByID', 'annotationId', annotationId)
            const localVarPath = `/annotations/{annotation_id}`
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find all the event tags created in the annotations.
         * @summary Find Annotations Tags.
         * @param {string} [tag] Tag is a string that you can use to filter tags.
         * @param {string} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationTags: async (tag?: string, limit?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
         * @summary Find Annotations.
         * @param {number} [from] Find annotations created after specific epoch datetime in milliseconds.
         * @param {number} [to] Find annotations created before specific epoch datetime in milliseconds.
         * @param {number} [userId] Limit response to annotations created by specific user.
         * @param {number} [alertId] Find annotations for a specified alert.
         * @param {number} [dashboardId] Find annotations that are scoped to a specific dashboard
         * @param {string} [dashboardUID] Find annotations that are scoped to a specific dashboard
         * @param {number} [panelId] Find annotations that are scoped to a specific panel
         * @param {number} [limit] Max limit for results returned.
         * @param {Array<string>} [tags] Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
         * @param {GetAnnotationsTypeEnum} [type] Return alerts or user created annotations
         * @param {boolean} [matchAny] Match any or all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotations: async (from?: number, to?: number, userId?: number, alertId?: number, dashboardId?: number, dashboardUID?: string, panelId?: number, limit?: number, tags?: Array<string>, type?: GetAnnotationsTypeEnum, matchAny?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (alertId !== undefined) {
                localVarQueryParameter['alertId'] = alertId;
            }

            if (dashboardId !== undefined) {
                localVarQueryParameter['dashboardId'] = dashboardId;
            }

            if (dashboardUID !== undefined) {
                localVarQueryParameter['dashboardUID'] = dashboardUID;
            }

            if (panelId !== undefined) {
                localVarQueryParameter['panelId'] = panelId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (matchAny !== undefined) {
                localVarQueryParameter['matchAny'] = matchAny;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete multiple annotations.
         * @param {MassDeleteAnnotationsCmd} massDeleteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteAnnotations: async (massDeleteAnnotationsCmd: MassDeleteAnnotationsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'massDeleteAnnotationsCmd' is not null or undefined
            assertParamExists('massDeleteAnnotations', 'massDeleteAnnotationsCmd', massDeleteAnnotationsCmd)
            const localVarPath = `/annotations/mass-delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(massDeleteAnnotationsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
         * @summary Patch Annotation.
         * @param {string} annotationId 
         * @param {PatchAnnotationsCmd} patchAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAnnotation: async (annotationId: string, patchAnnotationsCmd: PatchAnnotationsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('patchAnnotation', 'annotationId', annotationId)
            // verify required parameter 'patchAnnotationsCmd' is not null or undefined
            assertParamExists('patchAnnotation', 'patchAnnotationsCmd', patchAnnotationsCmd)
            const localVarPath = `/annotations/{annotation_id}`
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAnnotationsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
         * @summary Create Annotation.
         * @param {PostAnnotationsCmd} postAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnnotation: async (postAnnotationsCmd: PostAnnotationsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postAnnotationsCmd' is not null or undefined
            assertParamExists('postAnnotation', 'postAnnotationsCmd', postAnnotationsCmd)
            const localVarPath = `/annotations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postAnnotationsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
         * @summary Create Annotation in Graphite format.
         * @param {PostGraphiteAnnotationsCmd} postGraphiteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphiteAnnotation: async (postGraphiteAnnotationsCmd: PostGraphiteAnnotationsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postGraphiteAnnotationsCmd' is not null or undefined
            assertParamExists('postGraphiteAnnotation', 'postGraphiteAnnotationsCmd', postGraphiteAnnotationsCmd)
            const localVarPath = `/annotations/graphite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postGraphiteAnnotationsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
         * @summary Update Annotation.
         * @param {string} annotationId 
         * @param {UpdateAnnotationsCmd} updateAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotation: async (annotationId: string, updateAnnotationsCmd: UpdateAnnotationsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('updateAnnotation', 'annotationId', annotationId)
            // verify required parameter 'updateAnnotationsCmd' is not null or undefined
            assertParamExists('updateAnnotation', 'updateAnnotationsCmd', updateAnnotationsCmd)
            const localVarPath = `/annotations/{annotation_id}`
                .replace(`{${"annotation_id"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAnnotationsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationsApi - functional programming interface
 * @export
 */
export const AnnotationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes the annotation that matches the specified ID.
         * @summary Delete Annotation By ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnotationByID(annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.deleteAnnotationByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Annotation by ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Annotation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotationByID(annotationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.getAnnotationByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find all the event tags created in the annotations.
         * @summary Find Annotations Tags.
         * @param {string} [tag] Tag is a string that you can use to filter tags.
         * @param {string} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotationTags(tag?: string, limit?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAnnotationTagsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotationTags(tag, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.getAnnotationTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
         * @summary Find Annotations.
         * @param {number} [from] Find annotations created after specific epoch datetime in milliseconds.
         * @param {number} [to] Find annotations created before specific epoch datetime in milliseconds.
         * @param {number} [userId] Limit response to annotations created by specific user.
         * @param {number} [alertId] Find annotations for a specified alert.
         * @param {number} [dashboardId] Find annotations that are scoped to a specific dashboard
         * @param {string} [dashboardUID] Find annotations that are scoped to a specific dashboard
         * @param {number} [panelId] Find annotations that are scoped to a specific panel
         * @param {number} [limit] Max limit for results returned.
         * @param {Array<string>} [tags] Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
         * @param {GetAnnotationsTypeEnum} [type] Return alerts or user created annotations
         * @param {boolean} [matchAny] Match any or all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotations(from?: number, to?: number, userId?: number, alertId?: number, dashboardId?: number, dashboardUID?: string, panelId?: number, limit?: number, tags?: Array<string>, type?: GetAnnotationsTypeEnum, matchAny?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Annotation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotations(from, to, userId, alertId, dashboardId, dashboardUID, panelId, limit, tags, type, matchAny, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.getAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete multiple annotations.
         * @param {MassDeleteAnnotationsCmd} massDeleteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async massDeleteAnnotations(massDeleteAnnotationsCmd: MassDeleteAnnotationsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.massDeleteAnnotations(massDeleteAnnotationsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.massDeleteAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
         * @summary Patch Annotation.
         * @param {string} annotationId 
         * @param {PatchAnnotationsCmd} patchAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAnnotation(annotationId: string, patchAnnotationsCmd: PatchAnnotationsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAnnotation(annotationId, patchAnnotationsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.patchAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
         * @summary Create Annotation.
         * @param {PostAnnotationsCmd} postAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAnnotation(postAnnotationsCmd: PostAnnotationsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAnnotation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAnnotation(postAnnotationsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.postAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
         * @summary Create Annotation in Graphite format.
         * @param {PostGraphiteAnnotationsCmd} postGraphiteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGraphiteAnnotation(postGraphiteAnnotationsCmd: PostGraphiteAnnotationsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostAnnotation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGraphiteAnnotation(postGraphiteAnnotationsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.postGraphiteAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
         * @summary Update Annotation.
         * @param {string} annotationId 
         * @param {UpdateAnnotationsCmd} updateAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnotation(annotationId: string, updateAnnotationsCmd: UpdateAnnotationsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnotation(annotationId, updateAnnotationsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnnotationsApi.updateAnnotation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnnotationsApi - factory interface
 * @export
 */
export const AnnotationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationsApiFp(configuration)
    return {
        /**
         * Deletes the annotation that matches the specified ID.
         * @summary Delete Annotation By ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteAnnotationByID(annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Annotation by ID.
         * @param {string} annotationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Annotation> {
            return localVarFp.getAnnotationByID(annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find all the event tags created in the annotations.
         * @summary Find Annotations Tags.
         * @param {string} [tag] Tag is a string that you can use to filter tags.
         * @param {string} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationTags(tag?: string, limit?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAnnotationTagsResponse> {
            return localVarFp.getAnnotationTags(tag, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
         * @summary Find Annotations.
         * @param {number} [from] Find annotations created after specific epoch datetime in milliseconds.
         * @param {number} [to] Find annotations created before specific epoch datetime in milliseconds.
         * @param {number} [userId] Limit response to annotations created by specific user.
         * @param {number} [alertId] Find annotations for a specified alert.
         * @param {number} [dashboardId] Find annotations that are scoped to a specific dashboard
         * @param {string} [dashboardUID] Find annotations that are scoped to a specific dashboard
         * @param {number} [panelId] Find annotations that are scoped to a specific panel
         * @param {number} [limit] Max limit for results returned.
         * @param {Array<string>} [tags] Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
         * @param {GetAnnotationsTypeEnum} [type] Return alerts or user created annotations
         * @param {boolean} [matchAny] Match any or all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotations(from?: number, to?: number, userId?: number, alertId?: number, dashboardId?: number, dashboardUID?: string, panelId?: number, limit?: number, tags?: Array<string>, type?: GetAnnotationsTypeEnum, matchAny?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Annotation>> {
            return localVarFp.getAnnotations(from, to, userId, alertId, dashboardId, dashboardUID, panelId, limit, tags, type, matchAny, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete multiple annotations.
         * @param {MassDeleteAnnotationsCmd} massDeleteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        massDeleteAnnotations(massDeleteAnnotationsCmd: MassDeleteAnnotationsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.massDeleteAnnotations(massDeleteAnnotationsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
         * @summary Patch Annotation.
         * @param {string} annotationId 
         * @param {PatchAnnotationsCmd} patchAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAnnotation(annotationId: string, patchAnnotationsCmd: PatchAnnotationsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.patchAnnotation(annotationId, patchAnnotationsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
         * @summary Create Annotation.
         * @param {PostAnnotationsCmd} postAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnnotation(postAnnotationsCmd: PostAnnotationsCmd, options?: RawAxiosRequestConfig): AxiosPromise<PostAnnotation200Response> {
            return localVarFp.postAnnotation(postAnnotationsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
         * @summary Create Annotation in Graphite format.
         * @param {PostGraphiteAnnotationsCmd} postGraphiteAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraphiteAnnotation(postGraphiteAnnotationsCmd: PostGraphiteAnnotationsCmd, options?: RawAxiosRequestConfig): AxiosPromise<PostAnnotation200Response> {
            return localVarFp.postGraphiteAnnotation(postGraphiteAnnotationsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
         * @summary Update Annotation.
         * @param {string} annotationId 
         * @param {UpdateAnnotationsCmd} updateAnnotationsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotation(annotationId: string, updateAnnotationsCmd: UpdateAnnotationsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateAnnotation(annotationId, updateAnnotationsCmd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationsApi - object-oriented interface
 * @export
 * @class AnnotationsApi
 * @extends {BaseAPI}
 */
export class AnnotationsApi extends BaseAPI {
    /**
     * Deletes the annotation that matches the specified ID.
     * @summary Delete Annotation By ID.
     * @param {string} annotationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public deleteAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).deleteAnnotationByID(annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Annotation by ID.
     * @param {string} annotationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public getAnnotationByID(annotationId: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).getAnnotationByID(annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find all the event tags created in the annotations.
     * @summary Find Annotations Tags.
     * @param {string} [tag] Tag is a string that you can use to filter tags.
     * @param {string} [limit] Max limit for results returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public getAnnotationTags(tag?: string, limit?: string, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).getAnnotationTags(tag, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.
     * @summary Find Annotations.
     * @param {number} [from] Find annotations created after specific epoch datetime in milliseconds.
     * @param {number} [to] Find annotations created before specific epoch datetime in milliseconds.
     * @param {number} [userId] Limit response to annotations created by specific user.
     * @param {number} [alertId] Find annotations for a specified alert.
     * @param {number} [dashboardId] Find annotations that are scoped to a specific dashboard
     * @param {string} [dashboardUID] Find annotations that are scoped to a specific dashboard
     * @param {number} [panelId] Find annotations that are scoped to a specific panel
     * @param {number} [limit] Max limit for results returned.
     * @param {Array<string>} [tags] Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
     * @param {GetAnnotationsTypeEnum} [type] Return alerts or user created annotations
     * @param {boolean} [matchAny] Match any or all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public getAnnotations(from?: number, to?: number, userId?: number, alertId?: number, dashboardId?: number, dashboardUID?: string, panelId?: number, limit?: number, tags?: Array<string>, type?: GetAnnotationsTypeEnum, matchAny?: boolean, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).getAnnotations(from, to, userId, alertId, dashboardId, dashboardUID, panelId, limit, tags, type, matchAny, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete multiple annotations.
     * @param {MassDeleteAnnotationsCmd} massDeleteAnnotationsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public massDeleteAnnotations(massDeleteAnnotationsCmd: MassDeleteAnnotationsCmd, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).massDeleteAnnotations(massDeleteAnnotationsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.
     * @summary Patch Annotation.
     * @param {string} annotationId 
     * @param {PatchAnnotationsCmd} patchAnnotationsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public patchAnnotation(annotationId: string, patchAnnotationsCmd: PatchAnnotationsCmd, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).patchAnnotation(annotationId, patchAnnotationsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.
     * @summary Create Annotation.
     * @param {PostAnnotationsCmd} postAnnotationsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public postAnnotation(postAnnotationsCmd: PostAnnotationsCmd, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).postAnnotation(postAnnotationsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotation’s timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).
     * @summary Create Annotation in Graphite format.
     * @param {PostGraphiteAnnotationsCmd} postGraphiteAnnotationsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public postGraphiteAnnotation(postGraphiteAnnotationsCmd: PostGraphiteAnnotationsCmd, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).postGraphiteAnnotation(postGraphiteAnnotationsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.
     * @summary Update Annotation.
     * @param {string} annotationId 
     * @param {UpdateAnnotationsCmd} updateAnnotationsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationsApi
     */
    public updateAnnotation(annotationId: string, updateAnnotationsCmd: UpdateAnnotationsCmd, options?: RawAxiosRequestConfig) {
        return AnnotationsApiFp(this.configuration).updateAnnotation(annotationId, updateAnnotationsCmd, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAnnotationsTypeEnum = {
    Alert: 'alert',
    Annotation: 'annotation'
} as const;
export type GetAnnotationsTypeEnum = typeof GetAnnotationsTypeEnum[keyof typeof GetAnnotationsTypeEnum];


/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Will return details of the created API key.
         * @summary Creates an API key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addAPIkey: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Delete API key.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteAPIkey: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAPIkey', 'id', id)
            const localVarPath = `/auth/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Get auth keys.
         * @param {boolean} [includeExpired] Show expired keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIkeys: async (includeExpired?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includeExpired !== undefined) {
                localVarQueryParameter['includeExpired'] = includeExpired;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Will return details of the created API key.
         * @summary Creates an API key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addAPIkey(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAPIkey(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.addAPIkey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Delete API key.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteAPIkey(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAPIkey(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteAPIkey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Get auth keys.
         * @param {boolean} [includeExpired] Show expired keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAPIkeys(includeExpired?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKeyDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAPIkeys(includeExpired, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.getAPIkeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * Will return details of the created API key.
         * @summary Creates an API key.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addAPIkey(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addAPIkey(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Delete API key.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteAPIkey(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteAPIkey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
         * @summary Get auth keys.
         * @param {boolean} [includeExpired] Show expired keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAPIkeys(includeExpired?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKeyDTO>> {
            return localVarFp.getAPIkeys(includeExpired, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * Will return details of the created API key.
     * @summary Creates an API key.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public addAPIkey(options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).addAPIkey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an API key. Deprecated. See: https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
     * @summary Delete API key.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteAPIkey(id: number, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteAPIkey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will return auth keys.  Deprecated: true.  Deprecated. Please use GET /api/serviceaccounts and GET /api/serviceaccounts/{id}/tokens instead see https://grafana.com/docs/grafana/next/administration/service-accounts/migrate-api-keys/.
     * @summary Get auth keys.
     * @param {boolean} [includeExpired] Show expired keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getAPIkeys(includeExpired?: boolean, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).getAPIkeys(includeExpired, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CorrelationsApi - axios parameter creator
 * @export
 */
export const CorrelationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add correlation.
         * @param {string} sourceUID 
         * @param {CreateCorrelationCommand} createCorrelationCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCorrelation: async (sourceUID: string, createCorrelationCommand: CreateCorrelationCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUID' is not null or undefined
            assertParamExists('createCorrelation', 'sourceUID', sourceUID)
            // verify required parameter 'createCorrelationCommand' is not null or undefined
            assertParamExists('createCorrelation', 'createCorrelationCommand', createCorrelationCommand)
            const localVarPath = `/datasources/uid/{sourceUID}/correlations`
                .replace(`{${"sourceUID"}}`, encodeURIComponent(String(sourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCorrelationCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a correlation.
         * @param {string} uid 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCorrelation: async (uid: string, correlationUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteCorrelation', 'uid', uid)
            // verify required parameter 'correlationUID' is not null or undefined
            assertParamExists('deleteCorrelation', 'correlationUID', correlationUID)
            const localVarPath = `/datasources/uid/{uid}/correlations/{correlationUID}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"correlationUID"}}`, encodeURIComponent(String(correlationUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelation: async (sourceUID: string, correlationUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUID' is not null or undefined
            assertParamExists('getCorrelation', 'sourceUID', sourceUID)
            // verify required parameter 'correlationUID' is not null or undefined
            assertParamExists('getCorrelation', 'correlationUID', correlationUID)
            const localVarPath = `/datasources/uid/{sourceUID}/correlations/{correlationUID}`
                .replace(`{${"sourceUID"}}`, encodeURIComponent(String(sourceUID)))
                .replace(`{${"correlationUID"}}`, encodeURIComponent(String(correlationUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all correlations.
         * @param {number} [limit] Limit the maximum number of correlations to return per page
         * @param {number} [page] Page index for starting fetching correlations
         * @param {Array<string>} [sourceUID] Source datasource UID filter to be applied to correlations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations: async (limit?: number, page?: number, sourceUID?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasources/correlations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (sourceUID) {
                localVarQueryParameter['sourceUID'] = sourceUID;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all correlations originating from the given data source.
         * @param {string} sourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationsBySourceUID: async (sourceUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUID' is not null or undefined
            assertParamExists('getCorrelationsBySourceUID', 'sourceUID', sourceUID)
            const localVarPath = `/datasources/uid/{sourceUID}/correlations`
                .replace(`{${"sourceUID"}}`, encodeURIComponent(String(sourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {UpdateCorrelationCommand} [updateCorrelationCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCorrelation: async (sourceUID: string, correlationUID: string, updateCorrelationCommand?: UpdateCorrelationCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUID' is not null or undefined
            assertParamExists('updateCorrelation', 'sourceUID', sourceUID)
            // verify required parameter 'correlationUID' is not null or undefined
            assertParamExists('updateCorrelation', 'correlationUID', correlationUID)
            const localVarPath = `/datasources/uid/{sourceUID}/correlations/{correlationUID}`
                .replace(`{${"sourceUID"}}`, encodeURIComponent(String(sourceUID)))
                .replace(`{${"correlationUID"}}`, encodeURIComponent(String(correlationUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCorrelationCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorrelationsApi - functional programming interface
 * @export
 */
export const CorrelationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CorrelationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add correlation.
         * @param {string} sourceUID 
         * @param {CreateCorrelationCommand} createCorrelationCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCorrelation(sourceUID: string, createCorrelationCommand: CreateCorrelationCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCorrelationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCorrelation(sourceUID, createCorrelationCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.createCorrelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a correlation.
         * @param {string} uid 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCorrelation(uid: string, correlationUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCorrelationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCorrelation(uid, correlationUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.deleteCorrelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorrelation(sourceUID: string, correlationUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Correlation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorrelation(sourceUID, correlationUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.getCorrelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all correlations.
         * @param {number} [limit] Limit the maximum number of correlations to return per page
         * @param {number} [page] Page index for starting fetching correlations
         * @param {Array<string>} [sourceUID] Source datasource UID filter to be applied to correlations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorrelations(limit?: number, page?: number, sourceUID?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Correlation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorrelations(limit, page, sourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.getCorrelations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all correlations originating from the given data source.
         * @param {string} sourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorrelationsBySourceUID(sourceUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Correlation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorrelationsBySourceUID(sourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.getCorrelationsBySourceUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {UpdateCorrelationCommand} [updateCorrelationCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCorrelation(sourceUID: string, correlationUID: string, updateCorrelationCommand?: UpdateCorrelationCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCorrelationResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCorrelation(sourceUID, correlationUID, updateCorrelationCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrelationsApi.updateCorrelation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CorrelationsApi - factory interface
 * @export
 */
export const CorrelationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CorrelationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add correlation.
         * @param {string} sourceUID 
         * @param {CreateCorrelationCommand} createCorrelationCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCorrelation(sourceUID: string, createCorrelationCommand: CreateCorrelationCommand, options?: RawAxiosRequestConfig): AxiosPromise<CreateCorrelationResponseBody> {
            return localVarFp.createCorrelation(sourceUID, createCorrelationCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a correlation.
         * @param {string} uid 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCorrelation(uid: string, correlationUID: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteCorrelationResponseBody> {
            return localVarFp.deleteCorrelation(uid, correlationUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelation(sourceUID: string, correlationUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Correlation> {
            return localVarFp.getCorrelation(sourceUID, correlationUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all correlations.
         * @param {number} [limit] Limit the maximum number of correlations to return per page
         * @param {number} [page] Page index for starting fetching correlations
         * @param {Array<string>} [sourceUID] Source datasource UID filter to be applied to correlations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(limit?: number, page?: number, sourceUID?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Correlation>> {
            return localVarFp.getCorrelations(limit, page, sourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all correlations originating from the given data source.
         * @param {string} sourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationsBySourceUID(sourceUID: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Correlation>> {
            return localVarFp.getCorrelationsBySourceUID(sourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a correlation.
         * @param {string} sourceUID 
         * @param {string} correlationUID 
         * @param {UpdateCorrelationCommand} [updateCorrelationCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCorrelation(sourceUID: string, correlationUID: string, updateCorrelationCommand?: UpdateCorrelationCommand, options?: RawAxiosRequestConfig): AxiosPromise<UpdateCorrelationResponseBody> {
            return localVarFp.updateCorrelation(sourceUID, correlationUID, updateCorrelationCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CorrelationsApi - object-oriented interface
 * @export
 * @class CorrelationsApi
 * @extends {BaseAPI}
 */
export class CorrelationsApi extends BaseAPI {
    /**
     * 
     * @summary Add correlation.
     * @param {string} sourceUID 
     * @param {CreateCorrelationCommand} createCorrelationCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public createCorrelation(sourceUID: string, createCorrelationCommand: CreateCorrelationCommand, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).createCorrelation(sourceUID, createCorrelationCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a correlation.
     * @param {string} uid 
     * @param {string} correlationUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public deleteCorrelation(uid: string, correlationUID: string, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).deleteCorrelation(uid, correlationUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a correlation.
     * @param {string} sourceUID 
     * @param {string} correlationUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public getCorrelation(sourceUID: string, correlationUID: string, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).getCorrelation(sourceUID, correlationUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all correlations.
     * @param {number} [limit] Limit the maximum number of correlations to return per page
     * @param {number} [page] Page index for starting fetching correlations
     * @param {Array<string>} [sourceUID] Source datasource UID filter to be applied to correlations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public getCorrelations(limit?: number, page?: number, sourceUID?: Array<string>, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).getCorrelations(limit, page, sourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all correlations originating from the given data source.
     * @param {string} sourceUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public getCorrelationsBySourceUID(sourceUID: string, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).getCorrelationsBySourceUID(sourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a correlation.
     * @param {string} sourceUID 
     * @param {string} correlationUID 
     * @param {UpdateCorrelationCommand} [updateCorrelationCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrelationsApi
     */
    public updateCorrelation(sourceUID: string, correlationUID: string, updateCorrelationCommand?: UpdateCorrelationCommand, options?: RawAxiosRequestConfig) {
        return CorrelationsApiFp(this.configuration).updateCorrelation(sourceUID, correlationUID, updateCorrelationCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardPermissionsApi - axios parameter creator
 * @export
 */
export const DashboardPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
         * @summary Gets all existing permissions for the given dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardPermissionsListByID: async (dashboardID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardID' is not null or undefined
            assertParamExists('getDashboardPermissionsListByID', 'dashboardID', dashboardID)
            const localVarPath = `/dashboards/id/{DashboardID}/permissions`
                .replace(`{${"DashboardID"}}`, encodeURIComponent(String(dashboardID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all existing permissions for the given dashboard.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardPermissionsListByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDashboardPermissionsListByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}/permissions`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {number} dashboardID 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateDashboardPermissionsByID: async (dashboardID: number, updateDashboardACLCommand: UpdateDashboardACLCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardID' is not null or undefined
            assertParamExists('updateDashboardPermissionsByID', 'dashboardID', dashboardID)
            // verify required parameter 'updateDashboardACLCommand' is not null or undefined
            assertParamExists('updateDashboardPermissionsByID', 'updateDashboardACLCommand', updateDashboardACLCommand)
            const localVarPath = `/dashboards/id/{DashboardID}/permissions`
                .replace(`{${"DashboardID"}}`, encodeURIComponent(String(dashboardID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDashboardACLCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {string} uid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardPermissionsByUID: async (uid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDashboardPermissionsByUID', 'uid', uid)
            // verify required parameter 'updateDashboardACLCommand' is not null or undefined
            assertParamExists('updateDashboardPermissionsByUID', 'updateDashboardACLCommand', updateDashboardACLCommand)
            const localVarPath = `/dashboards/uid/{uid}/permissions`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDashboardACLCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardPermissionsApi - functional programming interface
 * @export
 */
export const DashboardPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
         * @summary Gets all existing permissions for the given dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDashboardPermissionsListByID(dashboardID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardACLInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardPermissionsListByID(dashboardID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPermissionsApi.getDashboardPermissionsListByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all existing permissions for the given dashboard.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardPermissionsListByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardACLInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardPermissionsListByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPermissionsApi.getDashboardPermissionsListByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {number} dashboardID 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateDashboardPermissionsByID(dashboardID: number, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboardPermissionsByID(dashboardID, updateDashboardACLCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPermissionsApi.updateDashboardPermissionsByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {string} uid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDashboardPermissionsByUID(uid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDashboardPermissionsByUID(uid, updateDashboardACLCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPermissionsApi.updateDashboardPermissionsByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardPermissionsApi - factory interface
 * @export
 */
export const DashboardPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardPermissionsApiFp(configuration)
    return {
        /**
         * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
         * @summary Gets all existing permissions for the given dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardPermissionsListByID(dashboardID: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardACLInfoDTO>> {
            return localVarFp.getDashboardPermissionsListByID(dashboardID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all existing permissions for the given dashboard.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardPermissionsListByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardACLInfoDTO>> {
            return localVarFp.getDashboardPermissionsListByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {number} dashboardID 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateDashboardPermissionsByID(dashboardID: number, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateDashboardPermissionsByID(dashboardID, updateDashboardACLCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation will remove existing permissions if they’re not included in the request.
         * @summary Updates permissions for a dashboard.
         * @param {string} uid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardPermissionsByUID(uid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateDashboardPermissionsByUID(uid, updateDashboardACLCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardPermissionsApi - object-oriented interface
 * @export
 * @class DashboardPermissionsApi
 * @extends {BaseAPI}
 */
export class DashboardPermissionsApi extends BaseAPI {
    /**
     * Please refer to [updated API](#/dashboard_permissions/getDashboardPermissionsListByUID) instead
     * @summary Gets all existing permissions for the given dashboard.
     * @param {number} dashboardID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DashboardPermissionsApi
     */
    public getDashboardPermissionsListByID(dashboardID: number, options?: RawAxiosRequestConfig) {
        return DashboardPermissionsApiFp(this.configuration).getDashboardPermissionsListByID(dashboardID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all existing permissions for the given dashboard.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPermissionsApi
     */
    public getDashboardPermissionsListByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DashboardPermissionsApiFp(this.configuration).getDashboardPermissionsListByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please refer to [updated API](#/dashboard_permissions/updateDashboardPermissionsByUID) instead  This operation will remove existing permissions if they’re not included in the request.
     * @summary Updates permissions for a dashboard.
     * @param {number} dashboardID 
     * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DashboardPermissionsApi
     */
    public updateDashboardPermissionsByID(dashboardID: number, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig) {
        return DashboardPermissionsApiFp(this.configuration).updateDashboardPermissionsByID(dashboardID, updateDashboardACLCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation will remove existing permissions if they’re not included in the request.
     * @summary Updates permissions for a dashboard.
     * @param {string} uid 
     * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPermissionsApi
     */
    public updateDashboardPermissionsByUID(uid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig) {
        return DashboardPermissionsApiFp(this.configuration).updateDashboardPermissionsByUID(uid, updateDashboardACLCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardPublicApi - axios parameter creator
 * @export
 */
export const DashboardPublicApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicDashboard: async (dashboardUid: string, publicDashboardDTO: PublicDashboardDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('createPublicDashboard', 'dashboardUid', dashboardUid)
            // verify required parameter 'publicDashboardDTO' is not null or undefined
            assertParamExists('createPublicDashboard', 'publicDashboardDTO', publicDashboardDTO)
            const localVarPath = `/dashboards/uid/{dashboardUid}/public-dashboards`
                .replace(`{${"dashboardUid"}}`, encodeURIComponent(String(dashboardUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicDashboardDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicDashboard: async (dashboardUid: string, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('deletePublicDashboard', 'dashboardUid', dashboardUid)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deletePublicDashboard', 'uid', uid)
            const localVarPath = `/dashboards/uid/{dashboardUid}/public-dashboards/{uid}`
                .replace(`{${"dashboardUid"}}`, encodeURIComponent(String(dashboardUid)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get annotations for a public dashboard
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicAnnotations: async (accessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('getPublicAnnotations', 'accessToken', accessToken)
            const localVarPath = `/public/dashboards/{accessToken}/annotations`
                .replace(`{${"accessToken"}}`, encodeURIComponent(String(accessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public dashboard by dashboardUid
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicDashboard: async (dashboardUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('getPublicDashboard', 'dashboardUid', dashboardUid)
            const localVarPath = `/dashboards/uid/{dashboardUid}/public-dashboards`
                .replace(`{${"dashboardUid"}}`, encodeURIComponent(String(dashboardUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of public dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicDashboards: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboards/public-dashboards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get results for a given panel on a public dashboard
         * @param {string} accessToken 
         * @param {number} panelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPublicDashboard: async (accessToken: string, panelId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('queryPublicDashboard', 'accessToken', accessToken)
            // verify required parameter 'panelId' is not null or undefined
            assertParamExists('queryPublicDashboard', 'panelId', panelId)
            const localVarPath = `/public/dashboards/{accessToken}/panels/{panelId}/query`
                .replace(`{${"accessToken"}}`, encodeURIComponent(String(accessToken)))
                .replace(`{${"panelId"}}`, encodeURIComponent(String(panelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicDashboard: async (dashboardUid: string, uid: string, publicDashboardDTO: PublicDashboardDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('updatePublicDashboard', 'dashboardUid', dashboardUid)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updatePublicDashboard', 'uid', uid)
            // verify required parameter 'publicDashboardDTO' is not null or undefined
            assertParamExists('updatePublicDashboard', 'publicDashboardDTO', publicDashboardDTO)
            const localVarPath = `/dashboards/uid/{dashboardUid}/public-dashboards/{uid}`
                .replace(`{${"dashboardUid"}}`, encodeURIComponent(String(dashboardUid)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicDashboardDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get public dashboard for view
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPublicDashboard: async (accessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('viewPublicDashboard', 'accessToken', accessToken)
            const localVarPath = `/public/dashboards/{accessToken}`
                .replace(`{${"accessToken"}}`, encodeURIComponent(String(accessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardPublicApi - functional programming interface
 * @export
 */
export const DashboardPublicApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardPublicApiAxiosParamCreator(configuration)
    return {
        /**
         * Create public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPublicDashboard(dashboardUid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicDashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPublicDashboard(dashboardUid, publicDashboardDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.createPublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePublicDashboard(dashboardUid: string, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePublicDashboard(dashboardUid, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.deletePublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get annotations for a public dashboard
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicAnnotations(accessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicAnnotations(accessToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.getPublicAnnotations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public dashboard by dashboardUid
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicDashboard(dashboardUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicDashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicDashboard(dashboardUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.getPublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of public dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPublicDashboards(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicDashboardListResponseWithPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPublicDashboards(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.listPublicDashboards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get results for a given panel on a public dashboard
         * @param {string} accessToken 
         * @param {number} panelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryPublicDashboard(accessToken: string, panelId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryPublicDashboard(accessToken, panelId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.queryPublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePublicDashboard(dashboardUid: string, uid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicDashboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePublicDashboard(dashboardUid, uid, publicDashboardDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.updatePublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get public dashboard for view
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewPublicDashboard(accessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFullWithMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewPublicDashboard(accessToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardPublicApi.viewPublicDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardPublicApi - factory interface
 * @export
 */
export const DashboardPublicApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardPublicApiFp(configuration)
    return {
        /**
         * Create public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPublicDashboard(dashboardUid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig): AxiosPromise<PublicDashboard> {
            return localVarFp.createPublicDashboard(dashboardUid, publicDashboardDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePublicDashboard(dashboardUid: string, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deletePublicDashboard(dashboardUid, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get annotations for a public dashboard
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicAnnotations(accessToken: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnnotationEvent>> {
            return localVarFp.getPublicAnnotations(accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public dashboard by dashboardUid
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicDashboard(dashboardUid: string, options?: RawAxiosRequestConfig): AxiosPromise<PublicDashboard> {
            return localVarFp.getPublicDashboard(dashboardUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of public dashboards
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPublicDashboards(options?: RawAxiosRequestConfig): AxiosPromise<PublicDashboardListResponseWithPagination> {
            return localVarFp.listPublicDashboards(options).then((request) => request(axios, basePath));
        },
        /**
         * Get results for a given panel on a public dashboard
         * @param {string} accessToken 
         * @param {number} panelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryPublicDashboard(accessToken: string, panelId: number, options?: RawAxiosRequestConfig): AxiosPromise<QueryDataResponse> {
            return localVarFp.queryPublicDashboard(accessToken, panelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update public dashboard for a dashboard
         * @param {string} dashboardUid 
         * @param {string} uid 
         * @param {PublicDashboardDTO} publicDashboardDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePublicDashboard(dashboardUid: string, uid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig): AxiosPromise<PublicDashboard> {
            return localVarFp.updatePublicDashboard(dashboardUid, uid, publicDashboardDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get public dashboard for view
         * @param {string} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewPublicDashboard(accessToken: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFullWithMeta> {
            return localVarFp.viewPublicDashboard(accessToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardPublicApi - object-oriented interface
 * @export
 * @class DashboardPublicApi
 * @extends {BaseAPI}
 */
export class DashboardPublicApi extends BaseAPI {
    /**
     * Create public dashboard for a dashboard
     * @param {string} dashboardUid 
     * @param {PublicDashboardDTO} publicDashboardDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public createPublicDashboard(dashboardUid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).createPublicDashboard(dashboardUid, publicDashboardDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete public dashboard for a dashboard
     * @param {string} dashboardUid 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public deletePublicDashboard(dashboardUid: string, uid: string, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).deletePublicDashboard(dashboardUid, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get annotations for a public dashboard
     * @param {string} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public getPublicAnnotations(accessToken: string, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).getPublicAnnotations(accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public dashboard by dashboardUid
     * @param {string} dashboardUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public getPublicDashboard(dashboardUid: string, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).getPublicDashboard(dashboardUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of public dashboards
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public listPublicDashboards(options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).listPublicDashboards(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get results for a given panel on a public dashboard
     * @param {string} accessToken 
     * @param {number} panelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public queryPublicDashboard(accessToken: string, panelId: number, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).queryPublicDashboard(accessToken, panelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update public dashboard for a dashboard
     * @param {string} dashboardUid 
     * @param {string} uid 
     * @param {PublicDashboardDTO} publicDashboardDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public updatePublicDashboard(dashboardUid: string, uid: string, publicDashboardDTO: PublicDashboardDTO, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).updatePublicDashboard(dashboardUid, uid, publicDashboardDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get public dashboard for view
     * @param {string} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardPublicApi
     */
    public viewPublicDashboard(accessToken: string, options?: RawAxiosRequestConfig) {
        return DashboardPublicApiFp(this.configuration).viewPublicDashboard(accessToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardVersionsApi - axios parameter creator
 * @export
 */
export const DashboardVersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
         * @summary Get a specific dashboard version.
         * @param {number} dashboardID 
         * @param {number} dashboardVersionID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardVersionByID: async (dashboardID: number, dashboardVersionID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardID' is not null or undefined
            assertParamExists('getDashboardVersionByID', 'dashboardID', dashboardID)
            // verify required parameter 'dashboardVersionID' is not null or undefined
            assertParamExists('getDashboardVersionByID', 'dashboardVersionID', dashboardVersionID)
            const localVarPath = `/dashboards/id/{DashboardID}/versions/{DashboardVersionID}`
                .replace(`{${"DashboardID"}}`, encodeURIComponent(String(dashboardID)))
                .replace(`{${"DashboardVersionID"}}`, encodeURIComponent(String(dashboardVersionID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific dashboard version using UID.
         * @param {number} dashboardVersionID 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardVersionByUID: async (dashboardVersionID: number, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardVersionID' is not null or undefined
            assertParamExists('getDashboardVersionByUID', 'dashboardVersionID', dashboardVersionID)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDashboardVersionByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}/versions/{DashboardVersionID}`
                .replace(`{${"DashboardVersionID"}}`, encodeURIComponent(String(dashboardVersionID)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
         * @summary Gets all existing versions for the dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardVersionsByID: async (dashboardID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardID' is not null or undefined
            assertParamExists('getDashboardVersionsByID', 'dashboardID', dashboardID)
            const localVarPath = `/dashboards/id/{DashboardID}/versions`
                .replace(`{${"DashboardID"}}`, encodeURIComponent(String(dashboardID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all existing versions for the dashboard using UID.
         * @param {string} uid 
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [start] Version to start from when returning queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardVersionsByUID: async (uid: string, limit?: number, start?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDashboardVersionsByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}/versions`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
         * @summary Restore a dashboard to a given dashboard version.
         * @param {number} dashboardID 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        restoreDashboardVersionByID: async (dashboardID: number, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardID' is not null or undefined
            assertParamExists('restoreDashboardVersionByID', 'dashboardID', dashboardID)
            // verify required parameter 'restoreDashboardVersionCommand' is not null or undefined
            assertParamExists('restoreDashboardVersionByID', 'restoreDashboardVersionCommand', restoreDashboardVersionCommand)
            const localVarPath = `/dashboards/id/{DashboardID}/restore`
                .replace(`{${"DashboardID"}}`, encodeURIComponent(String(dashboardID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreDashboardVersionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDashboardVersionByUID: async (uid: string, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('restoreDashboardVersionByUID', 'uid', uid)
            // verify required parameter 'restoreDashboardVersionCommand' is not null or undefined
            assertParamExists('restoreDashboardVersionByUID', 'restoreDashboardVersionCommand', restoreDashboardVersionCommand)
            const localVarPath = `/dashboards/uid/{uid}/restore`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreDashboardVersionCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardVersionsApi - functional programming interface
 * @export
 */
export const DashboardVersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardVersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
         * @summary Get a specific dashboard version.
         * @param {number} dashboardID 
         * @param {number} dashboardVersionID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDashboardVersionByID(dashboardID: number, dashboardVersionID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardVersionMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardVersionByID(dashboardID, dashboardVersionID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.getDashboardVersionByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific dashboard version using UID.
         * @param {number} dashboardVersionID 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardVersionByUID(dashboardVersionID: number, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardVersionMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardVersionByUID(dashboardVersionID, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.getDashboardVersionByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
         * @summary Gets all existing versions for the dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDashboardVersionsByID(dashboardID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardVersionMeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardVersionsByID(dashboardID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.getDashboardVersionsByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets all existing versions for the dashboard using UID.
         * @param {string} uid 
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [start] Version to start from when returning queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardVersionsByUID(uid: string, limit?: number, start?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardVersionMeta>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardVersionsByUID(uid, limit, start, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.getDashboardVersionsByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
         * @summary Restore a dashboard to a given dashboard version.
         * @param {number} dashboardID 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async restoreDashboardVersionByID(dashboardID: number, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDashboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDashboardVersionByID(dashboardID, restoreDashboardVersionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.restoreDashboardVersionByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDashboardVersionByUID(uid: string, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDashboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDashboardVersionByUID(uid, restoreDashboardVersionCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardVersionsApi.restoreDashboardVersionByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardVersionsApi - factory interface
 * @export
 */
export const DashboardVersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardVersionsApiFp(configuration)
    return {
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
         * @summary Get a specific dashboard version.
         * @param {number} dashboardID 
         * @param {number} dashboardVersionID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardVersionByID(dashboardID: number, dashboardVersionID: number, options?: RawAxiosRequestConfig): AxiosPromise<DashboardVersionMeta> {
            return localVarFp.getDashboardVersionByID(dashboardID, dashboardVersionID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific dashboard version using UID.
         * @param {number} dashboardVersionID 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardVersionByUID(dashboardVersionID: number, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardVersionMeta> {
            return localVarFp.getDashboardVersionByUID(dashboardVersionID, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
         * @summary Gets all existing versions for the dashboard.
         * @param {number} dashboardID 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDashboardVersionsByID(dashboardID: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardVersionMeta>> {
            return localVarFp.getDashboardVersionsByID(dashboardID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all existing versions for the dashboard using UID.
         * @param {string} uid 
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [start] Version to start from when returning queries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardVersionsByUID(uid: string, limit?: number, start?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardVersionMeta>> {
            return localVarFp.getDashboardVersionsByUID(uid, limit, start, options).then((request) => request(axios, basePath));
        },
        /**
         * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
         * @summary Restore a dashboard to a given dashboard version.
         * @param {number} dashboardID 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        restoreDashboardVersionByID(dashboardID: number, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig): AxiosPromise<PostDashboard200Response> {
            return localVarFp.restoreDashboardVersionByID(dashboardID, restoreDashboardVersionCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDashboardVersionByUID(uid: string, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig): AxiosPromise<PostDashboard200Response> {
            return localVarFp.restoreDashboardVersionByUID(uid, restoreDashboardVersionCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardVersionsApi - object-oriented interface
 * @export
 * @class DashboardVersionsApi
 * @extends {BaseAPI}
 */
export class DashboardVersionsApi extends BaseAPI {
    /**
     * Please refer to [updated API](#/dashboard_versions/getDashboardVersionByUID) instead
     * @summary Get a specific dashboard version.
     * @param {number} dashboardID 
     * @param {number} dashboardVersionID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public getDashboardVersionByID(dashboardID: number, dashboardVersionID: number, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).getDashboardVersionByID(dashboardID, dashboardVersionID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific dashboard version using UID.
     * @param {number} dashboardVersionID 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public getDashboardVersionByUID(dashboardVersionID: number, uid: string, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).getDashboardVersionByUID(dashboardVersionID, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please refer to [updated API](#/dashboard_versions/getDashboardVersionsByUID) instead
     * @summary Gets all existing versions for the dashboard.
     * @param {number} dashboardID 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public getDashboardVersionsByID(dashboardID: number, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).getDashboardVersionsByID(dashboardID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all existing versions for the dashboard using UID.
     * @param {string} uid 
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [start] Version to start from when returning queries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public getDashboardVersionsByUID(uid: string, limit?: number, start?: number, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).getDashboardVersionsByUID(uid, limit, start, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please refer to [updated API](#/dashboard_versions/restoreDashboardVersionByUID) instead
     * @summary Restore a dashboard to a given dashboard version.
     * @param {number} dashboardID 
     * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public restoreDashboardVersionByID(dashboardID: number, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).restoreDashboardVersionByID(dashboardID, restoreDashboardVersionCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a dashboard to a given dashboard version using UID.
     * @param {string} uid 
     * @param {RestoreDashboardVersionCommand} restoreDashboardVersionCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardVersionsApi
     */
    public restoreDashboardVersionByUID(uid: string, restoreDashboardVersionCommand: RestoreDashboardVersionCommand, options?: RawAxiosRequestConfig) {
        return DashboardVersionsApiFp(this.configuration).restoreDashboardVersionByUID(uid, restoreDashboardVersionCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardsApi - axios parameter creator
 * @export
 */
export const DashboardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Perform diff on two dashboards.
         * @param {CalculateDashboardDiffRequest} calculateDashboardDiffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateDashboardDiff: async (calculateDashboardDiffRequest: CalculateDashboardDiffRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'calculateDashboardDiffRequest' is not null or undefined
            assertParamExists('calculateDashboardDiff', 'calculateDashboardDiffRequest', calculateDashboardDiffRequest)
            const localVarPath = `/dashboards/calculate-diff`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculateDashboardDiffRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDashboardByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return the dashboard given the dashboard unique identifier (uid).
         * @summary Get dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDashboardByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all dashboards tags of an organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardTags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboards/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get home dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeDashboard: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboards/home`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Hard delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hardDeleteDashboardByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('hardDeleteDashboardByUID', 'uid', uid)
            const localVarPath = `/dashboards/uid/{uid}/trash`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import dashboard.
         * @param {ImportDashboardRequest} importDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDashboard: async (importDashboardRequest: ImportDashboardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importDashboardRequest' is not null or undefined
            assertParamExists('importDashboard', 'importDashboardRequest', importDashboardRequest)
            const localVarPath = `/dashboards/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importDashboardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
         * @summary Create / Update dashboard
         * @param {SaveDashboardCommand} saveDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboard: async (saveDashboardCommand: SaveDashboardCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveDashboardCommand' is not null or undefined
            assertParamExists('postDashboard', 'saveDashboardCommand', saveDashboardCommand)
            const localVarPath = `/dashboards/db`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveDashboardCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDeletedDashboardCommand} restoreDeletedDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedDashboardByUID: async (uid: string, restoreDeletedDashboardCommand: RestoreDeletedDashboardCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('restoreDeletedDashboardByUID', 'uid', uid)
            // verify required parameter 'restoreDeletedDashboardCommand' is not null or undefined
            assertParamExists('restoreDeletedDashboardByUID', 'restoreDeletedDashboardCommand', restoreDeletedDashboardCommand)
            const localVarPath = `/dashboards/uid/{uid}/trash`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreDeletedDashboardCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardsApi - functional programming interface
 * @export
 */
export const DashboardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Perform diff on two dashboards.
         * @param {CalculateDashboardDiffRequest} calculateDashboardDiffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateDashboardDiff(calculateDashboardDiffRequest: CalculateDashboardDiffRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateDashboardDiff(calculateDashboardDiffRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.calculateDashboardDiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDashboardByUID200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboardByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.deleteDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Will return the dashboard given the dashboard unique identifier (uid).
         * @summary Get dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardFullWithMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.getDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all dashboards tags of an organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardTags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardTagCloudItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardTags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.getDashboardTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get home dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeDashboard(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHomeDashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeDashboard(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.getHomeDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Hard delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hardDeleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDashboardByUID200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hardDeleteDashboardByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.hardDeleteDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import dashboard.
         * @param {ImportDashboardRequest} importDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importDashboard(importDashboardRequest: ImportDashboardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportDashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importDashboard(importDashboardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.importDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
         * @summary Create / Update dashboard
         * @param {SaveDashboardCommand} saveDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDashboard(saveDashboardCommand: SaveDashboardCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDashboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDashboard(saveDashboardCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.postDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDeletedDashboardCommand} restoreDeletedDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedDashboardByUID(uid: string, restoreDeletedDashboardCommand: RestoreDeletedDashboardCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostDashboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedDashboardByUID(uid, restoreDeletedDashboardCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardsApi.restoreDeletedDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardsApi - factory interface
 * @export
 */
export const DashboardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Perform diff on two dashboards.
         * @param {CalculateDashboardDiffRequest} calculateDashboardDiffRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateDashboardDiff(calculateDashboardDiffRequest: CalculateDashboardDiffRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.calculateDashboardDiff(calculateDashboardDiffRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteDashboardByUID200Response> {
            return localVarFp.deleteDashboardByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Will return the dashboard given the dashboard unique identifier (uid).
         * @summary Get dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<DashboardFullWithMeta> {
            return localVarFp.getDashboardByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all dashboards tags of an organisation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardTags(options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardTagCloudItem>> {
            return localVarFp.getDashboardTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get home dashboard.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeDashboard(options?: RawAxiosRequestConfig): AxiosPromise<GetHomeDashboardResponse> {
            return localVarFp.getHomeDashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * Will delete the dashboard given the specified unique identifier (uid).
         * @summary Hard delete dashboard by uid.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hardDeleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteDashboardByUID200Response> {
            return localVarFp.hardDeleteDashboardByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import dashboard.
         * @param {ImportDashboardRequest} importDashboardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDashboard(importDashboardRequest: ImportDashboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<ImportDashboardResponse> {
            return localVarFp.importDashboard(importDashboardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
         * @summary Create / Update dashboard
         * @param {SaveDashboardCommand} saveDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDashboard(saveDashboardCommand: SaveDashboardCommand, options?: RawAxiosRequestConfig): AxiosPromise<PostDashboard200Response> {
            return localVarFp.postDashboard(saveDashboardCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a dashboard to a given dashboard version using UID.
         * @param {string} uid 
         * @param {RestoreDeletedDashboardCommand} restoreDeletedDashboardCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedDashboardByUID(uid: string, restoreDeletedDashboardCommand: RestoreDeletedDashboardCommand, options?: RawAxiosRequestConfig): AxiosPromise<PostDashboard200Response> {
            return localVarFp.restoreDeletedDashboardByUID(uid, restoreDeletedDashboardCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardsApi - object-oriented interface
 * @export
 * @class DashboardsApi
 * @extends {BaseAPI}
 */
export class DashboardsApi extends BaseAPI {
    /**
     * 
     * @summary Perform diff on two dashboards.
     * @param {CalculateDashboardDiffRequest} calculateDashboardDiffRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public calculateDashboardDiff(calculateDashboardDiffRequest: CalculateDashboardDiffRequest, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).calculateDashboardDiff(calculateDashboardDiffRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will delete the dashboard given the specified unique identifier (uid).
     * @summary Delete dashboard by uid.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public deleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).deleteDashboardByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will return the dashboard given the dashboard unique identifier (uid).
     * @summary Get dashboard by uid.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).getDashboardByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all dashboards tags of an organisation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getDashboardTags(options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).getDashboardTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get home dashboard.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public getHomeDashboard(options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).getHomeDashboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Will delete the dashboard given the specified unique identifier (uid).
     * @summary Hard delete dashboard by uid.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public hardDeleteDashboardByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).hardDeleteDashboardByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import dashboard.
     * @param {ImportDashboardRequest} importDashboardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public importDashboard(importDashboardRequest: ImportDashboardRequest, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).importDashboard(importDashboardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new dashboard or updates an existing dashboard. Note: This endpoint is not intended for creating folders, use `POST /api/folders` for that.
     * @summary Create / Update dashboard
     * @param {SaveDashboardCommand} saveDashboardCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public postDashboard(saveDashboardCommand: SaveDashboardCommand, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).postDashboard(saveDashboardCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a dashboard to a given dashboard version using UID.
     * @param {string} uid 
     * @param {RestoreDeletedDashboardCommand} restoreDeletedDashboardCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardsApi
     */
    public restoreDeletedDashboardByUID(uid: string, restoreDeletedDashboardCommand: RestoreDeletedDashboardCommand, options?: RawAxiosRequestConfig) {
        return DashboardsApiFp(this.configuration).restoreDeletedDashboardByUID(uid, restoreDeletedDashboardCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasourcesApi - axios parameter creator
 * @export
 */
export const DatasourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
         * @summary Create a data source.
         * @param {AddDataSourceCommand} addDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDataSource: async (addDataSourceCommand: AddDataSourceCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addDataSourceCommand' is not null or undefined
            assertParamExists('addDataSource', 'addDataSourceCommand', addDataSourceCommand)
            const localVarPath = `/datasources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addDataSourceCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
         * @summary Fetch data source resources by Id.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        callDatasourceResourceByID: async (datasourceProxyRoute: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('callDatasourceResourceByID', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('callDatasourceResourceByID', 'id', id)
            const localVarPath = `/datasources/{id}/resources/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch data source resources.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callDatasourceResourceWithUID: async (datasourceProxyRoute: string, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('callDatasourceResourceWithUID', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('callDatasourceResourceWithUID', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}/resources/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
         * @summary Sends a health check request to the plugin datasource identified by the ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        checkDatasourceHealthByID: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkDatasourceHealthByID', 'id', id)
            const localVarPath = `/datasources/{id}/health`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends a health check request to the plugin datasource identified by the UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatasourceHealthWithUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('checkDatasourceHealthWithUID', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}/health`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy DELETE calls.
         * @param {string} uid 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyDELETEByUIDcalls: async (uid: string, datasourceProxyRoute: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('datasourceProxyDELETEByUIDcalls', 'uid', uid)
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyDELETEByUIDcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            const localVarPath = `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
         * @summary Data source proxy DELETE calls.
         * @param {string} id 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyDELETEcalls: async (id: string, datasourceProxyRoute: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasourceProxyDELETEcalls', 'id', id)
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyDELETEcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            const localVarPath = `/datasources/proxy/{id}/{datasource_proxy_route}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyGETByUIDcalls: async (datasourceProxyRoute: string, uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyGETByUIDcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('datasourceProxyGETByUIDcalls', 'uid', uid)
            const localVarPath = `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyGETcalls: async (datasourceProxyRoute: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyGETcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasourceProxyGETcalls', 'id', id)
            const localVarPath = `/datasources/proxy/{id}/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyPOSTByUIDcalls: async (datasourceProxyRoute: string, uid: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyPOSTByUIDcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('datasourceProxyPOSTByUIDcalls', 'uid', uid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('datasourceProxyPOSTByUIDcalls', 'body', body)
            const localVarPath = `/datasources/proxy/uid/{uid}/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyPOSTcalls: async (datasourceProxyRoute: string, id: string, body: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasourceProxyRoute' is not null or undefined
            assertParamExists('datasourceProxyPOSTcalls', 'datasourceProxyRoute', datasourceProxyRoute)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('datasourceProxyPOSTcalls', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('datasourceProxyPOSTcalls', 'body', body)
            const localVarPath = `/datasources/proxy/{id}/{datasource_proxy_route}`
                .replace(`{${"datasource_proxy_route"}}`, encodeURIComponent(String(datasourceProxyRoute)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
         * @summary Delete an existing data source by id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteDataSourceByID: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDataSourceByID', 'id', id)
            const localVarPath = `/datasources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Delete an existing data source by name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataSourceByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('deleteDataSourceByName', 'name', name)
            const localVarPath = `/datasources/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Delete an existing data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataSourceByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteDataSourceByUID', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
         * @summary Get a single data source by Id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDataSourceByID: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDataSourceByID', 'id', id)
            const localVarPath = `/datasources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get a single data source by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDataSourceByName', 'name', name)
            const localVarPath = `/datasources/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Get a single data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceByUID: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getDataSourceByUID', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get data source Id by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceIdByName: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getDataSourceIdByName', 'name', name)
            const localVarPath = `/datasources/id/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
         * @summary Get all data sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSources: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/datasources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
         * @summary Update an existing data source by its sequential ID.
         * @param {string} id 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateDataSourceByID: async (id: string, updateDataSourceCommand: UpdateDataSourceCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDataSourceByID', 'id', id)
            // verify required parameter 'updateDataSourceCommand' is not null or undefined
            assertParamExists('updateDataSourceByID', 'updateDataSourceCommand', updateDataSourceCommand)
            const localVarPath = `/datasources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataSourceCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
         * @summary Update an existing data source.
         * @param {string} uid 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataSourceByUID: async (uid: string, updateDataSourceCommand: UpdateDataSourceCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateDataSourceByUID', 'uid', uid)
            // verify required parameter 'updateDataSourceCommand' is not null or undefined
            assertParamExists('updateDataSourceByUID', 'updateDataSourceCommand', updateDataSourceCommand)
            const localVarPath = `/datasources/uid/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataSourceCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasourcesApi - functional programming interface
 * @export
 */
export const DatasourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
         * @summary Create a data source.
         * @param {AddDataSourceCommand} addDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDataSource(addDataSourceCommand: AddDataSourceCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddDataSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDataSource(addDataSourceCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.addDataSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
         * @summary Fetch data source resources by Id.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async callDatasourceResourceByID(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callDatasourceResourceByID(datasourceProxyRoute, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.callDatasourceResourceByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch data source resources.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callDatasourceResourceWithUID(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callDatasourceResourceWithUID(datasourceProxyRoute, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.callDatasourceResourceWithUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
         * @summary Sends a health check request to the plugin datasource identified by the ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async checkDatasourceHealthByID(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDatasourceHealthByID(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.checkDatasourceHealthByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sends a health check request to the plugin datasource identified by the UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDatasourceHealthWithUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDatasourceHealthWithUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.checkDatasourceHealthWithUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy DELETE calls.
         * @param {string} uid 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasourceProxyDELETEByUIDcalls(uid: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyDELETEByUIDcalls(uid, datasourceProxyRoute, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyDELETEByUIDcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
         * @summary Data source proxy DELETE calls.
         * @param {string} id 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async datasourceProxyDELETEcalls(id: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyDELETEcalls(id, datasourceProxyRoute, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyDELETEcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasourceProxyGETByUIDcalls(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyGETByUIDcalls(datasourceProxyRoute, uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyGETByUIDcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async datasourceProxyGETcalls(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyGETcalls(datasourceProxyRoute, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyGETcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async datasourceProxyPOSTByUIDcalls(datasourceProxyRoute: string, uid: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyPOSTByUIDcalls(datasourceProxyRoute, uid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyPOSTByUIDcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async datasourceProxyPOSTcalls(datasourceProxyRoute: string, id: string, body: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.datasourceProxyPOSTcalls(datasourceProxyRoute, id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.datasourceProxyPOSTcalls']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
         * @summary Delete an existing data source by id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteDataSourceByID(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataSourceByID(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.deleteDataSourceByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Delete an existing data source by name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataSourceByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteDataSourceByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataSourceByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.deleteDataSourceByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Delete an existing data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataSourceByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataSourceByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.deleteDataSourceByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
         * @summary Get a single data source by Id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDataSourceByID(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceByID(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.getDataSourceByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get a single data source by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.getDataSourceByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Get a single data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceByUID(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceByUID(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.getDataSourceByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get data source Id by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceIdByName(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataSourceIdByName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceIdByName(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.getDataSourceIdByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
         * @summary Get all data sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSources(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSourceListItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSources(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.getDataSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
         * @summary Update an existing data source by its sequential ID.
         * @param {string} id 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateDataSourceByID(id: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddDataSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataSourceByID(id, updateDataSourceCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.updateDataSourceByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
         * @summary Update an existing data source.
         * @param {string} uid 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataSourceByUID(uid: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddDataSource200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataSourceByUID(uid, updateDataSourceCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasourcesApi.updateDataSourceByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasourcesApi - factory interface
 * @export
 */
export const DatasourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasourcesApiFp(configuration)
    return {
        /**
         * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
         * @summary Create a data source.
         * @param {AddDataSourceCommand} addDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDataSource(addDataSourceCommand: AddDataSourceCommand, options?: RawAxiosRequestConfig): AxiosPromise<AddDataSource200Response> {
            return localVarFp.addDataSource(addDataSourceCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
         * @summary Fetch data source resources by Id.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        callDatasourceResourceByID(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.callDatasourceResourceByID(datasourceProxyRoute, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch data source resources.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callDatasourceResourceWithUID(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.callDatasourceResourceWithUID(datasourceProxyRoute, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
         * @summary Sends a health check request to the plugin datasource identified by the ID.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        checkDatasourceHealthByID(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.checkDatasourceHealthByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends a health check request to the plugin datasource identified by the UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDatasourceHealthWithUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.checkDatasourceHealthWithUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy DELETE calls.
         * @param {string} uid 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyDELETEByUIDcalls(uid: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyDELETEByUIDcalls(uid, datasourceProxyRoute, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
         * @summary Data source proxy DELETE calls.
         * @param {string} id 
         * @param {string} datasourceProxyRoute 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyDELETEcalls(id: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyDELETEcalls(id, datasourceProxyRoute, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source.
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyGETByUIDcalls(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyGETByUIDcalls(datasourceProxyRoute, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
         * @summary Data source proxy GET calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyGETcalls(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyGETcalls(datasourceProxyRoute, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} uid 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        datasourceProxyPOSTByUIDcalls(datasourceProxyRoute: string, uid: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyPOSTByUIDcalls(datasourceProxyRoute, uid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
         * @summary Data source proxy POST calls.
         * @param {string} datasourceProxyRoute 
         * @param {string} id 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        datasourceProxyPOSTcalls(datasourceProxyRoute: string, id: string, body: any, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.datasourceProxyPOSTcalls(datasourceProxyRoute, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
         * @summary Delete an existing data source by id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteDataSourceByID(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteDataSourceByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Delete an existing data source by name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataSourceByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteDataSourceByName200Response> {
            return localVarFp.deleteDataSourceByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Delete an existing data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataSourceByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteDataSourceByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
         * @summary Get a single data source by Id.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDataSourceByID(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DataSource> {
            return localVarFp.getDataSourceByID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get a single data source by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<DataSource> {
            return localVarFp.getDataSourceByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
         * @summary Get a single data source by UID.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceByUID(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<DataSource> {
            return localVarFp.getDataSourceByUID(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
         * @summary Get data source Id by Name.
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceIdByName(name: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDataSourceIdByName200Response> {
            return localVarFp.getDataSourceIdByName(name, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
         * @summary Get all data sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSources(options?: RawAxiosRequestConfig): AxiosPromise<Array<DataSourceListItemDTO>> {
            return localVarFp.getDataSources(options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
         * @summary Update an existing data source by its sequential ID.
         * @param {string} id 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateDataSourceByID(id: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig): AxiosPromise<AddDataSource200Response> {
            return localVarFp.updateDataSourceByID(id, updateDataSourceCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
         * @summary Update an existing data source.
         * @param {string} uid 
         * @param {UpdateDataSourceCommand} updateDataSourceCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataSourceByUID(uid: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig): AxiosPromise<AddDataSource200Response> {
            return localVarFp.updateDataSourceByUID(uid, updateDataSourceCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasourcesApi - object-oriented interface
 * @export
 * @class DatasourcesApi
 * @extends {BaseAPI}
 */
export class DatasourcesApi extends BaseAPI {
    /**
     * By defining `password` and `basicAuthPassword` under secureJsonData property Grafana encrypts them securely as an encrypted blob in the database. The response then lists the encrypted fields under secureJsonFields.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:create`
     * @summary Create a data source.
     * @param {AddDataSourceCommand} addDataSourceCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public addDataSource(addDataSourceCommand: AddDataSourceCommand, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).addDataSource(addDataSourceCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please refer to [updated API](#/datasources/callDatasourceResourceWithUID) instead
     * @summary Fetch data source resources by Id.
     * @param {string} datasourceProxyRoute 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public callDatasourceResourceByID(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).callDatasourceResourceByID(datasourceProxyRoute, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch data source resources.
     * @param {string} datasourceProxyRoute 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public callDatasourceResourceWithUID(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).callDatasourceResourceWithUID(datasourceProxyRoute, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Please refer to [updated API](#/datasources/checkDatasourceHealthWithUID) instead
     * @summary Sends a health check request to the plugin datasource identified by the ID.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public checkDatasourceHealthByID(id: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).checkDatasourceHealthByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends a health check request to the plugin datasource identified by the UID.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public checkDatasourceHealthWithUID(uid: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).checkDatasourceHealthWithUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source.
     * @summary Data source proxy DELETE calls.
     * @param {string} uid 
     * @param {string} datasourceProxyRoute 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyDELETEByUIDcalls(uid: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyDELETEByUIDcalls(uid, datasourceProxyRoute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyDELETEByUIDcalls) instead
     * @summary Data source proxy DELETE calls.
     * @param {string} id 
     * @param {string} datasourceProxyRoute 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyDELETEcalls(id: string, datasourceProxyRoute: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyDELETEcalls(id, datasourceProxyRoute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source.
     * @summary Data source proxy GET calls.
     * @param {string} datasourceProxyRoute 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyGETByUIDcalls(datasourceProxyRoute: string, uid: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyGETByUIDcalls(datasourceProxyRoute, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source.  Please refer to [updated API](#/datasources/datasourceProxyGETByUIDcalls) instead
     * @summary Data source proxy GET calls.
     * @param {string} datasourceProxyRoute 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyGETcalls(datasourceProxyRoute: string, id: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyGETcalls(datasourceProxyRoute, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined
     * @summary Data source proxy POST calls.
     * @param {string} datasourceProxyRoute 
     * @param {string} uid 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyPOSTByUIDcalls(datasourceProxyRoute: string, uid: string, body: any, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyPOSTByUIDcalls(datasourceProxyRoute, uid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Proxies all calls to the actual data source. The data source should support POST methods for the specific path and role as defined  Please refer to [updated API](#/datasources/datasourceProxyPOSTByUIDcalls) instead
     * @summary Data source proxy POST calls.
     * @param {string} datasourceProxyRoute 
     * @param {string} id 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public datasourceProxyPOSTcalls(datasourceProxyRoute: string, id: string, body: any, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).datasourceProxyPOSTcalls(datasourceProxyRoute, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/deleteDataSourceByUID) instead
     * @summary Delete an existing data source by id.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public deleteDataSourceByID(id: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).deleteDataSourceByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * @summary Delete an existing data source by name.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public deleteDataSourceByName(name: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).deleteDataSourceByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:delete` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * @summary Delete an existing data source by UID.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public deleteDataSourceByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).deleteDataSourceByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/getDataSourceByUID) instead
     * @summary Get a single data source by Id.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public getDataSourceByID(id: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).getDataSourceByID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * @summary Get a single data source by Name.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public getDataSourceByName(name: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).getDataSourceByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:kLtEtcRGk` (single data source).
     * @summary Get a single data source by UID.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public getDataSourceByUID(uid: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).getDataSourceByUID(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scopes: `datasources:*`, `datasources:name:*` and `datasources:name:test_datasource` (single data source).
     * @summary Get data source Id by Name.
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public getDataSourceIdByName(name: string, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).getDataSourceIdByName(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:read` and scope: `datasources:*`.
     * @summary Get all data sources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public getDataSources(options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).getDataSources(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:id:*` and `datasources:id:1` (single data source).  Please refer to [updated API](#/datasources/updateDataSourceByUID) instead
     * @summary Update an existing data source by its sequential ID.
     * @param {string} id 
     * @param {UpdateDataSourceCommand} updateDataSourceCommand 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public updateDataSourceByID(id: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).updateDataSourceByID(id, updateDataSourceCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Similar to creating a data source, `password` and `basicAuthPassword` should be defined under secureJsonData in order to be stored securely as an encrypted blob in the database. Then, the encrypted fields are listed under secureJsonFields section in the response.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:write` and scopes: `datasources:*`, `datasources:uid:*` and `datasources:uid:1` (single data source).
     * @summary Update an existing data source.
     * @param {string} uid 
     * @param {UpdateDataSourceCommand} updateDataSourceCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasourcesApi
     */
    public updateDataSourceByUID(uid: string, updateDataSourceCommand: UpdateDataSourceCommand, options?: RawAxiosRequestConfig) {
        return DatasourcesApiFp(this.configuration).updateDataSourceByUID(uid, updateDataSourceCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeviceDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.listDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDevices(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchDeviceQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDevices(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DevicesApi.searchDevices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DevicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDevices(options?: RawAxiosRequestConfig): AxiosPromise<Array<DeviceDTO>> {
            return localVarFp.listDevices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all devices within the last 30 days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDevices(options?: RawAxiosRequestConfig): AxiosPromise<SearchDeviceQueryResult> {
            return localVarFp.searchDevices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all devices within the last 30 days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public listDevices(options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).listDevices(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all devices within the last 30 days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public searchDevices(options?: RawAxiosRequestConfig) {
        return DevicesApiFp(this.configuration).searchDevices(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DsApi - axios parameter creator
 * @export
 */
export const DsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
         * @summary DataSource query metrics with expressions.
         * @param {MetricRequest} metricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetricsWithExpressions: async (metricRequest: MetricRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metricRequest' is not null or undefined
            assertParamExists('queryMetricsWithExpressions', 'metricRequest', metricRequest)
            const localVarPath = `/ds/query`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metricRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DsApi - functional programming interface
 * @export
 */
export const DsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DsApiAxiosParamCreator(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
         * @summary DataSource query metrics with expressions.
         * @param {MetricRequest} metricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryMetricsWithExpressions(metricRequest: MetricRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryMetricsWithExpressions(metricRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DsApi.queryMetricsWithExpressions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DsApi - factory interface
 * @export
 */
export const DsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DsApiFp(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
         * @summary DataSource query metrics with expressions.
         * @param {MetricRequest} metricRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryMetricsWithExpressions(metricRequest: MetricRequest, options?: RawAxiosRequestConfig): AxiosPromise<QueryDataResponse> {
            return localVarFp.queryMetricsWithExpressions(metricRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DsApi - object-oriented interface
 * @export
 * @class DsApi
 * @extends {BaseAPI}
 */
export class DsApi extends BaseAPI {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `datasources:query`.
     * @summary DataSource query metrics with expressions.
     * @param {MetricRequest} metricRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DsApi
     */
    public queryMetricsWithExpressions(metricRequest: MetricRequest, options?: RawAxiosRequestConfig) {
        return DsApiFp(this.configuration).queryMetricsWithExpressions(metricRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnterpriseApi - axios parameter creator
 * @export
 */
export const EnterpriseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamGroupApi: async (teamId: number, teamGroupMapping: TeamGroupMapping, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamGroupApi', 'teamId', teamId)
            // verify required parameter 'teamGroupMapping' is not null or undefined
            assertParamExists('addTeamGroupApi', 'teamGroupMapping', teamGroupMapping)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamGroupMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamRole: async (teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamRole', 'teamId', teamId)
            // verify required parameter 'addTeamRoleCommand' is not null or undefined
            assertParamExists('addTeamRole', 'addTeamRoleCommand', addTeamRoleCommand)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole: async (userId: number, addUserRoleCommand: AddUserRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserRole', 'userId', userId)
            // verify required parameter 'addUserRoleCommand' is not null or undefined
            assertParamExists('addUserRole', 'addUserRoleCommand', addUserRoleCommand)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUserRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadAccessControl: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/provisioning/access-control/reload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * clean cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanDataSourceCache: async (dataSourceUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceUID' is not null or undefined
            assertParamExists('cleanDataSourceCache', 'dataSourceUID', dataSourceUID)
            const localVarPath = `/datasources/{dataSourceUID}/cache/clean`
                .replace(`{${"dataSourceUID"}}`, encodeURIComponent(String(dataSourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('createRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRuleWriteTarget: async (prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prometheusRemoteWriteTargetJSON' is not null or undefined
            assertParamExists('createRecordingRuleWriteTarget', 'prometheusRemoteWriteTargetJSON', prometheusRemoteWriteTargetJSON)
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prometheusRemoteWriteTargetJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('createReport', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (createRoleForm: CreateRoleForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRoleForm' is not null or undefined
            assertParamExists('createRole', 'createRoleForm', createRoleForm)
            const localVarPath = `/access-control/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRoleForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLicenseToken: async (deleteTokenCommand: DeleteTokenCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTokenCommand' is not null or undefined
            assertParamExists('deleteLicenseToken', 'deleteTokenCommand', deleteTokenCommand)
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTokenCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRule: async (recordingRuleID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleID' is not null or undefined
            assertParamExists('deleteRecordingRule', 'recordingRuleID', recordingRuleID)
            const localVarPath = `/recording-rules/{recordingRuleID}`
                .replace(`{${"recordingRuleID"}}`, encodeURIComponent(String(recordingRuleID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRuleWriteTarget: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReport', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (roleUID: string, force?: boolean, global?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('deleteRole', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * disable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDataSourceCache: async (dataSourceUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceUID' is not null or undefined
            assertParamExists('disableDataSourceCache', 'dataSourceUID', dataSourceUID)
            const localVarPath = `/datasources/{dataSourceUID}/cache/disable`
                .replace(`{${"dataSourceUID"}}`, encodeURIComponent(String(dataSourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * enable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDataSourceCache: async (dataSourceUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceUID' is not null or undefined
            assertParamExists('enableDataSourceCache', 'dataSourceUID', dataSourceUID)
            const localVarPath = `/datasources/{dataSourceUID}/cache/enable`
                .replace(`{${"dataSourceUID"}}`, encodeURIComponent(String(dataSourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessControlStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-control/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsCSV: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/custom-permissions-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/custom-permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceCacheConfig: async (dataSourceUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceUID' is not null or undefined
            assertParamExists('getDataSourceCacheConfig', 'dataSourceUID', dataSourceUID)
            const localVarPath = `/datasources/{dataSourceUID}/cache`
                .replace(`{${"dataSourceUID"}}`, encodeURIComponent(String(dataSourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRuleWriteTarget: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getReport', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (roleUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('getRole', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments: async (roleUID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('getRoleAssignments', 'roleUID', roleUID)
            const localVarPath = `/access-control/roles/{roleUID}/assignments`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSLO: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/slo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsImage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/images/:image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/ldap-sync-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamGroupsApi: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamGroupsApi', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves LBAC rules for a team.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamLBACRulesApi: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getTeamLBACRulesApi', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}/lbac/teams`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordingRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (delegatable?: boolean, includeHidden?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-control/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (delegatable !== undefined) {
                localVarQueryParameter['delegatable'] = delegatable;
            }

            if (includeHidden !== undefined) {
                localVarQueryParameter['includeHidden'] = includeHidden;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamRoles: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('listTeamRoles', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamsRoles: async (rolesSearchQuery: RolesSearchQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolesSearchQuery' is not null or undefined
            assertParamExists('listTeamsRoles', 'rolesSearchQuery', rolesSearchQuery)
            const localVarPath = `/access-control/teams/roles/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolesSearchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserRoles', 'userId', userId)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersRoles: async (rolesSearchQuery: RolesSearchQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rolesSearchQuery' is not null or undefined
            assertParamExists('listUsersRoles', 'rolesSearchQuery', rolesSearchQuery)
            const localVarPath = `/access-control/users/roles/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rolesSearchQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACS: async (relayState?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/acs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (relayState !== undefined) {
                localVarQueryParameter['RelayState'] = relayState;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLicenseToken: async (deleteTokenCommand: DeleteTokenCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTokenCommand' is not null or undefined
            assertParamExists('postLicenseToken', 'deleteTokenCommand', deleteTokenCommand)
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTokenCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRenewLicenseToken: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postRenewLicenseToken', 'body', body)
            const localVarPath = `/licensing/token/renew`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSLO: async (sAMLRequest?: string, sAMLResponse?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/slo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sAMLRequest !== undefined) {
                localVarQueryParameter['SAMLRequest'] = sAMLRequest;
            }

            if (sAMLResponse !== undefined) {
                localVarQueryParameter['SAMLResponse'] = sAMLResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/refresh-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamGroupApiQuery: async (teamId: number, groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamGroupApiQuery', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamRole: async (roleUID: string, teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('removeTeamRole', 'roleUID', roleUID)
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamRole', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)))
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserRole: async (roleUID: string, userId: number, global?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('removeUserRole', 'roleUID', roleUID)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserRole', 'userId', userId)
            const localVarPath = `/access-control/users/{userId}/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportCSVs: async (dashboards?: string, title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/render/csvs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dashboards !== undefined) {
                localVarQueryParameter['dashboards'] = dashboards;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportPDFs: async (dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/render/pdfs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dashboards !== undefined) {
                localVarQueryParameter['dashboards'] = dashboards;
            }

            if (orientation !== undefined) {
                localVarQueryParameter['orientation'] = orientation;
            }

            if (layout !== undefined) {
                localVarQueryParameter['layout'] = layout;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (scaleFactor !== undefined) {
                localVarQueryParameter['scaleFactor'] = scaleFactor;
            }

            if (includeTables !== undefined) {
                localVarQueryParameter['includeTables'] = includeTables;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReportSettings: async (reportSettings: ReportSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportSettings' is not null or undefined
            assertParamExists('saveReportSettings', 'reportSettings', reportSettings)
            const localVarPath = `/reports/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
         * @summary Debug permissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResult: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/access-control/assignments/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReport: async (reportEmail: ReportEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportEmail' is not null or undefined
            assertParamExists('sendReport', 'reportEmail', reportEmail)
            const localVarPath = `/reports/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail: async (createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('sendTestEmail', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports/test-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * set cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {CacheConfigSetter} cacheConfigSetter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceCacheConfig: async (dataSourceUID: string, cacheConfigSetter: CacheConfigSetter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceUID' is not null or undefined
            assertParamExists('setDataSourceCacheConfig', 'dataSourceUID', dataSourceUID)
            // verify required parameter 'cacheConfigSetter' is not null or undefined
            assertParamExists('setDataSourceCacheConfig', 'cacheConfigSetter', cacheConfigSetter)
            const localVarPath = `/datasources/{dataSourceUID}/cache`
                .replace(`{${"dataSourceUID"}}`, encodeURIComponent(String(dataSourceUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cacheConfigSetter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAssignments: async (roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('setRoleAssignments', 'roleUID', roleUID)
            // verify required parameter 'setRoleAssignmentsCommand' is not null or undefined
            assertParamExists('setRoleAssignments', 'setRoleAssignmentsCommand', setRoleAssignmentsCommand)
            const localVarPath = `/access-control/roles/{roleUID}/assignments`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setRoleAssignmentsCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamRoles: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setTeamRoles', 'teamId', teamId)
            const localVarPath = `/access-control/teams/{teamId}/roles`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles: async (userId: number, setUserRolesCommand: SetUserRolesCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setUserRoles', 'userId', userId)
            // verify required parameter 'setUserRolesCommand' is not null or undefined
            assertParamExists('setUserRoles', 'setUserRolesCommand', setUserRolesCommand)
            const localVarPath = `/access-control/users/{userId}/roles`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserRolesCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('testCreateRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('updateRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport: async (id: number, createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateReport', 'id', id)
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('updateReport', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (roleUID: string, updateRoleCommand: UpdateRoleCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleUID' is not null or undefined
            assertParamExists('updateRole', 'roleUID', roleUID)
            // verify required parameter 'updateRoleCommand' is not null or undefined
            assertParamExists('updateRole', 'updateRoleCommand', updateRoleCommand)
            const localVarPath = `/access-control/roles/{roleUID}`
                .replace(`{${"roleUID"}}`, encodeURIComponent(String(roleUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRoleCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates LBAC rules for a team.
         * @param {string} uid 
         * @param {UpdateTeamLBACCommand} [updateTeamLBACCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamLBACRulesApi: async (uid: string, updateTeamLBACCommand?: UpdateTeamLBACCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateTeamLBACRulesApi', 'uid', uid)
            const localVarPath = `/datasources/uid/{uid}/lbac/teams`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamLBACCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnterpriseApi - functional programming interface
 * @export
 */
export const EnterpriseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnterpriseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamGroupApi(teamId, teamGroupMapping, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.addTeamGroupApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamRole(teamId, addTeamRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.addTeamRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserRole(userId, addUserRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.addUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminProvisioningReloadAccessControl(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.adminProvisioningReloadAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * clean cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cleanDataSourceCache(dataSourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.cleanDataSourceCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordingRuleJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrometheusRemoteWriteTargetJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(createRoleForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.createRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLicenseToken(deleteTokenCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingRule(recordingRuleID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingRuleWriteTarget(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleUID, force, global, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.deleteRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * disable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableDataSourceCache(dataSourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.disableDataSourceCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * enable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableDataSourceCache(dataSourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.enableDataSourceCache']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessControlStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessControlStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getAccessControlStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCustomPermissionsCSV(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPermissionsCSV(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getCustomPermissionsCSV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCustomPermissionsReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPermissionsReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getCustomPermissionsReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceCacheConfig(dataSourceUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceCacheConfig(dataSourceUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getDataSourceCacheConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrometheusRemoteWriteTargetJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingRuleWriteTarget(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getReportSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReports(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReports(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(roleUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(roleUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleAssignments(roleUID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSAMLLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSAMLLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSAMLLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSLO(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSLO(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSLO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingsImage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsImage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSettingsImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveSyncStatusDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getSyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamGroupDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamGroupsApi(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getTeamGroupsApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves LBAC rules for a team.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamLBACRulesApi(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamLBACRules>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamLBACRulesApi(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.getTeamLBACRulesApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecordingRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordingRuleJSON>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecordingRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listRecordingRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(delegatable, includeHidden, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamRoles(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamRoles(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listTeamRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<RoleDTO>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTeamsRoles(rolesSearchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listTeamsRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserRoles(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserRoles(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<RoleDTO>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersRoles(rolesSearchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.listUsersRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postACS(relayState?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postACS(relayState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.postACS']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLicenseToken(deleteTokenCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.postLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRenewLicenseToken(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.postRenewLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSLO(sAMLRequest, sAMLResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.postSLO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLicenseStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveUserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLicenseStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.refreshLicenseStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamGroupApiQuery(teamId, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.removeTeamGroupApiQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamRole(roleUID, teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.removeTeamRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserRole(roleUID, userId, global, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.removeUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderReportCSVs(dashboards, title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.renderReportCSVs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.renderReportPDFs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveReportSettings(reportSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.saveReportSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
         * @summary Debug permissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchResult(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchResult(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.searchResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReport(reportEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.sendReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestEmail(createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.sendTestEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * set cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {CacheConfigSetter} cacheConfigSetter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceCacheConfig(dataSourceUID: string, cacheConfigSetter: CacheConfigSetter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheConfigResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDataSourceCacheConfig(dataSourceUID, cacheConfigSetter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.setDataSourceCacheConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRoleAssignments(roleUID, setRoleAssignmentsCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.setRoleAssignments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTeamRoles(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTeamRoles(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.setTeamRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserRoles(userId, setUserRolesCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.setUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCreateRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.testCreateRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordingRuleJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReport(id, createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(roleUID, updateRoleCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates LBAC rules for a team.
         * @param {string} uid 
         * @param {UpdateTeamLBACCommand} [updateTeamLBACCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamLBACRulesApi(uid: string, updateTeamLBACCommand?: UpdateTeamLBACCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateTeamLBACRulesApi200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamLBACRulesApi(uid, updateTeamLBACCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnterpriseApi.updateTeamLBACRulesApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnterpriseApi - factory interface
 * @export
 */
export const EnterpriseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnterpriseApiFp(configuration)
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addTeamGroupApi(teamId, teamGroupMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
         * @summary Add team role.
         * @param {number} teamId 
         * @param {AddTeamRoleCommand} addTeamRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addTeamRole(teamId, addTeamRoleCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Add a user role assignment.
         * @param {number} userId 
         * @param {AddUserRoleCommand} addUserRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addUserRole(userId, addUserRoleCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig): AxiosPromise<ErrorResponseBody> {
            return localVarFp.adminProvisioningReloadAccessControl(options).then((request) => request(axios, basePath));
        },
        /**
         * clean cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): AxiosPromise<CacheConfigResponse> {
            return localVarFp.cleanDataSourceCache(dataSourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<RecordingRuleJSON> {
            return localVarFp.createRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig): AxiosPromise<PrometheusRemoteWriteTargetJSON> {
            return localVarFp.createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<CreateReport200Response> {
            return localVarFp.createReport(createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
         * @summary Create a new custom role.
         * @param {CreateRoleForm} createRoleForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.createRole(createRoleForm, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): AxiosPromise<ErrorResponseBody> {
            return localVarFp.deleteLicenseToken(deleteTokenCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRecordingRule(recordingRuleID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRecordingRuleWriteTarget(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
         * @summary Delete a custom role.
         * @param {string} roleUID 
         * @param {boolean} [force] 
         * @param {boolean} [global] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRole(roleUID, force, global, options).then((request) => request(axios, basePath));
        },
        /**
         * disable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): AxiosPromise<CacheConfigResponse> {
            return localVarFp.disableDataSourceCache(dataSourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * enable cache for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig): AxiosPromise<CacheConfigResponse> {
            return localVarFp.enableDataSourceCache(dataSourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
         * @summary Get status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessControlStatus(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getAccessControlStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsCSV(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomPermissionsCSV(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsReport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomPermissionsReport(options).then((request) => request(axios, basePath));
        },
        /**
         * get cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceCacheConfig(dataSourceUID: string, options?: RawAxiosRequestConfig): AxiosPromise<CacheConfigResponse> {
            return localVarFp.getDataSourceCacheConfig(dataSourceUID, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseToken(options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.getLicenseToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): AxiosPromise<PrometheusRemoteWriteTargetJSON> {
            return localVarFp.getRecordingRuleWriteTarget(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.getReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportSettings(options?: RawAxiosRequestConfig): AxiosPromise<ReportSettings> {
            return localVarFp.getReportSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(options?: RawAxiosRequestConfig): AxiosPromise<Array<Report>> {
            return localVarFp.getReports(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
         * @summary Get a role.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(roleUID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.getRole(roleUID, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
         * @summary Get role assignments.
         * @param {string} roleUID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentsDTO> {
            return localVarFp.getRoleAssignments(roleUID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSAMLLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSLO(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSLO(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsImage(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getSettingsImage(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus(options?: RawAxiosRequestConfig): AxiosPromise<ActiveSyncStatusDTO> {
            return localVarFp.getSyncStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamGroupDTO>> {
            return localVarFp.getTeamGroupsApi(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves LBAC rules for a team.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamLBACRulesApi(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamLBACRules>> {
            return localVarFp.getTeamLBACRulesApi(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordingRules(options?: RawAxiosRequestConfig): AxiosPromise<Array<RecordingRuleJSON>> {
            return localVarFp.listRecordingRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
         * @summary Get all roles.
         * @param {boolean} [delegatable] 
         * @param {boolean} [includeHidden] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDTO>> {
            return localVarFp.listRoles(delegatable, includeHidden, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
         * @summary Get team roles.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamRoles(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.listTeamRoles(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
         * @summary List roles assigned to multiple teams.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<RoleDTO>; }> {
            return localVarFp.listTeamsRoles(rolesSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
         * @summary List roles assigned to a user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserRoles(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<RoleDTO>> {
            return localVarFp.listUserRoles(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
         * @summary List roles assigned to multiple users.
         * @param {RolesSearchQuery} rolesSearchQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<RoleDTO>; }> {
            return localVarFp.listUsersRoles(rolesSearchQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACS(relayState?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postACS(relayState, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.postLicenseToken(deleteTokenCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postRenewLicenseToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postSLO(sAMLRequest, sAMLResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStats(options?: RawAxiosRequestConfig): AxiosPromise<ActiveUserStats> {
            return localVarFp.refreshLicenseStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeTeamGroupApiQuery(teamId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
         * @summary Remove team role.
         * @param {string} roleUID 
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeTeamRole(roleUID, teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Remove a user role assignment.
         * @param {string} roleUID 
         * @param {number} userId 
         * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeUserRole(roleUID, userId, global, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.renderReportCSVs(dashboards, title, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.saveReportSettings(reportSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
         * @summary Debug permissions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchResult(options?: RawAxiosRequestConfig): AxiosPromise<SearchResult> {
            return localVarFp.searchResult(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.sendReport(reportEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.sendTestEmail(createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
        /**
         * set cache config for a single data source
         * @param {string} dataSourceUID 
         * @param {CacheConfigSetter} cacheConfigSetter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceCacheConfig(dataSourceUID: string, cacheConfigSetter: CacheConfigSetter, options?: RawAxiosRequestConfig): AxiosPromise<CacheConfigResponse> {
            return localVarFp.setDataSourceCacheConfig(dataSourceUID, cacheConfigSetter, options).then((request) => request(axios, basePath));
        },
        /**
         * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
         * @summary Set role assignments.
         * @param {string} roleUID 
         * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig): AxiosPromise<RoleAssignmentsDTO> {
            return localVarFp.setRoleAssignments(roleUID, setRoleAssignmentsCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
         * @summary Update team role.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamRoles(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setTeamRoles(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
         * @summary Set user role assignments.
         * @param {number} userId 
         * @param {SetUserRolesCommand} setUserRolesCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setUserRoles(userId, setUserRolesCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.testCreateRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<RecordingRuleJSON> {
            return localVarFp.updateRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateReport(id, createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
         * @summary Update a custom role.
         * @param {string} roleUID 
         * @param {UpdateRoleCommand} updateRoleCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig): AxiosPromise<RoleDTO> {
            return localVarFp.updateRole(roleUID, updateRoleCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates LBAC rules for a team.
         * @param {string} uid 
         * @param {UpdateTeamLBACCommand} [updateTeamLBACCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamLBACRulesApi(uid: string, updateTeamLBACCommand?: UpdateTeamLBACCommand, options?: RawAxiosRequestConfig): AxiosPromise<UpdateTeamLBACRulesApi200Response> {
            return localVarFp.updateTeamLBACRulesApi(uid, updateTeamLBACCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnterpriseApi - object-oriented interface
 * @export
 * @class EnterpriseApi
 * @extends {BaseAPI}
 */
export class EnterpriseApi extends BaseAPI {
    /**
     * 
     * @summary Add External Group.
     * @param {number} teamId 
     * @param {TeamGroupMapping} teamGroupMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).addTeamGroupApi(teamId, teamGroupMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and scope `permissions:type:delegate`.
     * @summary Add team role.
     * @param {number} teamId 
     * @param {AddTeamRoleCommand} addTeamRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public addTeamRole(teamId: number, addTeamRoleCommand: AddTeamRoleCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).addTeamRole(teamId, addTeamRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a role to a specific user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:add` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only assign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Add a user role assignment.
     * @param {number} userId 
     * @param {AddUserRoleCommand} addUserRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public addUserRole(userId: number, addUserRoleCommand: AddUserRoleCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).addUserRole(userId, addUserRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary You need to have a permission with action `provisioning:reload` with scope `provisioners:accesscontrol`.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public adminProvisioningReloadAccessControl(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).adminProvisioningReloadAccessControl(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * clean cache for a single data source
     * @param {string} dataSourceUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public cleanDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).cleanDataSourceCache(dataSourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a recording rule that is then registered and started.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns a 422 if there is not an existing prometheus data source configured.
     * @summary Create a remote write target.
     * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
     * @summary Create a report.
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createReport(createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new custom role and maps given permissions to that role. Note that roles with the same prefix as Fixed Roles can’t be created.  You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to create a custom role which allows to do that. This is done to prevent escalation of privileges.
     * @summary Create a new custom role.
     * @param {CreateRoleForm} createRoleForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public createRole(createRoleForm: CreateRoleForm, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).createRole(createRoleForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
     * @summary Remove license from database.
     * @param {DeleteTokenCommand} deleteTokenCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteLicenseToken(deleteTokenCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete removes the rule from the registry and stops it.
     * @param {number} recordingRuleID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteRecordingRule(recordingRuleID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the remote write target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteRecordingRuleWriteTarget(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
     * @summary Delete a report.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteReport(id: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a role with the given UID, and it’s permissions. If the role is assigned to a built-in role, the deletion operation will fail, unless force query param is set to true, and in that case all assignments will also be deleted.  You need to have a permission with action `roles:delete` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only delete a custom role with the same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to delete a custom role which allows to do that.
     * @summary Delete a custom role.
     * @param {string} roleUID 
     * @param {boolean} [force] 
     * @param {boolean} [global] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public deleteRole(roleUID: string, force?: boolean, global?: boolean, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).deleteRole(roleUID, force, global, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * disable cache for a single data source
     * @param {string} dataSourceUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public disableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).disableDataSourceCache(dataSourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * enable cache for a single data source
     * @param {string} dataSourceUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public enableDataSourceCache(dataSourceUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).enableDataSourceCache(dataSourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an indicator to check if fine-grained access control is enabled or not.  You need to have a permission with action `status:accesscontrol` and scope `services:accesscontrol`.
     * @summary Get status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getAccessControlStatus(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getAccessControlStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * @summary Get custom permissions report in CSV format.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getCustomPermissionsCSV(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getCustomPermissionsCSV(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * @summary Get custom permissions report.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getCustomPermissionsReport(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getCustomPermissionsReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get cache config for a single data source
     * @param {string} dataSourceUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getDataSourceCacheConfig(dataSourceUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getDataSourceCacheConfig(dataSourceUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * @summary Get license token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getLicenseToken(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getLicenseToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getMetadata(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the prometheus remote write target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getRecordingRuleWriteTarget(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
     * @summary Get a report.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getReport(id: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
     * @summary Get report settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getReportSettings(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getReportSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
     * @summary List reports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getReports(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getReports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a role for the given UID.  You need to have a permission with action `roles:read` and scope `roles:*`.
     * @summary Get a role.
     * @param {string} roleUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getRole(roleUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getRole(roleUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:list` and scope `teams:id:*` and `users.roles:list` and scope `users:id:*`.
     * @summary Get role assignments.
     * @param {string} roleUID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getRoleAssignments(roleUID: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getRoleAssignments(roleUID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLogout initiates single logout process.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getSAMLLogout(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSAMLLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * @summary It performs Single Logout (SLO) callback.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getSLO(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSLO(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
     * @summary Get custom branding report image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getSettingsImage(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSettingsImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check license availability.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `ldap.status:read`.
     * @summary Returns the current state of the LDAP background sync integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getSyncStatus(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getSyncStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get External Groups.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getTeamGroupsApi(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves LBAC rules for a team.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public getTeamLBACRulesApi(uid: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).getTeamLBACRulesApi(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all rules in the database: active or deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listRecordingRules(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listRecordingRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all existing roles. The response contains all global and organization local roles, for the organization which user is signed in.  You need to have a permission with action `roles:read` and scope `roles:*`.  The `delegatable` flag reduces the set of roles to only those for which the signed-in user has permissions to assign.
     * @summary Get all roles.
     * @param {boolean} [delegatable] 
     * @param {boolean} [includeHidden] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listRoles(delegatable?: boolean, includeHidden?: boolean, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listRoles(delegatable, includeHidden, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:read` and scope `teams:id:<team ID>`.
     * @summary Get team roles.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listTeamRoles(teamId: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listTeamRoles(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to the given teams.  You need to have a permission with action `teams.roles:read` and scope `teams:id:*`.
     * @summary List roles assigned to multiple teams.
     * @param {RolesSearchQuery} rolesSearchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listTeamsRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listTeamsRoles(rolesSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to a given user. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:<user ID>`.
     * @summary List roles assigned to a user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listUserRoles(userId: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listUserRoles(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the roles that have been directly assigned to the given users. The list does not include built-in roles (Viewer, Editor, Admin or Grafana Admin), and it does not include roles that have been inherited from a team.  You need to have a permission with action `users.roles:read` and scope `users:id:*`.
     * @summary List roles assigned to multiple users.
     * @param {RolesSearchQuery} rolesSearchQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public listUsersRoles(rolesSearchQuery: RolesSearchQuery, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).listUsersRoles(rolesSearchQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary It performs Assertion Consumer Service (ACS).
     * @param {string} [relayState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public postACS(relayState?: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).postACS(relayState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:update`.
     * @summary Create license token.
     * @param {DeleteTokenCommand} deleteTokenCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).postLicenseToken(deleteTokenCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
     * @summary Manually force license refresh.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).postRenewLicenseToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * @summary It performs Single Logout (SLO) callback.
     * @param {string} [sAMLRequest] 
     * @param {string} [sAMLResponse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).postSLO(sAMLRequest, sAMLResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * @summary Refresh license stats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public refreshLicenseStats(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).refreshLicenseStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove External Group.
     * @param {number} teamId 
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).removeTeamGroupApiQuery(teamId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:remove` and scope `permissions:type:delegate`.
     * @summary Remove team role.
     * @param {string} roleUID 
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public removeTeamRole(roleUID: string, teamId: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).removeTeamRole(roleUID, teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from a user. For bulk updates consider Set user role assignments.  You need to have a permission with action `users.roles:remove` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Remove a user role assignment.
     * @param {string} roleUID 
     * @param {number} userId 
     * @param {boolean} [global] A flag indicating if the assignment is global or not. If set to false, the default org ID of the authenticated user will be used from the request to remove assignment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public removeUserRole(roleUID: string, userId: number, global?: boolean, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).removeUserRole(roleUID, userId, global, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to all users and with a valid license.
     * @summary Download a CSV report.
     * @param {string} [dashboards] 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).renderReportCSVs(dashboards, title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to all users and with a valid license.
     * @summary Render report for multiple dashboards.
     * @param {string} [dashboards] 
     * @param {string} [orientation] 
     * @param {string} [layout] 
     * @param {string} [title] 
     * @param {string} [scaleFactor] 
     * @param {string} [includeTables] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
     * @summary Save settings.
     * @param {ReportSettings} reportSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).saveReportSettings(reportSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the result of the search through access-control role assignments.  You need to have a permission with action `teams.roles:read` on scope `teams:*` and a permission with action `users.roles:read` on scope `users:*`.
     * @summary Debug permissions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public searchResult(options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).searchResult(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
     * @summary Send a report.
     * @param {ReportEmail} reportEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).sendReport(reportEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
     * @summary Send test report via email.
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).sendTestEmail(createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * set cache config for a single data source
     * @param {string} dataSourceUID 
     * @param {CacheConfigSetter} cacheConfigSetter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public setDataSourceCacheConfig(dataSourceUID: string, cacheConfigSetter: CacheConfigSetter, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).setDataSourceCacheConfig(dataSourceUID, cacheConfigSetter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set role assignments for the role with the given UID.  You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate`, and `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate`.
     * @summary Set role assignments.
     * @param {string} roleUID 
     * @param {SetRoleAssignmentsCommand} setRoleAssignmentsCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public setRoleAssignments(roleUID: string, setRoleAssignmentsCommand: SetRoleAssignmentsCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).setRoleAssignments(roleUID, setRoleAssignmentsCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `teams.roles:add` and `teams.roles:remove` and scope `permissions:type:delegate` for each.
     * @summary Update team role.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public setTeamRoles(teamId: number, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).setTeamRoles(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user’s role assignments to match the provided set of UIDs. This will remove any assigned roles that aren’t in the request and add roles that are in the set but are not already assigned to the user. If you want to add or remove a single role, consider using Add a user role assignment or Remove a user role assignment instead.  You need to have a permission with action `users.roles:add` and `users.roles:remove` and scope `permissions:type:delegate` for each. `permissions:type:delegate`  scope ensures that users can only assign or unassign roles which have same, or a subset of permissions which the user has. For example, if a user does not have required permissions for creating users, they won’t be able to assign or unassign a role which will allow to do that. This is done to prevent escalation of privileges.
     * @summary Set user role assignments.
     * @param {number} userId 
     * @param {SetUserRolesCommand} setUserRolesCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public setUserRoles(userId: number, setUserRolesCommand: SetUserRolesCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).setUserRoles(userId, setUserRolesCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a recording rule.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).testCreateRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the active status of a rule.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
     * @summary Update a report.
     * @param {number} id 
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateReport(id, createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `roles:write` and scope `permissions:type:delegate`. `permissions:type:delegate` scope ensures that users can only create custom roles with the same, or a subset of permissions which the user has.
     * @summary Update a custom role.
     * @param {string} roleUID 
     * @param {UpdateRoleCommand} updateRoleCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateRole(roleUID: string, updateRoleCommand: UpdateRoleCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateRole(roleUID, updateRoleCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates LBAC rules for a team.
     * @param {string} uid 
     * @param {UpdateTeamLBACCommand} [updateTeamLBACCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnterpriseApi
     */
    public updateTeamLBACRulesApi(uid: string, updateTeamLBACCommand?: UpdateTeamLBACCommand, options?: RawAxiosRequestConfig) {
        return EnterpriseApiFp(this.configuration).updateTeamLBACRulesApi(uid, updateTeamLBACCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FolderPermissionsApi - axios parameter creator
 * @export
 */
export const FolderPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets all existing permissions for the folder with the given `uid`.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPermissionList: async (folderUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('getFolderPermissionList', 'folderUid', folderUid)
            const localVarPath = `/folders/{folder_uid}/permissions`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
         * @param {string} folderUid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderPermissions: async (folderUid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('updateFolderPermissions', 'folderUid', folderUid)
            // verify required parameter 'updateDashboardACLCommand' is not null or undefined
            assertParamExists('updateFolderPermissions', 'updateDashboardACLCommand', updateDashboardACLCommand)
            const localVarPath = `/folders/{folder_uid}/permissions`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDashboardACLCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FolderPermissionsApi - functional programming interface
 * @export
 */
export const FolderPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FolderPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets all existing permissions for the folder with the given `uid`.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderPermissionList(folderUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardACLInfoDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderPermissionList(folderUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderPermissionsApi.getFolderPermissionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
         * @param {string} folderUid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolderPermissions(folderUid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolderPermissions(folderUid, updateDashboardACLCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FolderPermissionsApi.updateFolderPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FolderPermissionsApi - factory interface
 * @export
 */
export const FolderPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FolderPermissionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets all existing permissions for the folder with the given `uid`.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderPermissionList(folderUid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardACLInfoDTO>> {
            return localVarFp.getFolderPermissionList(folderUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
         * @param {string} folderUid 
         * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolderPermissions(folderUid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateFolderPermissions(folderUid, updateDashboardACLCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FolderPermissionsApi - object-oriented interface
 * @export
 * @class FolderPermissionsApi
 * @extends {BaseAPI}
 */
export class FolderPermissionsApi extends BaseAPI {
    /**
     * 
     * @summary Gets all existing permissions for the folder with the given `uid`.
     * @param {string} folderUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderPermissionsApi
     */
    public getFolderPermissionList(folderUid: string, options?: RawAxiosRequestConfig) {
        return FolderPermissionsApiFp(this.configuration).getFolderPermissionList(folderUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates permissions for a folder. This operation will remove existing permissions if they’re not included in the request.
     * @param {string} folderUid 
     * @param {UpdateDashboardACLCommand} updateDashboardACLCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FolderPermissionsApi
     */
    public updateFolderPermissions(folderUid: string, updateDashboardACLCommand: UpdateDashboardACLCommand, options?: RawAxiosRequestConfig) {
        return FolderPermissionsApiFp(this.configuration).updateFolderPermissions(folderUid, updateDashboardACLCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If nested folders are enabled then it additionally expects the parent folder UID.
         * @summary Create folder.
         * @param {CreateFolderCommand} createFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder: async (createFolderCommand: CreateFolderCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFolderCommand' is not null or undefined
            assertParamExists('createFolder', 'createFolderCommand', createFolderCommand)
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFolderCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
         * @summary Delete folder.
         * @param {string} folderUid 
         * @param {boolean} [forceDeleteRules] If &#x60;true&#x60; any Grafana 8 Alerts under this folder will be deleted. Set to &#x60;false&#x60; so that the request will fail if the folder contains any Grafana 8 Alerts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder: async (folderUid: string, forceDeleteRules?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('deleteFolder', 'folderUid', folderUid)
            const localVarPath = `/folders/{folder_uid}`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (forceDeleteRules !== undefined) {
                localVarQueryParameter['forceDeleteRules'] = forceDeleteRules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
         * @summary Get folder by id.
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFolderByID: async (folderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderId' is not null or undefined
            assertParamExists('getFolderByID', 'folderId', folderId)
            const localVarPath = `/folders/id/{folder_id}`
                .replace(`{${"folder_id"}}`, encodeURIComponent(String(folderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get folder by uid.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByUID: async (folderUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('getFolderByUID', 'folderUid', folderUid)
            const localVarPath = `/folders/{folder_uid}`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the count of each descendant of a folder by kind. The folder is identified by UID.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderDescendantCounts: async (folderUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('getFolderDescendantCounts', 'folderUid', folderUid)
            const localVarPath = `/folders/{folder_uid}/counts`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
         * @summary Get all folders.
         * @param {number} [limit] Limit the maximum number of folders to return
         * @param {number} [page] Page index for starting fetching folders
         * @param {string} [parentUid] The parent folder UID
         * @param {GetFoldersPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return folders that the user can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (limit?: number, page?: number, parentUid?: string, permission?: GetFoldersPermissionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (parentUid !== undefined) {
                localVarQueryParameter['parentUid'] = parentUid;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Move folder.
         * @param {string} folderUid 
         * @param {MoveFolderCommand} moveFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder: async (folderUid: string, moveFolderCommand: MoveFolderCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('moveFolder', 'folderUid', folderUid)
            // verify required parameter 'moveFolderCommand' is not null or undefined
            assertParamExists('moveFolder', 'moveFolderCommand', moveFolderCommand)
            const localVarPath = `/folders/{folder_uid}/move`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moveFolderCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update folder.
         * @param {string} folderUid 
         * @param {UpdateFolderCommand} updateFolderCommand To change the unique identifier (uid), provide another one. To overwrite an existing folder with newer version, set &#x60;overwrite&#x60; to &#x60;true&#x60;. Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless &#x60;overwrite&#x60; is &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder: async (folderUid: string, updateFolderCommand: UpdateFolderCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUid' is not null or undefined
            assertParamExists('updateFolder', 'folderUid', folderUid)
            // verify required parameter 'updateFolderCommand' is not null or undefined
            assertParamExists('updateFolder', 'updateFolderCommand', updateFolderCommand)
            const localVarPath = `/folders/{folder_uid}`
                .replace(`{${"folder_uid"}}`, encodeURIComponent(String(folderUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFolderCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * If nested folders are enabled then it additionally expects the parent folder UID.
         * @summary Create folder.
         * @param {CreateFolderCommand} createFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFolder(createFolderCommand: CreateFolderCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFolder(createFolderCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.createFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
         * @summary Delete folder.
         * @param {string} folderUid 
         * @param {boolean} [forceDeleteRules] If &#x60;true&#x60; any Grafana 8 Alerts under this folder will be deleted. Set to &#x60;false&#x60; so that the request will fail if the folder contains any Grafana 8 Alerts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFolder(folderUid: string, forceDeleteRules?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFolder(folderUid, forceDeleteRules, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.deleteFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
         * @summary Get folder by id.
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getFolderByID(folderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderByID(folderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get folder by uid.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderByUID(folderUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderByUID(folderUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the count of each descendant of a folder by kind. The folder is identified by UID.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolderDescendantCounts(folderUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolderDescendantCounts(folderUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolderDescendantCounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
         * @summary Get all folders.
         * @param {number} [limit] Limit the maximum number of folders to return
         * @param {number} [page] Page index for starting fetching folders
         * @param {string} [parentUid] The parent folder UID
         * @param {GetFoldersPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return folders that the user can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(limit?: number, page?: number, parentUid?: string, permission?: GetFoldersPermissionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FolderSearchHit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(limit, page, parentUid, permission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.getFolders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Move folder.
         * @param {string} folderUid 
         * @param {MoveFolderCommand} moveFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFolder(folderUid: string, moveFolderCommand: MoveFolderCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFolder(folderUid, moveFolderCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.moveFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update folder.
         * @param {string} folderUid 
         * @param {UpdateFolderCommand} updateFolderCommand To change the unique identifier (uid), provide another one. To overwrite an existing folder with newer version, set &#x60;overwrite&#x60; to &#x60;true&#x60;. Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless &#x60;overwrite&#x60; is &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFolder(folderUid: string, updateFolderCommand: UpdateFolderCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Folder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFolder(folderUid, updateFolderCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoldersApi.updateFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * If nested folders are enabled then it additionally expects the parent folder UID.
         * @summary Create folder.
         * @param {CreateFolderCommand} createFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFolder(createFolderCommand: CreateFolderCommand, options?: RawAxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.createFolder(createFolderCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
         * @summary Delete folder.
         * @param {string} folderUid 
         * @param {boolean} [forceDeleteRules] If &#x60;true&#x60; any Grafana 8 Alerts under this folder will be deleted. Set to &#x60;false&#x60; so that the request will fail if the folder contains any Grafana 8 Alerts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFolder(folderUid: string, forceDeleteRules?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<DeleteFolder200Response> {
            return localVarFp.deleteFolder(folderUid, forceDeleteRules, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
         * @summary Get folder by id.
         * @param {number} folderId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFolderByID(folderId: number, options?: RawAxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.getFolderByID(folderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get folder by uid.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderByUID(folderUid: string, options?: RawAxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.getFolderByUID(folderUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the count of each descendant of a folder by kind. The folder is identified by UID.
         * @param {string} folderUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolderDescendantCounts(folderUid: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getFolderDescendantCounts(folderUid, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
         * @summary Get all folders.
         * @param {number} [limit] Limit the maximum number of folders to return
         * @param {number} [page] Page index for starting fetching folders
         * @param {string} [parentUid] The parent folder UID
         * @param {GetFoldersPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return folders that the user can edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(limit?: number, page?: number, parentUid?: string, permission?: GetFoldersPermissionEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<FolderSearchHit>> {
            return localVarFp.getFolders(limit, page, parentUid, permission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Move folder.
         * @param {string} folderUid 
         * @param {MoveFolderCommand} moveFolderCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFolder(folderUid: string, moveFolderCommand: MoveFolderCommand, options?: RawAxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.moveFolder(folderUid, moveFolderCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update folder.
         * @param {string} folderUid 
         * @param {UpdateFolderCommand} updateFolderCommand To change the unique identifier (uid), provide another one. To overwrite an existing folder with newer version, set &#x60;overwrite&#x60; to &#x60;true&#x60;. Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless &#x60;overwrite&#x60; is &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFolder(folderUid: string, updateFolderCommand: UpdateFolderCommand, options?: RawAxiosRequestConfig): AxiosPromise<Folder> {
            return localVarFp.updateFolder(folderUid, updateFolderCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * If nested folders are enabled then it additionally expects the parent folder UID.
     * @summary Create folder.
     * @param {CreateFolderCommand} createFolderCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public createFolder(createFolderCommand: CreateFolderCommand, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).createFolder(createFolderCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing folder identified by UID along with all dashboards (and their alerts) stored in the folder. This operation cannot be reverted. If nested folders are enabled then it also deletes all the subfolders.
     * @summary Delete folder.
     * @param {string} folderUid 
     * @param {boolean} [forceDeleteRules] If &#x60;true&#x60; any Grafana 8 Alerts under this folder will be deleted. Set to &#x60;false&#x60; so that the request will fail if the folder contains any Grafana 8 Alerts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public deleteFolder(folderUid: string, forceDeleteRules?: boolean, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).deleteFolder(folderUid, forceDeleteRules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the folder identified by id. This is deprecated. Please refer to [updated API](#/folders/getFolderByUID) instead
     * @summary Get folder by id.
     * @param {number} folderId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderByID(folderId: number, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderByID(folderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get folder by uid.
     * @param {string} folderUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderByUID(folderUid: string, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderByUID(folderUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the count of each descendant of a folder by kind. The folder is identified by UID.
     * @param {string} folderUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolderDescendantCounts(folderUid: string, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolderDescendantCounts(folderUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns all folders that the authenticated user has permission to view. If nested folders are enabled, it expects an additional query parameter with the parent folder UID and returns the immediate subfolders that the authenticated user has permission to view. If the parameter is not supplied then it returns immediate subfolders under the root that the authenticated user has permission to view.
     * @summary Get all folders.
     * @param {number} [limit] Limit the maximum number of folders to return
     * @param {number} [page] Page index for starting fetching folders
     * @param {string} [parentUid] The parent folder UID
     * @param {GetFoldersPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return folders that the user can edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolders(limit?: number, page?: number, parentUid?: string, permission?: GetFoldersPermissionEnum, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolders(limit, page, parentUid, permission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Move folder.
     * @param {string} folderUid 
     * @param {MoveFolderCommand} moveFolderCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public moveFolder(folderUid: string, moveFolderCommand: MoveFolderCommand, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).moveFolder(folderUid, moveFolderCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update folder.
     * @param {string} folderUid 
     * @param {UpdateFolderCommand} updateFolderCommand To change the unique identifier (uid), provide another one. To overwrite an existing folder with newer version, set &#x60;overwrite&#x60; to &#x60;true&#x60;. Provide the current version to safelly update the folder: if the provided version differs from the stored one the request will fail, unless &#x60;overwrite&#x60; is &#x60;true&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public updateFolder(folderUid: string, updateFolderCommand: UpdateFolderCommand, options?: RawAxiosRequestConfig) {
        return FoldersApiFp(this.configuration).updateFolder(folderUid, updateFolderCommand, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetFoldersPermissionEnum = {
    Edit: 'Edit',
    View: 'View'
} as const;
export type GetFoldersPermissionEnum = typeof GetFoldersPermissionEnum[keyof typeof GetFoldersPermissionEnum];


/**
 * GetCurrentOrgApi - axios parameter creator
 * @export
 */
export const GetCurrentOrgApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrgQuota: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org/quotas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GetCurrentOrgApi - functional programming interface
 * @export
 */
export const GetCurrentOrgApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GetCurrentOrgApiAxiosParamCreator(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentOrgQuota(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuotaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentOrgQuota(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GetCurrentOrgApi.getCurrentOrgQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GetCurrentOrgApi - factory interface
 * @export
 */
export const GetCurrentOrgApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GetCurrentOrgApiFp(configuration)
    return {
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrgQuota(options?: RawAxiosRequestConfig): AxiosPromise<Array<QuotaDTO>> {
            return localVarFp.getCurrentOrgQuota(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GetCurrentOrgApi - object-oriented interface
 * @export
 * @class GetCurrentOrgApi
 * @extends {BaseAPI}
 */
export class GetCurrentOrgApi extends BaseAPI {
    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
     * @summary Fetch Organization quota.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GetCurrentOrgApi
     */
    public getCurrentOrgQuota(options?: RawAxiosRequestConfig) {
        return GetCurrentOrgApiFp(this.configuration).getCurrentOrgQuota(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * apiHealthHandler will return ok if Grafana\'s web server is running and it can access the database. If the database cannot be accessed it will return http status code 503.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * apiHealthHandler will return ok if Grafana\'s web server is running and it can access the database. If the database cannot be accessed it will return http status code 503.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.getHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * apiHealthHandler will return ok if Grafana\'s web server is running and it can access the database. If the database cannot be accessed it will return http status code 503.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthResponse> {
            return localVarFp.getHealth(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * apiHealthHandler will return ok if Grafana\'s web server is running and it can access the database. If the database cannot be accessed it will return http status code 503.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealth(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).getHealth(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LdapDebugApi - axios parameter creator
 * @export
 */
export const LdapDebugApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/ldap-sync-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LdapDebugApi - functional programming interface
 * @export
 */
export const LdapDebugApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LdapDebugApiAxiosParamCreator(configuration)
    return {
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSyncStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveSyncStatusDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSyncStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LdapDebugApi.getSyncStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LdapDebugApi - factory interface
 * @export
 */
export const LdapDebugApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LdapDebugApiFp(configuration)
    return {
        /**
         * You need to have a permission with action `ldap.status:read`.
         * @summary Returns the current state of the LDAP background sync integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSyncStatus(options?: RawAxiosRequestConfig): AxiosPromise<ActiveSyncStatusDTO> {
            return localVarFp.getSyncStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LdapDebugApi - object-oriented interface
 * @export
 * @class LdapDebugApi
 * @extends {BaseAPI}
 */
export class LdapDebugApi extends BaseAPI {
    /**
     * You need to have a permission with action `ldap.status:read`.
     * @summary Returns the current state of the LDAP background sync integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdapDebugApi
     */
    public getSyncStatus(options?: RawAxiosRequestConfig) {
        return LdapDebugApiFp(this.configuration).getSyncStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LibraryElementsApi - axios parameter creator
 * @export
 */
export const LibraryElementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new library element.
         * @summary Create library element.
         * @param {CreateLibraryElementCommand} createLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibraryElement: async (createLibraryElementCommand: CreateLibraryElementCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createLibraryElementCommand' is not null or undefined
            assertParamExists('createLibraryElement', 'createLibraryElementCommand', createLibraryElementCommand)
            const localVarPath = `/library-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createLibraryElementCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
         * @summary Delete library element.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryElementByUID: async (libraryElementUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'libraryElementUid' is not null or undefined
            assertParamExists('deleteLibraryElementByUID', 'libraryElementUid', libraryElementUid)
            const localVarPath = `/library-elements/{library_element_uid}`
                .replace(`{${"library_element_uid"}}`, encodeURIComponent(String(libraryElementUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a library element with the given name.
         * @summary Get library element by name.
         * @param {string} libraryElementName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementByName: async (libraryElementName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'libraryElementName' is not null or undefined
            assertParamExists('getLibraryElementByName', 'libraryElementName', libraryElementName)
            const localVarPath = `/library-elements/name/{library_element_name}`
                .replace(`{${"library_element_name"}}`, encodeURIComponent(String(libraryElementName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a library element with the given UID.
         * @summary Get library element by UID.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementByUID: async (libraryElementUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'libraryElementUid' is not null or undefined
            assertParamExists('getLibraryElementByUID', 'libraryElementUid', libraryElementUid)
            const localVarPath = `/library-elements/{library_element_uid}`
                .replace(`{${"library_element_uid"}}`, encodeURIComponent(String(libraryElementUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of connections for a library element based on the UID specified.
         * @summary Get library element connections.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementConnections: async (libraryElementUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'libraryElementUid' is not null or undefined
            assertParamExists('getLibraryElementConnections', 'libraryElementUid', libraryElementUid)
            const localVarPath = `/library-elements/{library_element_uid}/connections/`
                .replace(`{${"library_element_uid"}}`, encodeURIComponent(String(libraryElementUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
         * @summary Get all library elements.
         * @param {string} [searchString] Part of the name or description searched for.
         * @param {GetLibraryElementsKindEnum} [kind] Kind of element to search for.
         * @param {GetLibraryElementsSortDirectionEnum} [sortDirection] Sort order of elements.
         * @param {string} [typeFilter] A comma separated list of types to filter the elements by
         * @param {string} [excludeUid] Element UID to exclude from search results.
         * @param {string} [folderFilter] A comma separated list of folder ID(s) to filter the elements by.
         * @param {number} [perPage] The number of results per page.
         * @param {number} [page] The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElements: async (searchString?: string, kind?: GetLibraryElementsKindEnum, sortDirection?: GetLibraryElementsSortDirectionEnum, typeFilter?: string, excludeUid?: string, folderFilter?: string, perPage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/library-elements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }

            if (typeFilter !== undefined) {
                localVarQueryParameter['typeFilter'] = typeFilter;
            }

            if (excludeUid !== undefined) {
                localVarQueryParameter['excludeUid'] = excludeUid;
            }

            if (folderFilter !== undefined) {
                localVarQueryParameter['folderFilter'] = folderFilter;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing library element identified by uid.
         * @summary Update library element.
         * @param {string} libraryElementUid 
         * @param {PatchLibraryElementCommand} patchLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryElement: async (libraryElementUid: string, patchLibraryElementCommand: PatchLibraryElementCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'libraryElementUid' is not null or undefined
            assertParamExists('updateLibraryElement', 'libraryElementUid', libraryElementUid)
            // verify required parameter 'patchLibraryElementCommand' is not null or undefined
            assertParamExists('updateLibraryElement', 'patchLibraryElementCommand', patchLibraryElementCommand)
            const localVarPath = `/library-elements/{library_element_uid}`
                .replace(`{${"library_element_uid"}}`, encodeURIComponent(String(libraryElementUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchLibraryElementCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LibraryElementsApi - functional programming interface
 * @export
 */
export const LibraryElementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LibraryElementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new library element.
         * @summary Create library element.
         * @param {CreateLibraryElementCommand} createLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLibraryElement(createLibraryElementCommand: CreateLibraryElementCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLibraryElement(createLibraryElementCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.createLibraryElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
         * @summary Delete library element.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLibraryElementByUID(libraryElementUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.deleteLibraryElementByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a library element with the given name.
         * @summary Get library element by name.
         * @param {string} libraryElementName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryElementByName(libraryElementName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryElementByName(libraryElementName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.getLibraryElementByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a library element with the given UID.
         * @summary Get library element by UID.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryElementByUID(libraryElementUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.getLibraryElementByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of connections for a library element based on the UID specified.
         * @summary Get library element connections.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryElementConnections(libraryElementUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementConnectionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryElementConnections(libraryElementUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.getLibraryElementConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
         * @summary Get all library elements.
         * @param {string} [searchString] Part of the name or description searched for.
         * @param {GetLibraryElementsKindEnum} [kind] Kind of element to search for.
         * @param {GetLibraryElementsSortDirectionEnum} [sortDirection] Sort order of elements.
         * @param {string} [typeFilter] A comma separated list of types to filter the elements by
         * @param {string} [excludeUid] Element UID to exclude from search results.
         * @param {string} [folderFilter] A comma separated list of folder ID(s) to filter the elements by.
         * @param {number} [perPage] The number of results per page.
         * @param {number} [page] The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLibraryElements(searchString?: string, kind?: GetLibraryElementsKindEnum, sortDirection?: GetLibraryElementsSortDirectionEnum, typeFilter?: string, excludeUid?: string, folderFilter?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLibraryElements(searchString, kind, sortDirection, typeFilter, excludeUid, folderFilter, perPage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.getLibraryElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing library element identified by uid.
         * @summary Update library element.
         * @param {string} libraryElementUid 
         * @param {PatchLibraryElementCommand} patchLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLibraryElement(libraryElementUid: string, patchLibraryElementCommand: PatchLibraryElementCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LibraryElementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLibraryElement(libraryElementUid, patchLibraryElementCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LibraryElementsApi.updateLibraryElement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LibraryElementsApi - factory interface
 * @export
 */
export const LibraryElementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LibraryElementsApiFp(configuration)
    return {
        /**
         * Creates a new library element.
         * @summary Create library element.
         * @param {CreateLibraryElementCommand} createLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLibraryElement(createLibraryElementCommand: CreateLibraryElementCommand, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementResponse> {
            return localVarFp.createLibraryElement(createLibraryElementCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
         * @summary Delete library element.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteLibraryElementByUID(libraryElementUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a library element with the given name.
         * @summary Get library element by name.
         * @param {string} libraryElementName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementByName(libraryElementName: string, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementArrayResponse> {
            return localVarFp.getLibraryElementByName(libraryElementName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a library element with the given UID.
         * @summary Get library element by UID.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementResponse> {
            return localVarFp.getLibraryElementByUID(libraryElementUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of connections for a library element based on the UID specified.
         * @summary Get library element connections.
         * @param {string} libraryElementUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElementConnections(libraryElementUid: string, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementConnectionsResponse> {
            return localVarFp.getLibraryElementConnections(libraryElementUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
         * @summary Get all library elements.
         * @param {string} [searchString] Part of the name or description searched for.
         * @param {GetLibraryElementsKindEnum} [kind] Kind of element to search for.
         * @param {GetLibraryElementsSortDirectionEnum} [sortDirection] Sort order of elements.
         * @param {string} [typeFilter] A comma separated list of types to filter the elements by
         * @param {string} [excludeUid] Element UID to exclude from search results.
         * @param {string} [folderFilter] A comma separated list of folder ID(s) to filter the elements by.
         * @param {number} [perPage] The number of results per page.
         * @param {number} [page] The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLibraryElements(searchString?: string, kind?: GetLibraryElementsKindEnum, sortDirection?: GetLibraryElementsSortDirectionEnum, typeFilter?: string, excludeUid?: string, folderFilter?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementSearchResponse> {
            return localVarFp.getLibraryElements(searchString, kind, sortDirection, typeFilter, excludeUid, folderFilter, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing library element identified by uid.
         * @summary Update library element.
         * @param {string} libraryElementUid 
         * @param {PatchLibraryElementCommand} patchLibraryElementCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLibraryElement(libraryElementUid: string, patchLibraryElementCommand: PatchLibraryElementCommand, options?: RawAxiosRequestConfig): AxiosPromise<LibraryElementResponse> {
            return localVarFp.updateLibraryElement(libraryElementUid, patchLibraryElementCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LibraryElementsApi - object-oriented interface
 * @export
 * @class LibraryElementsApi
 * @extends {BaseAPI}
 */
export class LibraryElementsApi extends BaseAPI {
    /**
     * Creates a new library element.
     * @summary Create library element.
     * @param {CreateLibraryElementCommand} createLibraryElementCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public createLibraryElement(createLibraryElementCommand: CreateLibraryElementCommand, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).createLibraryElement(createLibraryElementCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing library element as specified by the UID. This operation cannot be reverted. You cannot delete a library element that is connected. This operation cannot be reverted.
     * @summary Delete library element.
     * @param {string} libraryElementUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public deleteLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).deleteLibraryElementByUID(libraryElementUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a library element with the given name.
     * @summary Get library element by name.
     * @param {string} libraryElementName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public getLibraryElementByName(libraryElementName: string, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).getLibraryElementByName(libraryElementName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a library element with the given UID.
     * @summary Get library element by UID.
     * @param {string} libraryElementUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public getLibraryElementByUID(libraryElementUid: string, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).getLibraryElementByUID(libraryElementUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of connections for a library element based on the UID specified.
     * @summary Get library element connections.
     * @param {string} libraryElementUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public getLibraryElementConnections(libraryElementUid: string, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).getLibraryElementConnections(libraryElementUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all library elements the authenticated user has permission to view. Use the `perPage` query parameter to control the maximum number of library elements returned; the default limit is `100`. You can also use the `page` query parameter to fetch library elements from any page other than the first one.
     * @summary Get all library elements.
     * @param {string} [searchString] Part of the name or description searched for.
     * @param {GetLibraryElementsKindEnum} [kind] Kind of element to search for.
     * @param {GetLibraryElementsSortDirectionEnum} [sortDirection] Sort order of elements.
     * @param {string} [typeFilter] A comma separated list of types to filter the elements by
     * @param {string} [excludeUid] Element UID to exclude from search results.
     * @param {string} [folderFilter] A comma separated list of folder ID(s) to filter the elements by.
     * @param {number} [perPage] The number of results per page.
     * @param {number} [page] The page for a set of records, given that only perPage records are returned at a time. Numbering starts at 1.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public getLibraryElements(searchString?: string, kind?: GetLibraryElementsKindEnum, sortDirection?: GetLibraryElementsSortDirectionEnum, typeFilter?: string, excludeUid?: string, folderFilter?: string, perPage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).getLibraryElements(searchString, kind, sortDirection, typeFilter, excludeUid, folderFilter, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing library element identified by uid.
     * @summary Update library element.
     * @param {string} libraryElementUid 
     * @param {PatchLibraryElementCommand} patchLibraryElementCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryElementsApi
     */
    public updateLibraryElement(libraryElementUid: string, patchLibraryElementCommand: PatchLibraryElementCommand, options?: RawAxiosRequestConfig) {
        return LibraryElementsApiFp(this.configuration).updateLibraryElement(libraryElementUid, patchLibraryElementCommand, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetLibraryElementsKindEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;
export type GetLibraryElementsKindEnum = typeof GetLibraryElementsKindEnum[keyof typeof GetLibraryElementsKindEnum];
/**
 * @export
 */
export const GetLibraryElementsSortDirectionEnum = {
    Asc: 'alpha-asc',
    Desc: 'alpha-desc'
} as const;
export type GetLibraryElementsSortDirectionEnum = typeof GetLibraryElementsSortDirectionEnum[keyof typeof GetLibraryElementsSortDirectionEnum];


/**
 * LicensingApi - axios parameter creator
 * @export
 */
export const LicensingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLicenseToken: async (deleteTokenCommand: DeleteTokenCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTokenCommand' is not null or undefined
            assertParamExists('deleteLicenseToken', 'deleteTokenCommand', deleteTokenCommand)
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTokenCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsCSV: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/custom-permissions-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsReport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/custom-permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLicenseToken: async (deleteTokenCommand: DeleteTokenCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteTokenCommand' is not null or undefined
            assertParamExists('postLicenseToken', 'deleteTokenCommand', deleteTokenCommand)
            const localVarPath = `/licensing/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteTokenCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRenewLicenseToken: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postRenewLicenseToken', 'body', body)
            const localVarPath = `/licensing/token/renew`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/licensing/refresh-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicensingApi - functional programming interface
 * @export
 */
export const LicensingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicensingApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ErrorResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLicenseToken(deleteTokenCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.deleteLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCustomPermissionsCSV(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPermissionsCSV(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.getCustomPermissionsCSV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getCustomPermissionsReport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomPermissionsReport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.getCustomPermissionsReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.getLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postLicenseToken(deleteTokenCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.postLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRenewLicenseToken(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.postRenewLicenseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshLicenseStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveUserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshLicenseStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LicensingApi.refreshLicenseStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LicensingApi - factory interface
 * @export
 */
export const LicensingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicensingApiFp(configuration)
    return {
        /**
         * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
         * @summary Remove license from database.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): AxiosPromise<ErrorResponseBody> {
            return localVarFp.deleteLicenseToken(deleteTokenCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report in CSV format.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsCSV(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomPermissionsCSV(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing.reports:read`.
         * @summary Get custom permissions report.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getCustomPermissionsReport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCustomPermissionsReport(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Get license token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseToken(options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.getLicenseToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check license availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:update`.
         * @summary Create license token.
         * @param {DeleteTokenCommand} deleteTokenCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.postLicenseToken(deleteTokenCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
         * @summary Manually force license refresh.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postRenewLicenseToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `licensing:read`.
         * @summary Refresh license stats.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshLicenseStats(options?: RawAxiosRequestConfig): AxiosPromise<ActiveUserStats> {
            return localVarFp.refreshLicenseStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicensingApi - object-oriented interface
 * @export
 * @class LicensingApi
 * @extends {BaseAPI}
 */
export class LicensingApi extends BaseAPI {
    /**
     * Removes the license stored in the Grafana database. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:delete`.
     * @summary Remove license from database.
     * @param {DeleteTokenCommand} deleteTokenCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public deleteLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).deleteLicenseToken(deleteTokenCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * @summary Get custom permissions report in CSV format.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public getCustomPermissionsCSV(options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).getCustomPermissionsCSV(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing.reports:read`.
     * @summary Get custom permissions report.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public getCustomPermissionsReport(options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).getCustomPermissionsReport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * @summary Get license token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public getLicenseToken(options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).getLicenseToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check license availability.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:update`.
     * @summary Create license token.
     * @param {DeleteTokenCommand} deleteTokenCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public postLicenseToken(deleteTokenCommand: DeleteTokenCommand, options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).postLicenseToken(deleteTokenCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually ask license issuer for a new token. Available in Grafana Enterprise v7.4+.  You need to have a permission with action `licensing:update`.
     * @summary Manually force license refresh.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public postRenewLicenseToken(body: object, options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).postRenewLicenseToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `licensing:read`.
     * @summary Refresh license stats.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicensingApi
     */
    public refreshLicenseStats(options?: RawAxiosRequestConfig) {
        return LicensingApiFp(this.configuration).refreshLicenseStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MigrationsApi - axios parameter creator
 * @export
 */
export const MigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * TODO: Implement
         * @summary Cancel a snapshot, wherever it is in its processing chain.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSnapshot: async (uid: string, snapshotUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('cancelSnapshot', 'uid', uid)
            // verify required parameter 'snapshotUid' is not null or undefined
            assertParamExists('cancelSnapshot', 'snapshotUid', snapshotUid)
            const localVarPath = `/cloudmigration/migration/{uid}/snapshot/{snapshotUid}/cancel`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"snapshotUid"}}`, encodeURIComponent(String(snapshotUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create gcom access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCloudMigrationToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudmigration/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a migration session.
         * @param {CloudMigrationSessionRequestDTO} cloudMigrationSessionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession: async (cloudMigrationSessionRequestDTO: CloudMigrationSessionRequestDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudMigrationSessionRequestDTO' is not null or undefined
            assertParamExists('createSession', 'cloudMigrationSessionRequestDTO', cloudMigrationSessionRequestDTO)
            const localVarPath = `/cloudmigration/migration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudMigrationSessionRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the snapshot initialization is successful, the snapshot uid is returned.
         * @summary Trigger the creation of an instance snapshot associated with the provided session.
         * @param {string} uid UID of a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('createSnapshot', 'uid', uid)
            const localVarPath = `/cloudmigration/migration/{uid}/snapshot`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a cloud migration token.
         * @param {string} uid UID of a cloud migration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCloudMigrationToken: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteCloudMigrationToken', 'uid', uid)
            const localVarPath = `/cloudmigration/token/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteSession', 'uid', uid)
            const localVarPath = `/cloudmigration/migration/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch the cloud migration token if it exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudMigrationToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudmigration/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a cloud migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSession', 'uid', uid)
            const localVarPath = `/cloudmigration/migration/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of all cloud migration sessions that have been created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cloudmigration/migration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of snapshots for a session.
         * @param {string} uid Session UID of a session
         * @param {number} [page] Page is used for pagination with limit
         * @param {number} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShapshotList: async (uid: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getShapshotList', 'uid', uid)
            const localVarPath = `/cloudmigration/migration/{uid}/snapshots`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metadata about a snapshot, including where it is in its processing and final results.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {number} [resultPage] ResultPage is used for pagination with ResultLimit
         * @param {number} [resultLimit] Max limit for snapshot results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot: async (uid: string, snapshotUid: string, resultPage?: number, resultLimit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getSnapshot', 'uid', uid)
            // verify required parameter 'snapshotUid' is not null or undefined
            assertParamExists('getSnapshot', 'snapshotUid', snapshotUid)
            const localVarPath = `/cloudmigration/migration/{uid}/snapshot/{snapshotUid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"snapshotUid"}}`, encodeURIComponent(String(snapshotUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (resultPage !== undefined) {
                localVarQueryParameter['resultPage'] = resultPage;
            }

            if (resultLimit !== undefined) {
                localVarQueryParameter['resultLimit'] = resultLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a snapshot to the Grafana Migration Service for processing.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSnapshot: async (uid: string, snapshotUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('uploadSnapshot', 'uid', uid)
            // verify required parameter 'snapshotUid' is not null or undefined
            assertParamExists('uploadSnapshot', 'snapshotUid', snapshotUid)
            const localVarPath = `/cloudmigration/migration/{uid}/snapshot/{snapshotUid}/upload`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"snapshotUid"}}`, encodeURIComponent(String(snapshotUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MigrationsApi - functional programming interface
 * @export
 */
export const MigrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MigrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * TODO: Implement
         * @summary Cancel a snapshot, wherever it is in its processing chain.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSnapshot(uid, snapshotUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.cancelSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create gcom access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCloudMigrationToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAccessTokenResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCloudMigrationToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.createCloudMigrationToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a migration session.
         * @param {CloudMigrationSessionRequestDTO} cloudMigrationSessionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSession(cloudMigrationSessionRequestDTO: CloudMigrationSessionRequestDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudMigrationSessionResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSession(cloudMigrationSessionRequestDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.createSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If the snapshot initialization is successful, the snapshot uid is returned.
         * @summary Trigger the creation of an instance snapshot associated with the provided session.
         * @param {string} uid UID of a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSnapshot(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSnapshotResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSnapshot(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.createSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a cloud migration token.
         * @param {string} uid UID of a cloud migration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCloudMigrationToken(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCloudMigrationToken(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.deleteCloudMigrationToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSession(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSession(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.deleteSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch the cloud migration token if it exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCloudMigrationToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessTokenResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCloudMigrationToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getCloudMigrationToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a cloud migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSession(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudMigrationSessionResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSession(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of all cloud migration sessions that have been created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudMigrationSessionListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getSessionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a list of snapshots for a session.
         * @param {string} uid Session UID of a session
         * @param {number} [page] Page is used for pagination with limit
         * @param {number} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShapshotList(uid: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotListResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShapshotList(uid, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getShapshotList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get metadata about a snapshot, including where it is in its processing and final results.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {number} [resultPage] ResultPage is used for pagination with ResultLimit
         * @param {number} [resultLimit] Max limit for snapshot results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSnapshot(uid: string, snapshotUid: string, resultPage?: number, resultLimit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSnapshotResponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSnapshot(uid, snapshotUid, resultPage, resultLimit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a snapshot to the Grafana Migration Service for processing.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSnapshot(uid, snapshotUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.uploadSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MigrationsApi - factory interface
 * @export
 */
export const MigrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MigrationsApiFp(configuration)
    return {
        /**
         * TODO: Implement
         * @summary Cancel a snapshot, wherever it is in its processing chain.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelSnapshot(uid, snapshotUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create gcom access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCloudMigrationToken(options?: RawAxiosRequestConfig): AxiosPromise<CreateAccessTokenResponseDTO> {
            return localVarFp.createCloudMigrationToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a migration session.
         * @param {CloudMigrationSessionRequestDTO} cloudMigrationSessionRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSession(cloudMigrationSessionRequestDTO: CloudMigrationSessionRequestDTO, options?: RawAxiosRequestConfig): AxiosPromise<CloudMigrationSessionResponseDTO> {
            return localVarFp.createSession(cloudMigrationSessionRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * If the snapshot initialization is successful, the snapshot uid is returned.
         * @summary Trigger the creation of an instance snapshot associated with the provided session.
         * @param {string} uid UID of a session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSnapshot(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<CreateSnapshotResponseDTO> {
            return localVarFp.createSnapshot(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a cloud migration token.
         * @param {string} uid UID of a cloud migration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCloudMigrationToken(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCloudMigrationToken(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSession(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch the cloud migration token if it exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCloudMigrationToken(options?: RawAxiosRequestConfig): AxiosPromise<GetAccessTokenResponseDTO> {
            return localVarFp.getCloudMigrationToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a cloud migration session by its uid.
         * @param {string} uid UID of a migration session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<CloudMigrationSessionResponseDTO> {
            return localVarFp.getSession(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of all cloud migration sessions that have been created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionList(options?: RawAxiosRequestConfig): AxiosPromise<CloudMigrationSessionListResponseDTO> {
            return localVarFp.getSessionList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of snapshots for a session.
         * @param {string} uid Session UID of a session
         * @param {number} [page] Page is used for pagination with limit
         * @param {number} [limit] Max limit for results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShapshotList(uid: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SnapshotListResponseDTO> {
            return localVarFp.getShapshotList(uid, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metadata about a snapshot, including where it is in its processing and final results.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {number} [resultPage] ResultPage is used for pagination with ResultLimit
         * @param {number} [resultLimit] Max limit for snapshot results returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSnapshot(uid: string, snapshotUid: string, resultPage?: number, resultLimit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetSnapshotResponseDTO> {
            return localVarFp.getSnapshot(uid, snapshotUid, resultPage, resultLimit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a snapshot to the Grafana Migration Service for processing.
         * @param {string} uid Session UID of a session
         * @param {string} snapshotUid UID of a snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadSnapshot(uid, snapshotUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MigrationsApi - object-oriented interface
 * @export
 * @class MigrationsApi
 * @extends {BaseAPI}
 */
export class MigrationsApi extends BaseAPI {
    /**
     * TODO: Implement
     * @summary Cancel a snapshot, wherever it is in its processing chain.
     * @param {string} uid Session UID of a session
     * @param {string} snapshotUid UID of a snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public cancelSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).cancelSnapshot(uid, snapshotUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create gcom access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public createCloudMigrationToken(options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).createCloudMigrationToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a migration session.
     * @param {CloudMigrationSessionRequestDTO} cloudMigrationSessionRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public createSession(cloudMigrationSessionRequestDTO: CloudMigrationSessionRequestDTO, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).createSession(cloudMigrationSessionRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the snapshot initialization is successful, the snapshot uid is returned.
     * @summary Trigger the creation of an instance snapshot associated with the provided session.
     * @param {string} uid UID of a session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public createSnapshot(uid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).createSnapshot(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a cloud migration token.
     * @param {string} uid UID of a cloud migration token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public deleteCloudMigrationToken(uid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).deleteCloudMigrationToken(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a migration session by its uid.
     * @param {string} uid UID of a migration session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public deleteSession(uid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).deleteSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch the cloud migration token if it exists.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getCloudMigrationToken(options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getCloudMigrationToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a cloud migration session by its uid.
     * @param {string} uid UID of a migration session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getSession(uid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getSession(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of all cloud migration sessions that have been created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getSessionList(options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getSessionList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of snapshots for a session.
     * @param {string} uid Session UID of a session
     * @param {number} [page] Page is used for pagination with limit
     * @param {number} [limit] Max limit for results returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getShapshotList(uid: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getShapshotList(uid, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metadata about a snapshot, including where it is in its processing and final results.
     * @param {string} uid Session UID of a session
     * @param {string} snapshotUid UID of a snapshot
     * @param {number} [resultPage] ResultPage is used for pagination with ResultLimit
     * @param {number} [resultLimit] Max limit for snapshot results returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public getSnapshot(uid: string, snapshotUid: string, resultPage?: number, resultLimit?: number, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getSnapshot(uid, snapshotUid, resultPage, resultLimit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a snapshot to the Grafana Migration Service for processing.
     * @param {string} uid Session UID of a session
     * @param {string} snapshotUid UID of a snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MigrationsApi
     */
    public uploadSnapshot(uid: string, snapshotUid: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).uploadSnapshot(uid, snapshotUid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrgApi - axios parameter creator
 * @export
 */
export const OrgApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgUserToCurrentOrg: async (addOrgUserCommand: AddOrgUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addOrgUserCommand' is not null or undefined
            assertParamExists('addOrgUserToCurrentOrg', 'addOrgUserCommand', addOrgUserCommand)
            const localVarPath = `/org/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrgUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current Organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrg: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get all users within the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsersForCurrentOrg: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
         * @summary Get all users within the current organization (lookup)
         * @param {string} [query] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsersForCurrentOrgLookup: async (query?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org/users/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgUserForCurrentOrg: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeOrgUserForCurrentOrg', 'userId', userId)
            const localVarPath = `/org/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current Organization.
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentOrg: async (updateOrgForm: UpdateOrgForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrgForm' is not null or undefined
            assertParamExists('updateCurrentOrg', 'updateOrgForm', updateOrgForm)
            const localVarPath = `/org`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current Organization\'s address.
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentOrgAddress: async (updateOrgAddressForm: UpdateOrgAddressForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrgAddressForm' is not null or undefined
            assertParamExists('updateCurrentOrgAddress', 'updateOrgAddressForm', updateOrgAddressForm)
            const localVarPath = `/org/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgAddressForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Updates the given user.
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgUserForCurrentOrg: async (userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateOrgUserForCurrentOrg', 'userId', userId)
            // verify required parameter 'updateOrgUserCommand' is not null or undefined
            assertParamExists('updateOrgUserForCurrentOrg', 'updateOrgUserCommand', updateOrgUserCommand)
            const localVarPath = `/org/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgApi - functional programming interface
 * @export
 */
export const OrgApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrgUserToCurrentOrg(addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrgUserToCurrentOrg(addOrgUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.addOrgUserToCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get current Organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentOrg(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgDetailsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentOrg(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.getCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get all users within the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgUsersForCurrentOrg(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgUserDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgUsersForCurrentOrg(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.getOrgUsersForCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
         * @summary Get all users within the current organization (lookup)
         * @param {string} [query] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgUsersForCurrentOrgLookup(query?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserLookupDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgUsersForCurrentOrgLookup(query, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.getOrgUsersForCurrentOrgLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrgUserForCurrentOrg(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrgUserForCurrentOrg(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.removeOrgUserForCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update current Organization.
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentOrg(updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentOrg(updateOrgForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.updateCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update current Organization\'s address.
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrentOrgAddress(updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrentOrgAddress(updateOrgAddressForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.updateCurrentOrgAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Updates the given user.
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgUserForCurrentOrg(userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgUserForCurrentOrg(userId, updateOrgUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgApi.updateOrgUserForCurrentOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrgApi - factory interface
 * @export
 */
export const OrgApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgApiFp(configuration)
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgUserToCurrentOrg(addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addOrgUserToCurrentOrg(addOrgUserCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current Organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrg(options?: RawAxiosRequestConfig): AxiosPromise<OrgDetailsDTO> {
            return localVarFp.getCurrentOrg(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get all users within the current organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsersForCurrentOrg(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrgUserDTO>> {
            return localVarFp.getOrgUsersForCurrentOrg(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
         * @summary Get all users within the current organization (lookup)
         * @param {string} [query] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsersForCurrentOrgLookup(query?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserLookupDTO>> {
            return localVarFp.getOrgUsersForCurrentOrgLookup(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgUserForCurrentOrg(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeOrgUserForCurrentOrg(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current Organization.
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentOrg(updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateCurrentOrg(updateOrgForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current Organization\'s address.
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrentOrgAddress(updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateCurrentOrgAddress(updateOrgAddressForm, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Updates the given user.
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgUserForCurrentOrg(userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrgUserForCurrentOrg(userId, updateOrgUserCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrgApi - object-oriented interface
 * @export
 * @class OrgApi
 * @extends {BaseAPI}
 */
export class OrgApi extends BaseAPI {
    /**
     * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
     * @summary Add a new user to the current organization.
     * @param {AddOrgUserCommand} addOrgUserCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public addOrgUserToCurrentOrg(addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).addOrgUserToCurrentOrg(addOrgUserCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current Organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public getCurrentOrg(options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).getCurrentOrg(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all org users within the current organization. Accessible to users with org admin role. If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
     * @summary Get all users within the current organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public getOrgUsersForCurrentOrg(options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).getOrgUsersForCurrentOrg(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all org users within the current organization, but with less detailed information. Accessible to users with org admin role, admin in any folder or admin of any team. Mainly used by Grafana UI for providing list of users when adding team members and when editing folder/dashboard permissions.
     * @summary Get all users within the current organization (lookup)
     * @param {string} [query] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public getOrgUsersForCurrentOrgLookup(query?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).getOrgUsersForCurrentOrgLookup(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
     * @summary Delete user in current organization.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public removeOrgUserForCurrentOrg(userId: number, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).removeOrgUserForCurrentOrg(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current Organization.
     * @param {UpdateOrgForm} updateOrgForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public updateCurrentOrg(updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).updateCurrentOrg(updateOrgForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current Organization\'s address.
     * @param {UpdateOrgAddressForm} updateOrgAddressForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public updateCurrentOrgAddress(updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).updateCurrentOrgAddress(updateOrgAddressForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
     * @summary Updates the given user.
     * @param {number} userId 
     * @param {UpdateOrgUserCommand} updateOrgUserCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgApi
     */
    public updateOrgUserForCurrentOrg(userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig) {
        return OrgApiFp(this.configuration).updateOrgUserForCurrentOrg(userId, updateOrgUserCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrgInvitesApi - axios parameter creator
 * @export
 */
export const OrgInvitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add invite.
         * @param {AddInviteForm} addInviteForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgInvite: async (addInviteForm: AddInviteForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addInviteForm' is not null or undefined
            assertParamExists('addOrgInvite', 'addInviteForm', addInviteForm)
            const localVarPath = `/org/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addInviteForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pending invites.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingOrgInvites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke invite.
         * @param {string} invitationCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvite: async (invitationCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invitationCode' is not null or undefined
            assertParamExists('revokeInvite', 'invitationCode', invitationCode)
            const localVarPath = `/org/invites/{invitation_code}/revoke`
                .replace(`{${"invitation_code"}}`, encodeURIComponent(String(invitationCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgInvitesApi - functional programming interface
 * @export
 */
export const OrgInvitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgInvitesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add invite.
         * @param {AddInviteForm} addInviteForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrgInvite(addInviteForm: AddInviteForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrgInvite(addInviteForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgInvitesApi.addOrgInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pending invites.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingOrgInvites(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TempUserDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingOrgInvites(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgInvitesApi.getPendingOrgInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke invite.
         * @param {string} invitationCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeInvite(invitationCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeInvite(invitationCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgInvitesApi.revokeInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrgInvitesApi - factory interface
 * @export
 */
export const OrgInvitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgInvitesApiFp(configuration)
    return {
        /**
         * 
         * @summary Add invite.
         * @param {AddInviteForm} addInviteForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgInvite(addInviteForm: AddInviteForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addOrgInvite(addInviteForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pending invites.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingOrgInvites(options?: RawAxiosRequestConfig): AxiosPromise<Array<TempUserDTO>> {
            return localVarFp.getPendingOrgInvites(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke invite.
         * @param {string} invitationCode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvite(invitationCode: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.revokeInvite(invitationCode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrgInvitesApi - object-oriented interface
 * @export
 * @class OrgInvitesApi
 * @extends {BaseAPI}
 */
export class OrgInvitesApi extends BaseAPI {
    /**
     * 
     * @summary Add invite.
     * @param {AddInviteForm} addInviteForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgInvitesApi
     */
    public addOrgInvite(addInviteForm: AddInviteForm, options?: RawAxiosRequestConfig) {
        return OrgInvitesApiFp(this.configuration).addOrgInvite(addInviteForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pending invites.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgInvitesApi
     */
    public getPendingOrgInvites(options?: RawAxiosRequestConfig) {
        return OrgInvitesApiFp(this.configuration).getPendingOrgInvites(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke invite.
     * @param {string} invitationCode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgInvitesApi
     */
    public revokeInvite(invitationCode: string, options?: RawAxiosRequestConfig) {
        return OrgInvitesApiFp(this.configuration).revokeInvite(invitationCode, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrgPreferencesApi - axios parameter creator
 * @export
 */
export const OrgPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Current Org Prefs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/org/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch Current Org Prefs.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgPreferences: async (patchPrefsCmd: PatchPrefsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchPrefsCmd' is not null or undefined
            assertParamExists('patchOrgPreferences', 'patchPrefsCmd', patchPrefsCmd)
            const localVarPath = `/org/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPrefsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Current Org Prefs.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPreferences: async (updatePrefsCmd: UpdatePrefsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePrefsCmd' is not null or undefined
            assertParamExists('updateOrgPreferences', 'updatePrefsCmd', updatePrefsCmd)
            const localVarPath = `/org/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePrefsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgPreferencesApi - functional programming interface
 * @export
 */
export const OrgPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Current Org Prefs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgPreferencesApi.getOrgPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch Current Org Prefs.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchOrgPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchOrgPreferences(patchPrefsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgPreferencesApi.patchOrgPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Current Org Prefs.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgPreferences(updatePrefsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgPreferencesApi.updateOrgPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrgPreferencesApi - factory interface
 * @export
 */
export const OrgPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgPreferencesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Current Org Prefs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgPreferences(options?: RawAxiosRequestConfig): AxiosPromise<Preferences> {
            return localVarFp.getOrgPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch Current Org Prefs.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchOrgPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.patchOrgPreferences(patchPrefsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Current Org Prefs.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrgPreferences(updatePrefsCmd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrgPreferencesApi - object-oriented interface
 * @export
 * @class OrgPreferencesApi
 * @extends {BaseAPI}
 */
export class OrgPreferencesApi extends BaseAPI {
    /**
     * 
     * @summary Get Current Org Prefs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgPreferencesApi
     */
    public getOrgPreferences(options?: RawAxiosRequestConfig) {
        return OrgPreferencesApiFp(this.configuration).getOrgPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch Current Org Prefs.
     * @param {PatchPrefsCmd} patchPrefsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgPreferencesApi
     */
    public patchOrgPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig) {
        return OrgPreferencesApiFp(this.configuration).patchOrgPreferences(patchPrefsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Current Org Prefs.
     * @param {UpdatePrefsCmd} updatePrefsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgPreferencesApi
     */
    public updateOrgPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig) {
        return OrgPreferencesApiFp(this.configuration).updateOrgPreferences(updatePrefsCmd, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrgsApi - axios parameter creator
 * @export
 */
export const OrgsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {number} orgId 
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgUser: async (orgId: number, addOrgUserCommand: AddOrgUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('addOrgUser', 'orgId', orgId)
            // verify required parameter 'addOrgUserCommand' is not null or undefined
            assertParamExists('addOrgUser', 'addOrgUserCommand', addOrgUserCommand)
            const localVarPath = `/orgs/{org_id}/users`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrgUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
         * @summary Create Organization.
         * @param {CreateOrgCommand} createOrgCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg: async (createOrgCommand: CreateOrgCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrgCommand' is not null or undefined
            assertParamExists('createOrg', 'createOrgCommand', createOrgCommand)
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrgCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgByID: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('deleteOrgByID', 'orgId', orgId)
            const localVarPath = `/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgByID: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getOrgByID', 'orgId', orgId)
            const localVarPath = `/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {string} orgName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgByName: async (orgName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgName' is not null or undefined
            assertParamExists('getOrgByName', 'orgName', orgName)
            const localVarPath = `/orgs/name/{org_name}`
                .replace(`{${"org_name"}}`, encodeURIComponent(String(orgName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgQuota: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getOrgQuota', 'orgId', orgId)
            const localVarPath = `/orgs/{org_id}/quotas`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsers: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('getOrgUsers', 'orgId', orgId)
            const localVarPath = `/orgs/{org_id}/users`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgUser: async (orgId: number, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('removeOrgUser', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeOrgUser', 'userId', userId)
            const localVarPath = `/orgs/{org_id}/users/{user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Search Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgUsers: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('searchOrgUsers', 'orgId', orgId)
            const localVarPath = `/orgs/{org_id}/users/search`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search all Organizations.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgs: async (page?: number, perpage?: number, name?: string, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Organization.
         * @param {number} orgId 
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg: async (orgId: number, updateOrgForm: UpdateOrgForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateOrg', 'orgId', orgId)
            // verify required parameter 'updateOrgForm' is not null or undefined
            assertParamExists('updateOrg', 'updateOrgForm', updateOrgForm)
            const localVarPath = `/orgs/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Organization\'s address.
         * @param {number} orgId 
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgAddress: async (orgId: number, updateOrgAddressForm: UpdateOrgAddressForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateOrgAddress', 'orgId', orgId)
            // verify required parameter 'updateOrgAddressForm' is not null or undefined
            assertParamExists('updateOrgAddress', 'updateOrgAddressForm', updateOrgAddressForm)
            const localVarPath = `/orgs/{org_id}/address`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgAddressForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} orgId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgQuota: async (quotaTarget: string, orgId: number, updateQuotaCmd: UpdateQuotaCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quotaTarget' is not null or undefined
            assertParamExists('updateOrgQuota', 'quotaTarget', quotaTarget)
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateOrgQuota', 'orgId', orgId)
            // verify required parameter 'updateQuotaCmd' is not null or undefined
            assertParamExists('updateOrgQuota', 'updateQuotaCmd', updateQuotaCmd)
            const localVarPath = `/orgs/{org_id}/quotas/{quota_target}`
                .replace(`{${"quota_target"}}`, encodeURIComponent(String(quotaTarget)))
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateQuotaCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Update Users in Organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgUser: async (orgId: number, userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('updateOrgUser', 'orgId', orgId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateOrgUser', 'userId', userId)
            // verify required parameter 'updateOrgUserCommand' is not null or undefined
            assertParamExists('updateOrgUser', 'updateOrgUserCommand', updateOrgUserCommand)
            const localVarPath = `/orgs/{org_id}/users/{user_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrgUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrgsApi - functional programming interface
 * @export
 */
export const OrgsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrgsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {number} orgId 
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrgUser(orgId: number, addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrgUser(orgId, addOrgUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.addOrgUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
         * @summary Create Organization.
         * @param {CreateOrgCommand} createOrgCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrg(createOrgCommand: CreateOrgCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrg200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrg(createOrgCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.createOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrgByID(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrgByID(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.deleteOrgByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgByID(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgDetailsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgByID(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.getOrgByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {string} orgName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgByName(orgName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrgDetailsDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgByName(orgName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.getOrgByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgQuota(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuotaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgQuota(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.getOrgQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgUsers(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgUserDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgUsers(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.getOrgUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrgUser(orgId: number, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrgUser(orgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.removeOrgUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Search Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOrgUsers(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchOrgUsersQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOrgUsers(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.searchOrgUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search all Organizations.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOrgs(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrgDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOrgs(page, perpage, name, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.searchOrgs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Organization.
         * @param {number} orgId 
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrg(orgId: number, updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrg(orgId, updateOrgForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.updateOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Organization\'s address.
         * @param {number} orgId 
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgAddress(orgId: number, updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgAddress(orgId, updateOrgAddressForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.updateOrgAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} orgId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgQuota(quotaTarget: string, orgId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgQuota(quotaTarget, orgId, updateQuotaCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.updateOrgQuota']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Update Users in Organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrgUser(orgId: number, userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrgUser(orgId, userId, updateOrgUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrgsApi.updateOrgUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrgsApi - factory interface
 * @export
 */
export const OrgsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrgsApiFp(configuration)
    return {
        /**
         * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
         * @summary Add a new user to the current organization.
         * @param {number} orgId 
         * @param {AddOrgUserCommand} addOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrgUser(orgId: number, addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addOrgUser(orgId, addOrgUserCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
         * @summary Create Organization.
         * @param {CreateOrgCommand} createOrgCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrg(createOrgCommand: CreateOrgCommand, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrg200Response> {
            return localVarFp.createOrg(createOrgCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrgByID(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteOrgByID(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgByID(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<OrgDetailsDTO> {
            return localVarFp.getOrgByID(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Organization by ID.
         * @param {string} orgName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgByName(orgName: string, options?: RawAxiosRequestConfig): AxiosPromise<OrgDetailsDTO> {
            return localVarFp.getOrgByName(orgName, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
         * @summary Fetch Organization quota.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgQuota(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<QuotaDTO>> {
            return localVarFp.getOrgQuota(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Get Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgUsers(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrgUserDTO>> {
            return localVarFp.getOrgUsers(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
         * @summary Delete user in current organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrgUser(orgId: number, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeOrgUser(orgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
         * @summary Search Users in Organization.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgUsers(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchOrgUsersQueryResult> {
            return localVarFp.searchOrgUsers(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search all Organizations.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgs(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrgDTO>> {
            return localVarFp.searchOrgs(page, perpage, name, query, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Organization.
         * @param {number} orgId 
         * @param {UpdateOrgForm} updateOrgForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrg(orgId: number, updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrg(orgId, updateOrgForm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Organization\'s address.
         * @param {number} orgId 
         * @param {UpdateOrgAddressForm} updateOrgAddressForm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgAddress(orgId: number, updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrgAddress(orgId, updateOrgAddressForm, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
         * @summary Update user quota.
         * @param {string} quotaTarget 
         * @param {number} orgId 
         * @param {UpdateQuotaCmd} updateQuotaCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgQuota(quotaTarget: string, orgId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrgQuota(quotaTarget, orgId, updateQuotaCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
         * @summary Update Users in Organization.
         * @param {number} orgId 
         * @param {number} userId 
         * @param {UpdateOrgUserCommand} updateOrgUserCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrgUser(orgId: number, userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateOrgUser(orgId, userId, updateOrgUserCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrgsApi - object-oriented interface
 * @export
 * @class OrgsApi
 * @extends {BaseAPI}
 */
export class OrgsApi extends BaseAPI {
    /**
     * Adds a global user to the current organization.  If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:add` with scope `users:*`.
     * @summary Add a new user to the current organization.
     * @param {number} orgId 
     * @param {AddOrgUserCommand} addOrgUserCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public addOrgUser(orgId: number, addOrgUserCommand: AddOrgUserCommand, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).addOrgUser(orgId, addOrgUserCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only works if [users.allow_org_create](https://grafana.com/docs/grafana/latest/administration/configuration/#allow_org_create) is set.
     * @summary Create Organization.
     * @param {CreateOrgCommand} createOrgCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public createOrg(createOrgCommand: CreateOrgCommand, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).createOrg(createOrgCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Organization.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public deleteOrgByID(orgId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).deleteOrgByID(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Organization by ID.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgByID(orgId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).getOrgByID(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Organization by ID.
     * @param {string} orgName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgByName(orgName: string, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).getOrgByName(orgName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:read` and scope `org:id:1` (orgIDScope).
     * @summary Fetch Organization quota.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgQuota(orgId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).getOrgQuota(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
     * @summary Get Users in Organization.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public getOrgUsers(orgId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).getOrgUsers(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:remove` with scope `users:*`.
     * @summary Delete user in current organization.
     * @param {number} orgId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public removeOrgUser(orgId: number, userId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).removeOrgUser(orgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users:read` with scope `users:*`.
     * @summary Search Users in Organization.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public searchOrgUsers(orgId: number, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).searchOrgUsers(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search all Organizations.
     * @param {number} [page] 
     * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
     * @param {string} [name] 
     * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public searchOrgs(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).searchOrgs(page, perpage, name, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Organization.
     * @param {number} orgId 
     * @param {UpdateOrgForm} updateOrgForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrg(orgId: number, updateOrgForm: UpdateOrgForm, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).updateOrg(orgId, updateOrgForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Organization\'s address.
     * @param {number} orgId 
     * @param {UpdateOrgAddressForm} updateOrgAddressForm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrgAddress(orgId: number, updateOrgAddressForm: UpdateOrgAddressForm, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).updateOrgAddress(orgId, updateOrgAddressForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled, you need to have a permission with action `orgs.quotas:write` and scope `org:id:1` (orgIDScope).
     * @summary Update user quota.
     * @param {string} quotaTarget 
     * @param {number} orgId 
     * @param {UpdateQuotaCmd} updateQuotaCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrgQuota(quotaTarget: string, orgId: number, updateQuotaCmd: UpdateQuotaCmd, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).updateOrgQuota(quotaTarget, orgId, updateQuotaCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you are running Grafana Enterprise and have Fine-grained access control enabled you need to have a permission with action: `org.users.role:update` with scope `users:*`.
     * @summary Update Users in Organization.
     * @param {number} orgId 
     * @param {number} userId 
     * @param {UpdateOrgUserCommand} updateOrgUserCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrgsApi
     */
    public updateOrgUser(orgId: number, userId: number, updateOrgUserCommand: UpdateOrgUserCommand, options?: RawAxiosRequestConfig) {
        return OrgsApiFp(this.configuration).updateOrgUser(orgId, userId, updateOrgUserCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create playlist.
         * @param {CreatePlaylistCommand} createPlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist: async (createPlaylistCommand: CreatePlaylistCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaylistCommand' is not null or undefined
            assertParamExists('createPlaylist', 'createPlaylistCommand', createPlaylistCommand)
            const localVarPath = `/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlaylistCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deletePlaylist', 'uid', uid)
            const localVarPath = `/playlists/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getPlaylist', 'uid', uid)
            const localVarPath = `/playlists/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get playlist items.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems: async (uid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getPlaylistItems', 'uid', uid)
            const localVarPath = `/playlists/{uid}/items`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get playlists.
         * @param {string} [query] 
         * @param {number} [limit] in:limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlaylists: async (query?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update playlist.
         * @param {string} uid 
         * @param {UpdatePlaylistCommand} updatePlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist: async (uid: string, updatePlaylistCommand: UpdatePlaylistCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updatePlaylist', 'uid', uid)
            // verify required parameter 'updatePlaylistCommand' is not null or undefined
            assertParamExists('updatePlaylist', 'updatePlaylistCommand', updatePlaylistCommand)
            const localVarPath = `/playlists/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePlaylistCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create playlist.
         * @param {CreatePlaylistCommand} createPlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaylist(createPlaylistCommand: CreatePlaylistCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(createPlaylistCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.createPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.deletePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylist(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylist(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.getPlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get playlist items.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistItems(uid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaylistItemDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistItems(uid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.getPlaylistItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get playlists.
         * @param {string} [query] 
         * @param {number} [limit] in:limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlaylists(query?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Playlist>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlaylists(query, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.searchPlaylists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update playlist.
         * @param {string} uid 
         * @param {UpdatePlaylistCommand} updatePlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaylist(uid: string, updatePlaylistCommand: UpdatePlaylistCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaylist(uid, updatePlaylistCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlaylistsApi.updatePlaylist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create playlist.
         * @param {CreatePlaylistCommand} createPlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaylist(createPlaylistCommand: CreatePlaylistCommand, options?: RawAxiosRequestConfig): AxiosPromise<Playlist> {
            return localVarFp.createPlaylist(createPlaylistCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deletePlaylist(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get playlist.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylist(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDTO> {
            return localVarFp.getPlaylist(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get playlist items.
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistItems(uid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<PlaylistItemDTO>> {
            return localVarFp.getPlaylistItems(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get playlists.
         * @param {string} [query] 
         * @param {number} [limit] in:limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlaylists(query?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Playlist>> {
            return localVarFp.searchPlaylists(query, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update playlist.
         * @param {string} uid 
         * @param {UpdatePlaylistCommand} updatePlaylistCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylist(uid: string, updatePlaylistCommand: UpdatePlaylistCommand, options?: RawAxiosRequestConfig): AxiosPromise<PlaylistDTO> {
            return localVarFp.updatePlaylist(uid, updatePlaylistCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @summary Create playlist.
     * @param {CreatePlaylistCommand} createPlaylistCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public createPlaylist(createPlaylistCommand: CreatePlaylistCommand, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).createPlaylist(createPlaylistCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete playlist.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public deletePlaylist(uid: string, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).deletePlaylist(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get playlist.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylist(uid: string, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylist(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get playlist items.
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public getPlaylistItems(uid: string, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylistItems(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get playlists.
     * @param {string} [query] 
     * @param {number} [limit] in:limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public searchPlaylists(query?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).searchPlaylists(query, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update playlist.
     * @param {string} uid 
     * @param {UpdatePlaylistCommand} updatePlaylistCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public updatePlaylist(uid: string, updatePlaylistCommand: UpdatePlaylistCommand, options?: RawAxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).updatePlaylist(uid, updatePlaylistCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvisioningApi - axios parameter creator
 * @export
 */
export const ProvisioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteAlertRule: async (uID: string, xDisableProvenance?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routeDeleteAlertRule', 'uID', uID)
            const localVarPath = `/v1/provisioning/alert-rules/{UID}`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete rule group
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteAlertRuleGroup: async (folderUID: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUID' is not null or undefined
            assertParamExists('routeDeleteAlertRuleGroup', 'folderUID', folderUID)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('routeDeleteAlertRuleGroup', 'group', group)
            const localVarPath = `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`
                .replace(`{${"FolderUID"}}`, encodeURIComponent(String(folderUID)))
                .replace(`{${"Group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteContactpoints: async (uID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routeDeleteContactpoints', 'uID', uID)
            const localVarPath = `/v1/provisioning/contact-points/{UID}`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a mute timing.
         * @param {string} name Mute timing name
         * @param {string} [version] Version of mute timing to use for optimistic concurrency. Leave empty to disable validation
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteMuteTiming: async (name: string, version?: string, xDisableProvenance?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routeDeleteMuteTiming', 'name', name)
            const localVarPath = `/v1/provisioning/mute-timings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a template.
         * @param {string} name Template name
         * @param {string} [version] Version of template to use for optimistic concurrency. Leave empty to disable validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteTemplate: async (name: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routeDeleteTemplate', 'name', name)
            const localVarPath = `/v1/provisioning/templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export a mute timing in provisioning format.
         * @param {string} name Mute timing name
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeExportMuteTiming: async (name: string, download?: boolean, format?: RouteExportMuteTimingFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routeExportMuteTiming', 'name', name)
            const localVarPath = `/v1/provisioning/mute-timings/{name}/export`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export all mute timings in provisioning format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingsFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeExportMuteTimings: async (download?: boolean, format?: RouteExportMuteTimingsFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/mute-timings/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRule: async (uID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routeGetAlertRule', 'uID', uID)
            const localVarPath = `/v1/provisioning/alert-rules/{UID}`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export an alert rule in provisioning file format.
         * @param {string} uID Alert rule UID
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleExport: async (uID: string, download?: boolean, format?: RouteGetAlertRuleExportFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routeGetAlertRuleExport', 'uID', uID)
            const localVarPath = `/v1/provisioning/alert-rules/{UID}/export`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleGroup: async (folderUID: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUID' is not null or undefined
            assertParamExists('routeGetAlertRuleGroup', 'folderUID', folderUID)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('routeGetAlertRuleGroup', 'group', group)
            const localVarPath = `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`
                .replace(`{${"FolderUID"}}`, encodeURIComponent(String(folderUID)))
                .replace(`{${"Group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export an alert rule group in provisioning file format.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleGroupExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleGroupExport: async (folderUID: string, group: string, download?: boolean, format?: RouteGetAlertRuleGroupExportFormatEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUID' is not null or undefined
            assertParamExists('routeGetAlertRuleGroupExport', 'folderUID', folderUID)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('routeGetAlertRuleGroupExport', 'group', group)
            const localVarPath = `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}/export`
                .replace(`{${"FolderUID"}}`, encodeURIComponent(String(folderUID)))
                .replace(`{${"Group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the alert rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/alert-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export all alert rules in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRulesExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {Array<string>} [folderUid] UIDs of folders from which to export rules
         * @param {string} [group] Name of group of rules to export. Must be specified only together with a single folder UID
         * @param {string} [ruleUid] UID of alert rule to export. If specified, parameters folderUid and group must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRulesExport: async (download?: boolean, format?: RouteGetAlertRulesExportFormatEnum, folderUid?: Array<string>, group?: string, ruleUid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/alert-rules/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (folderUid) {
                localVarQueryParameter['folderUid'] = folderUid;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (ruleUid !== undefined) {
                localVarQueryParameter['ruleUid'] = ruleUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the contact points.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetContactpoints: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/contact-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export all contact points in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetContactpointsExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {boolean} [decrypt] Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetContactpointsExport: async (download?: boolean, format?: RouteGetContactpointsExportFormatEnum, decrypt?: boolean, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/contact-points/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (decrypt !== undefined) {
                localVarQueryParameter['decrypt'] = decrypt;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a mute timing.
         * @param {string} name Mute timing name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetMuteTiming: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routeGetMuteTiming', 'name', name)
            const localVarPath = `/v1/provisioning/mute-timings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the mute timings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetMuteTimings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/mute-timings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetPolicyTree: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export the notification policy tree in provisioning file format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetPolicyTreeExport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/policies/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a notification template.
         * @param {string} name Template Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetTemplate: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routeGetTemplate', 'name', name)
            const localVarPath = `/v1/provisioning/templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all notification templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new alert rule.
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostAlertRule: async (xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/alert-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisionedAlertRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a contact point.
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostContactpoints: async (xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/contact-points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddedContactPoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new mute timing.
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostMuteTiming: async (xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/mute-timings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(muteTimeInterval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing alert rule.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutAlertRule: async (uID: string, xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routePutAlertRule', 'uID', uID)
            const localVarPath = `/v1/provisioning/alert-rules/{UID}`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(provisionedAlertRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or update alert rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {string} [xDisableProvenance] 
         * @param {AlertRuleGroup} [alertRuleGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutAlertRuleGroup: async (folderUID: string, group: string, xDisableProvenance?: string, alertRuleGroup?: AlertRuleGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'folderUID' is not null or undefined
            assertParamExists('routePutAlertRuleGroup', 'folderUID', folderUID)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('routePutAlertRuleGroup', 'group', group)
            const localVarPath = `/v1/provisioning/folder/{FolderUID}/rule-groups/{Group}`
                .replace(`{${"FolderUID"}}`, encodeURIComponent(String(folderUID)))
                .replace(`{${"Group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alertRuleGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutContactpoint: async (uID: string, xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uID' is not null or undefined
            assertParamExists('routePutContactpoint', 'uID', uID)
            const localVarPath = `/v1/provisioning/contact-points/{UID}`
                .replace(`{${"UID"}}`, encodeURIComponent(String(uID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(embeddedContactPoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an existing mute timing.
         * @param {string} name Mute timing name
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutMuteTiming: async (name: string, xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routePutMuteTiming', 'name', name)
            const localVarPath = `/v1/provisioning/mute-timings/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(muteTimeInterval, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the notification policy tree.
         * @param {string} [xDisableProvenance] 
         * @param {Route} [route] The new notification routing tree to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutPolicyTree: async (xDisableProvenance?: string, route?: Route, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(route, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing notification template.
         * @param {string} name Template Name
         * @param {string} [xDisableProvenance] 
         * @param {NotificationTemplateContent} [notificationTemplateContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutTemplate: async (name: string, xDisableProvenance?: string, notificationTemplateContent?: NotificationTemplateContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('routePutTemplate', 'name', name)
            const localVarPath = `/v1/provisioning/templates/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (xDisableProvenance != null) {
                localVarHeaderParameter['X-Disable-Provenance'] = String(xDisableProvenance);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notificationTemplateContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clears the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeResetPolicyTree: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvisioningApi - functional programming interface
 * @export
 */
export const ProvisioningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvisioningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeDeleteAlertRule(uID: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteAlertRule(uID, xDisableProvenance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeDeleteAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete rule group
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeDeleteAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteAlertRuleGroup(folderUID, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeDeleteAlertRuleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeDeleteContactpoints(uID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteContactpoints(uID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeDeleteContactpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a mute timing.
         * @param {string} name Mute timing name
         * @param {string} [version] Version of mute timing to use for optimistic concurrency. Leave empty to disable validation
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeDeleteMuteTiming(name: string, version?: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteMuteTiming(name, version, xDisableProvenance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeDeleteMuteTiming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a template.
         * @param {string} name Template name
         * @param {string} [version] Version of template to use for optimistic concurrency. Leave empty to disable validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeDeleteTemplate(name: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeDeleteTemplate(name, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeDeleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export a mute timing in provisioning format.
         * @param {string} name Mute timing name
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeExportMuteTiming(name: string, download?: boolean, format?: RouteExportMuteTimingFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeExportMuteTiming(name, download, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeExportMuteTiming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export all mute timings in provisioning format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingsFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeExportMuteTimings(download?: boolean, format?: RouteExportMuteTimingsFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeExportMuteTimings(download, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeExportMuteTimings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRule(uID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionedAlertRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRule(uID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export an alert rule in provisioning file format.
         * @param {string} uID Alert rule UID
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRuleExport(uID: string, download?: boolean, format?: RouteGetAlertRuleExportFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRuleExport(uID, download, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRuleExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRuleGroup(folderUID, group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRuleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export an alert rule group in provisioning file format.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleGroupExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRuleGroupExport(folderUID: string, group: string, download?: boolean, format?: RouteGetAlertRuleGroupExportFormatEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRuleGroupExport(folderUID, group, download, format, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRuleGroupExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all the alert rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProvisionedAlertRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export all alert rules in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRulesExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {Array<string>} [folderUid] UIDs of folders from which to export rules
         * @param {string} [group] Name of group of rules to export. Must be specified only together with a single folder UID
         * @param {string} [ruleUid] UID of alert rule to export. If specified, parameters folderUid and group must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetAlertRulesExport(download?: boolean, format?: RouteGetAlertRulesExportFormatEnum, folderUid?: Array<string>, group?: string, ruleUid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetAlertRulesExport(download, format, folderUid, group, ruleUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetAlertRulesExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all the contact points.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetContactpoints(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmbeddedContactPoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetContactpoints(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetContactpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export all contact points in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetContactpointsExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {boolean} [decrypt] Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetContactpointsExport(download?: boolean, format?: RouteGetContactpointsExportFormatEnum, decrypt?: boolean, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetContactpointsExport(download, format, decrypt, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetContactpointsExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a mute timing.
         * @param {string} name Mute timing name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetMuteTiming(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteTimeInterval>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetMuteTiming(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetMuteTiming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all the mute timings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetMuteTimings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MuteTimeInterval>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetMuteTimings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetMuteTimings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetPolicyTree(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Route>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetPolicyTree(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetPolicyTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export the notification policy tree in provisioning file format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetPolicyTreeExport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertingFileExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetPolicyTreeExport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetPolicyTreeExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a notification template.
         * @param {string} name Template Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetTemplate(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetTemplate(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all notification templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeGetTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeGetTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeGetTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new alert rule.
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePostAlertRule(xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionedAlertRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePostAlertRule(xDisableProvenance, provisionedAlertRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePostAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a contact point.
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePostContactpoints(xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmbeddedContactPoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePostContactpoints(xDisableProvenance, embeddedContactPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePostContactpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new mute timing.
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePostMuteTiming(xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteTimeInterval>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePostMuteTiming(xDisableProvenance, muteTimeInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePostMuteTiming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing alert rule.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutAlertRule(uID: string, xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProvisionedAlertRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutAlertRule(uID, xDisableProvenance, provisionedAlertRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutAlertRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create or update alert rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {string} [xDisableProvenance] 
         * @param {AlertRuleGroup} [alertRuleGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutAlertRuleGroup(folderUID: string, group: string, xDisableProvenance?: string, alertRuleGroup?: AlertRuleGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertRuleGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutAlertRuleGroup(folderUID, group, xDisableProvenance, alertRuleGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutAlertRuleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutContactpoint(uID: string, xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutContactpoint(uID, xDisableProvenance, embeddedContactPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutContactpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Replace an existing mute timing.
         * @param {string} name Mute timing name
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutMuteTiming(name: string, xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteTimeInterval>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutMuteTiming(name, xDisableProvenance, muteTimeInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutMuteTiming']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sets the notification policy tree.
         * @param {string} [xDisableProvenance] 
         * @param {Route} [route] The new notification routing tree to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutPolicyTree(xDisableProvenance?: string, route?: Route, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutPolicyTree(xDisableProvenance, route, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutPolicyTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an existing notification template.
         * @param {string} name Template Name
         * @param {string} [xDisableProvenance] 
         * @param {NotificationTemplateContent} [notificationTemplateContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routePutTemplate(name: string, xDisableProvenance?: string, notificationTemplateContent?: NotificationTemplateContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routePutTemplate(name, xDisableProvenance, notificationTemplateContent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routePutTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clears the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routeResetPolicyTree(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routeResetPolicyTree(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningApi.routeResetPolicyTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvisioningApi - factory interface
 * @export
 */
export const ProvisioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvisioningApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteAlertRule(uID: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.routeDeleteAlertRule(uID, xDisableProvenance, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete rule group
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.routeDeleteAlertRuleGroup(folderUID, group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteContactpoints(uID: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.routeDeleteContactpoints(uID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a mute timing.
         * @param {string} name Mute timing name
         * @param {string} [version] Version of mute timing to use for optimistic concurrency. Leave empty to disable validation
         * @param {string} [xDisableProvenance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteMuteTiming(name: string, version?: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.routeDeleteMuteTiming(name, version, xDisableProvenance, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a template.
         * @param {string} name Template name
         * @param {string} [version] Version of template to use for optimistic concurrency. Leave empty to disable validation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeDeleteTemplate(name: string, version?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.routeDeleteTemplate(name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export a mute timing in provisioning format.
         * @param {string} name Mute timing name
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeExportMuteTiming(name: string, download?: boolean, format?: RouteExportMuteTimingFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeExportMuteTiming(name, download, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export all mute timings in provisioning format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteExportMuteTimingsFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeExportMuteTimings(download?: boolean, format?: RouteExportMuteTimingsFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeExportMuteTimings(download, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a specific alert rule by UID.
         * @param {string} uID Alert rule UID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRule(uID: string, options?: RawAxiosRequestConfig): AxiosPromise<ProvisionedAlertRule> {
            return localVarFp.routeGetAlertRule(uID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export an alert rule in provisioning file format.
         * @param {string} uID Alert rule UID
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleExport(uID: string, download?: boolean, format?: RouteGetAlertRuleExportFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeGetAlertRuleExport(uID, download, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleGroup> {
            return localVarFp.routeGetAlertRuleGroup(folderUID, group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export an alert rule group in provisioning file format.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRuleGroupExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRuleGroupExport(folderUID: string, group: string, download?: boolean, format?: RouteGetAlertRuleGroupExportFormatEnum, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeGetAlertRuleGroupExport(folderUID, group, download, format, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the alert rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRules(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProvisionedAlertRule>> {
            return localVarFp.routeGetAlertRules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export all alert rules in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetAlertRulesExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {Array<string>} [folderUid] UIDs of folders from which to export rules
         * @param {string} [group] Name of group of rules to export. Must be specified only together with a single folder UID
         * @param {string} [ruleUid] UID of alert rule to export. If specified, parameters folderUid and group must be empty.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetAlertRulesExport(download?: boolean, format?: RouteGetAlertRulesExportFormatEnum, folderUid?: Array<string>, group?: string, ruleUid?: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeGetAlertRulesExport(download, format, folderUid, group, ruleUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the contact points.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetContactpoints(name?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<EmbeddedContactPoint>> {
            return localVarFp.routeGetContactpoints(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export all contact points in provisioning file format.
         * @param {boolean} [download] Whether to initiate a download of the file or not.
         * @param {RouteGetContactpointsExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
         * @param {boolean} [decrypt] Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings.
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetContactpointsExport(download?: boolean, format?: RouteGetContactpointsExportFormatEnum, decrypt?: boolean, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeGetContactpointsExport(download, format, decrypt, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a mute timing.
         * @param {string} name Mute timing name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetMuteTiming(name: string, options?: RawAxiosRequestConfig): AxiosPromise<MuteTimeInterval> {
            return localVarFp.routeGetMuteTiming(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all the mute timings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetMuteTimings(options?: RawAxiosRequestConfig): AxiosPromise<Array<MuteTimeInterval>> {
            return localVarFp.routeGetMuteTimings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetPolicyTree(options?: RawAxiosRequestConfig): AxiosPromise<Route> {
            return localVarFp.routeGetPolicyTree(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export the notification policy tree in provisioning file format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetPolicyTreeExport(options?: RawAxiosRequestConfig): AxiosPromise<AlertingFileExport> {
            return localVarFp.routeGetPolicyTreeExport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a notification template.
         * @param {string} name Template Name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetTemplate(name: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationTemplate> {
            return localVarFp.routeGetTemplate(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all notification templates.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeGetTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationTemplate>> {
            return localVarFp.routeGetTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new alert rule.
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostAlertRule(xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig): AxiosPromise<ProvisionedAlertRule> {
            return localVarFp.routePostAlertRule(xDisableProvenance, provisionedAlertRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a contact point.
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostContactpoints(xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig): AxiosPromise<EmbeddedContactPoint> {
            return localVarFp.routePostContactpoints(xDisableProvenance, embeddedContactPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new mute timing.
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePostMuteTiming(xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig): AxiosPromise<MuteTimeInterval> {
            return localVarFp.routePostMuteTiming(xDisableProvenance, muteTimeInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing alert rule.
         * @param {string} uID Alert rule UID
         * @param {string} [xDisableProvenance] 
         * @param {ProvisionedAlertRule} [provisionedAlertRule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutAlertRule(uID: string, xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig): AxiosPromise<ProvisionedAlertRule> {
            return localVarFp.routePutAlertRule(uID, xDisableProvenance, provisionedAlertRule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or update alert rule group.
         * @param {string} folderUID 
         * @param {string} group 
         * @param {string} [xDisableProvenance] 
         * @param {AlertRuleGroup} [alertRuleGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutAlertRuleGroup(folderUID: string, group: string, xDisableProvenance?: string, alertRuleGroup?: AlertRuleGroup, options?: RawAxiosRequestConfig): AxiosPromise<AlertRuleGroup> {
            return localVarFp.routePutAlertRuleGroup(folderUID, group, xDisableProvenance, alertRuleGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing contact point.
         * @param {string} uID UID is the contact point unique identifier
         * @param {string} [xDisableProvenance] 
         * @param {EmbeddedContactPoint} [embeddedContactPoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutContactpoint(uID: string, xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.routePutContactpoint(uID, xDisableProvenance, embeddedContactPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace an existing mute timing.
         * @param {string} name Mute timing name
         * @param {string} [xDisableProvenance] 
         * @param {MuteTimeInterval} [muteTimeInterval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutMuteTiming(name: string, xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig): AxiosPromise<MuteTimeInterval> {
            return localVarFp.routePutMuteTiming(name, xDisableProvenance, muteTimeInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the notification policy tree.
         * @param {string} [xDisableProvenance] 
         * @param {Route} [route] The new notification routing tree to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutPolicyTree(xDisableProvenance?: string, route?: Route, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.routePutPolicyTree(xDisableProvenance, route, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an existing notification template.
         * @param {string} name Template Name
         * @param {string} [xDisableProvenance] 
         * @param {NotificationTemplateContent} [notificationTemplateContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routePutTemplate(name: string, xDisableProvenance?: string, notificationTemplateContent?: NotificationTemplateContent, options?: RawAxiosRequestConfig): AxiosPromise<NotificationTemplate> {
            return localVarFp.routePutTemplate(name, xDisableProvenance, notificationTemplateContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clears the notification policy tree.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routeResetPolicyTree(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.routeResetPolicyTree(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvisioningApi - object-oriented interface
 * @export
 * @class ProvisioningApi
 * @extends {BaseAPI}
 */
export class ProvisioningApi extends BaseAPI {
    /**
     * 
     * @summary Delete a specific alert rule by UID.
     * @param {string} uID Alert rule UID
     * @param {string} [xDisableProvenance] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeDeleteAlertRule(uID: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeDeleteAlertRule(uID, xDisableProvenance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete rule group
     * @param {string} folderUID 
     * @param {string} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeDeleteAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeDeleteAlertRuleGroup(folderUID, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a contact point.
     * @param {string} uID UID is the contact point unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeDeleteContactpoints(uID: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeDeleteContactpoints(uID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a mute timing.
     * @param {string} name Mute timing name
     * @param {string} [version] Version of mute timing to use for optimistic concurrency. Leave empty to disable validation
     * @param {string} [xDisableProvenance] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeDeleteMuteTiming(name: string, version?: string, xDisableProvenance?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeDeleteMuteTiming(name, version, xDisableProvenance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a template.
     * @param {string} name Template name
     * @param {string} [version] Version of template to use for optimistic concurrency. Leave empty to disable validation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeDeleteTemplate(name: string, version?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeDeleteTemplate(name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export a mute timing in provisioning format.
     * @param {string} name Mute timing name
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteExportMuteTimingFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeExportMuteTiming(name: string, download?: boolean, format?: RouteExportMuteTimingFormatEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeExportMuteTiming(name, download, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export all mute timings in provisioning format.
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteExportMuteTimingsFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeExportMuteTimings(download?: boolean, format?: RouteExportMuteTimingsFormatEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeExportMuteTimings(download, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a specific alert rule by UID.
     * @param {string} uID Alert rule UID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRule(uID: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRule(uID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export an alert rule in provisioning file format.
     * @param {string} uID Alert rule UID
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteGetAlertRuleExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRuleExport(uID: string, download?: boolean, format?: RouteGetAlertRuleExportFormatEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRuleExport(uID, download, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a rule group.
     * @param {string} folderUID 
     * @param {string} group 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRuleGroup(folderUID: string, group: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRuleGroup(folderUID, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export an alert rule group in provisioning file format.
     * @param {string} folderUID 
     * @param {string} group 
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteGetAlertRuleGroupExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRuleGroupExport(folderUID: string, group: string, download?: boolean, format?: RouteGetAlertRuleGroupExportFormatEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRuleGroupExport(folderUID, group, download, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the alert rules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRules(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export all alert rules in provisioning file format.
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteGetAlertRulesExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {Array<string>} [folderUid] UIDs of folders from which to export rules
     * @param {string} [group] Name of group of rules to export. Must be specified only together with a single folder UID
     * @param {string} [ruleUid] UID of alert rule to export. If specified, parameters folderUid and group must be empty.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetAlertRulesExport(download?: boolean, format?: RouteGetAlertRulesExportFormatEnum, folderUid?: Array<string>, group?: string, ruleUid?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetAlertRulesExport(download, format, folderUid, group, ruleUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the contact points.
     * @param {string} [name] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetContactpoints(name?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetContactpoints(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export all contact points in provisioning file format.
     * @param {boolean} [download] Whether to initiate a download of the file or not.
     * @param {RouteGetContactpointsExportFormatEnum} [format] Format of the downloaded file. Supported yaml, json or hcl. Accept header can also be used, but the query parameter will take precedence.
     * @param {boolean} [decrypt] Whether any contained secure settings should be decrypted or left redacted. Redacted settings will contain RedactedValue instead. Currently, only org admin can view decrypted secure settings.
     * @param {string} [name] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetContactpointsExport(download?: boolean, format?: RouteGetContactpointsExportFormatEnum, decrypt?: boolean, name?: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetContactpointsExport(download, format, decrypt, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a mute timing.
     * @param {string} name Mute timing name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetMuteTiming(name: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetMuteTiming(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all the mute timings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetMuteTimings(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetMuteTimings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the notification policy tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetPolicyTree(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetPolicyTree(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export the notification policy tree in provisioning file format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetPolicyTreeExport(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetPolicyTreeExport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a notification template.
     * @param {string} name Template Name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetTemplate(name: string, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetTemplate(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all notification templates.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeGetTemplates(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeGetTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new alert rule.
     * @param {string} [xDisableProvenance] 
     * @param {ProvisionedAlertRule} [provisionedAlertRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePostAlertRule(xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePostAlertRule(xDisableProvenance, provisionedAlertRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a contact point.
     * @param {string} [xDisableProvenance] 
     * @param {EmbeddedContactPoint} [embeddedContactPoint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePostContactpoints(xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePostContactpoints(xDisableProvenance, embeddedContactPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new mute timing.
     * @param {string} [xDisableProvenance] 
     * @param {MuteTimeInterval} [muteTimeInterval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePostMuteTiming(xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePostMuteTiming(xDisableProvenance, muteTimeInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing alert rule.
     * @param {string} uID Alert rule UID
     * @param {string} [xDisableProvenance] 
     * @param {ProvisionedAlertRule} [provisionedAlertRule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutAlertRule(uID: string, xDisableProvenance?: string, provisionedAlertRule?: ProvisionedAlertRule, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutAlertRule(uID, xDisableProvenance, provisionedAlertRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or update alert rule group.
     * @param {string} folderUID 
     * @param {string} group 
     * @param {string} [xDisableProvenance] 
     * @param {AlertRuleGroup} [alertRuleGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutAlertRuleGroup(folderUID: string, group: string, xDisableProvenance?: string, alertRuleGroup?: AlertRuleGroup, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutAlertRuleGroup(folderUID, group, xDisableProvenance, alertRuleGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing contact point.
     * @param {string} uID UID is the contact point unique identifier
     * @param {string} [xDisableProvenance] 
     * @param {EmbeddedContactPoint} [embeddedContactPoint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutContactpoint(uID: string, xDisableProvenance?: string, embeddedContactPoint?: EmbeddedContactPoint, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutContactpoint(uID, xDisableProvenance, embeddedContactPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace an existing mute timing.
     * @param {string} name Mute timing name
     * @param {string} [xDisableProvenance] 
     * @param {MuteTimeInterval} [muteTimeInterval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutMuteTiming(name: string, xDisableProvenance?: string, muteTimeInterval?: MuteTimeInterval, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutMuteTiming(name, xDisableProvenance, muteTimeInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the notification policy tree.
     * @param {string} [xDisableProvenance] 
     * @param {Route} [route] The new notification routing tree to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutPolicyTree(xDisableProvenance?: string, route?: Route, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutPolicyTree(xDisableProvenance, route, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an existing notification template.
     * @param {string} name Template Name
     * @param {string} [xDisableProvenance] 
     * @param {NotificationTemplateContent} [notificationTemplateContent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routePutTemplate(name: string, xDisableProvenance?: string, notificationTemplateContent?: NotificationTemplateContent, options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routePutTemplate(name, xDisableProvenance, notificationTemplateContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clears the notification policy tree.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningApi
     */
    public routeResetPolicyTree(options?: RawAxiosRequestConfig) {
        return ProvisioningApiFp(this.configuration).routeResetPolicyTree(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RouteExportMuteTimingFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteExportMuteTimingFormatEnum = typeof RouteExportMuteTimingFormatEnum[keyof typeof RouteExportMuteTimingFormatEnum];
/**
 * @export
 */
export const RouteExportMuteTimingsFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteExportMuteTimingsFormatEnum = typeof RouteExportMuteTimingsFormatEnum[keyof typeof RouteExportMuteTimingsFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRuleExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRuleExportFormatEnum = typeof RouteGetAlertRuleExportFormatEnum[keyof typeof RouteGetAlertRuleExportFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRuleGroupExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRuleGroupExportFormatEnum = typeof RouteGetAlertRuleGroupExportFormatEnum[keyof typeof RouteGetAlertRuleGroupExportFormatEnum];
/**
 * @export
 */
export const RouteGetAlertRulesExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetAlertRulesExportFormatEnum = typeof RouteGetAlertRulesExportFormatEnum[keyof typeof RouteGetAlertRulesExportFormatEnum];
/**
 * @export
 */
export const RouteGetContactpointsExportFormatEnum = {
    Yaml: 'yaml',
    Json: 'json',
    Hcl: 'hcl'
} as const;
export type RouteGetContactpointsExportFormatEnum = typeof RouteGetContactpointsExportFormatEnum[keyof typeof RouteGetContactpointsExportFormatEnum];


/**
 * QueryHistoryApi - axios parameter creator
 * @export
 */
export const QueryHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds new query to query history.
         * @summary Add query to query history.
         * @param {CreateQueryInQueryHistoryCommand} createQueryInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery: async (createQueryInQueryHistoryCommand: CreateQueryInQueryHistoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createQueryInQueryHistoryCommand' is not null or undefined
            assertParamExists('createQuery', 'createQueryInQueryHistoryCommand', createQueryInQueryHistoryCommand)
            const localVarPath = `/query-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQueryInQueryHistoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
         * @summary Delete query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuery: async (queryHistoryUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryHistoryUid' is not null or undefined
            assertParamExists('deleteQuery', 'queryHistoryUid', queryHistoryUid)
            const localVarPath = `/query-history/{query_history_uid}`
                .replace(`{${"query_history_uid"}}`, encodeURIComponent(String(queryHistoryUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates comment for query in query history as specified by the UID.
         * @summary Update comment for query in query history.
         * @param {string} queryHistoryUid 
         * @param {PatchQueryCommentInQueryHistoryCommand} patchQueryCommentInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueryComment: async (queryHistoryUid: string, patchQueryCommentInQueryHistoryCommand: PatchQueryCommentInQueryHistoryCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryHistoryUid' is not null or undefined
            assertParamExists('patchQueryComment', 'queryHistoryUid', queryHistoryUid)
            // verify required parameter 'patchQueryCommentInQueryHistoryCommand' is not null or undefined
            assertParamExists('patchQueryComment', 'patchQueryCommentInQueryHistoryCommand', patchQueryCommentInQueryHistoryCommand)
            const localVarPath = `/query-history/{query_history_uid}`
                .replace(`{${"query_history_uid"}}`, encodeURIComponent(String(queryHistoryUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchQueryCommentInQueryHistoryCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
         * @summary Query history search.
         * @param {Array<string>} [datasourceUid] List of data source UIDs to search for
         * @param {string} [searchString] Text inside query or comments that is searched for
         * @param {boolean} [onlyStarred] Flag indicating if only starred queries should be returned
         * @param {SearchQueriesSortEnum} [sort] Sort method
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size.
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [from] From range for the query history search
         * @param {number} [to] To range for the query history search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchQueries: async (datasourceUid?: Array<string>, searchString?: string, onlyStarred?: boolean, sort?: SearchQueriesSortEnum, page?: number, limit?: number, from?: number, to?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/query-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (datasourceUid) {
                localVarQueryParameter['datasourceUid'] = datasourceUid;
            }

            if (searchString !== undefined) {
                localVarQueryParameter['searchString'] = searchString;
            }

            if (onlyStarred !== undefined) {
                localVarQueryParameter['onlyStarred'] = onlyStarred;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds star to query in query history as specified by the UID.
         * @summary Add star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starQuery: async (queryHistoryUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryHistoryUid' is not null or undefined
            assertParamExists('starQuery', 'queryHistoryUid', queryHistoryUid)
            const localVarPath = `/query-history/star/{query_history_uid}`
                .replace(`{${"query_history_uid"}}`, encodeURIComponent(String(queryHistoryUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes star from query in query history as specified by the UID.
         * @summary Remove star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarQuery: async (queryHistoryUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryHistoryUid' is not null or undefined
            assertParamExists('unstarQuery', 'queryHistoryUid', queryHistoryUid)
            const localVarPath = `/query-history/star/{query_history_uid}`
                .replace(`{${"query_history_uid"}}`, encodeURIComponent(String(queryHistoryUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryHistoryApi - functional programming interface
 * @export
 */
export const QueryHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QueryHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds new query to query history.
         * @summary Add query to query history.
         * @param {CreateQueryInQueryHistoryCommand} createQueryInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuery(createQueryInQueryHistoryCommand: CreateQueryInQueryHistoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuery(createQueryInQueryHistoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.createQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
         * @summary Delete query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistoryDeleteQueryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuery(queryHistoryUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.deleteQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates comment for query in query history as specified by the UID.
         * @summary Update comment for query in query history.
         * @param {string} queryHistoryUid 
         * @param {PatchQueryCommentInQueryHistoryCommand} patchQueryCommentInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchQueryComment(queryHistoryUid: string, patchQueryCommentInQueryHistoryCommand: PatchQueryCommentInQueryHistoryCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchQueryComment(queryHistoryUid, patchQueryCommentInQueryHistoryCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.patchQueryComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
         * @summary Query history search.
         * @param {Array<string>} [datasourceUid] List of data source UIDs to search for
         * @param {string} [searchString] Text inside query or comments that is searched for
         * @param {boolean} [onlyStarred] Flag indicating if only starred queries should be returned
         * @param {SearchQueriesSortEnum} [sort] Sort method
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size.
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [from] From range for the query history search
         * @param {number} [to] To range for the query history search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchQueries(datasourceUid?: Array<string>, searchString?: string, onlyStarred?: boolean, sort?: SearchQueriesSortEnum, page?: number, limit?: number, from?: number, to?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistorySearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchQueries(datasourceUid, searchString, onlyStarred, sort, page, limit, from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.searchQueries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds star to query in query history as specified by the UID.
         * @summary Add star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starQuery(queryHistoryUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.starQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes star from query in query history as specified by the UID.
         * @summary Remove star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unstarQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstarQuery(queryHistoryUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QueryHistoryApi.unstarQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QueryHistoryApi - factory interface
 * @export
 */
export const QueryHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QueryHistoryApiFp(configuration)
    return {
        /**
         * Adds new query to query history.
         * @summary Add query to query history.
         * @param {CreateQueryInQueryHistoryCommand} createQueryInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery(createQueryInQueryHistoryCommand: CreateQueryInQueryHistoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistoryResponse> {
            return localVarFp.createQuery(createQueryInQueryHistoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
         * @summary Delete query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistoryDeleteQueryResponse> {
            return localVarFp.deleteQuery(queryHistoryUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates comment for query in query history as specified by the UID.
         * @summary Update comment for query in query history.
         * @param {string} queryHistoryUid 
         * @param {PatchQueryCommentInQueryHistoryCommand} patchQueryCommentInQueryHistoryCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchQueryComment(queryHistoryUid: string, patchQueryCommentInQueryHistoryCommand: PatchQueryCommentInQueryHistoryCommand, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistoryResponse> {
            return localVarFp.patchQueryComment(queryHistoryUid, patchQueryCommentInQueryHistoryCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
         * @summary Query history search.
         * @param {Array<string>} [datasourceUid] List of data source UIDs to search for
         * @param {string} [searchString] Text inside query or comments that is searched for
         * @param {boolean} [onlyStarred] Flag indicating if only starred queries should be returned
         * @param {SearchQueriesSortEnum} [sort] Sort method
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size.
         * @param {number} [limit] Limit the number of returned results
         * @param {number} [from] From range for the query history search
         * @param {number} [to] To range for the query history search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchQueries(datasourceUid?: Array<string>, searchString?: string, onlyStarred?: boolean, sort?: SearchQueriesSortEnum, page?: number, limit?: number, from?: number, to?: number, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistorySearchResponse> {
            return localVarFp.searchQueries(datasourceUid, searchString, onlyStarred, sort, page, limit, from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds star to query in query history as specified by the UID.
         * @summary Add star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistoryResponse> {
            return localVarFp.starQuery(queryHistoryUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes star from query in query history as specified by the UID.
         * @summary Remove star to query in query history.
         * @param {string} queryHistoryUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig): AxiosPromise<QueryHistoryResponse> {
            return localVarFp.unstarQuery(queryHistoryUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryHistoryApi - object-oriented interface
 * @export
 * @class QueryHistoryApi
 * @extends {BaseAPI}
 */
export class QueryHistoryApi extends BaseAPI {
    /**
     * Adds new query to query history.
     * @summary Add query to query history.
     * @param {CreateQueryInQueryHistoryCommand} createQueryInQueryHistoryCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public createQuery(createQueryInQueryHistoryCommand: CreateQueryInQueryHistoryCommand, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).createQuery(createQueryInQueryHistoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an existing query in query history as specified by the UID. This operation cannot be reverted.
     * @summary Delete query in query history.
     * @param {string} queryHistoryUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public deleteQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).deleteQuery(queryHistoryUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates comment for query in query history as specified by the UID.
     * @summary Update comment for query in query history.
     * @param {string} queryHistoryUid 
     * @param {PatchQueryCommentInQueryHistoryCommand} patchQueryCommentInQueryHistoryCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public patchQueryComment(queryHistoryUid: string, patchQueryCommentInQueryHistoryCommand: PatchQueryCommentInQueryHistoryCommand, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).patchQueryComment(queryHistoryUid, patchQueryCommentInQueryHistoryCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of queries in the query history that matches the search criteria. Query history search supports pagination. Use the `limit` parameter to control the maximum number of queries returned; the default limit is 100. You can also use the `page` query parameter to fetch queries from any page other than the first one.
     * @summary Query history search.
     * @param {Array<string>} [datasourceUid] List of data source UIDs to search for
     * @param {string} [searchString] Text inside query or comments that is searched for
     * @param {boolean} [onlyStarred] Flag indicating if only starred queries should be returned
     * @param {SearchQueriesSortEnum} [sort] Sort method
     * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size.
     * @param {number} [limit] Limit the number of returned results
     * @param {number} [from] From range for the query history search
     * @param {number} [to] To range for the query history search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public searchQueries(datasourceUid?: Array<string>, searchString?: string, onlyStarred?: boolean, sort?: SearchQueriesSortEnum, page?: number, limit?: number, from?: number, to?: number, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).searchQueries(datasourceUid, searchString, onlyStarred, sort, page, limit, from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds star to query in query history as specified by the UID.
     * @summary Add star to query in query history.
     * @param {string} queryHistoryUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public starQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).starQuery(queryHistoryUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes star from query in query history as specified by the UID.
     * @summary Remove star to query in query history.
     * @param {string} queryHistoryUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryHistoryApi
     */
    public unstarQuery(queryHistoryUid: string, options?: RawAxiosRequestConfig) {
        return QueryHistoryApiFp(this.configuration).unstarQuery(queryHistoryUid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchQueriesSortEnum = {
    Desc: 'time-desc',
    Asc: 'time-asc'
} as const;
export type SearchQueriesSortEnum = typeof SearchQueriesSortEnum[keyof typeof SearchQueriesSortEnum];


/**
 * RecordingRulesApi - axios parameter creator
 * @export
 */
export const RecordingRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('createRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRuleWriteTarget: async (prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'prometheusRemoteWriteTargetJSON' is not null or undefined
            assertParamExists('createRecordingRuleWriteTarget', 'prometheusRemoteWriteTargetJSON', prometheusRemoteWriteTargetJSON)
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(prometheusRemoteWriteTargetJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRule: async (recordingRuleID: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleID' is not null or undefined
            assertParamExists('deleteRecordingRule', 'recordingRuleID', recordingRuleID)
            const localVarPath = `/recording-rules/{recordingRuleID}`
                .replace(`{${"recordingRuleID"}}`, encodeURIComponent(String(recordingRuleID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRuleWriteTarget: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRuleWriteTarget: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules/writer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordingRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('testCreateRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordingRule: async (recordingRuleJSON: RecordingRuleJSON, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordingRuleJSON' is not null or undefined
            assertParamExists('updateRecordingRule', 'recordingRuleJSON', recordingRuleJSON)
            const localVarPath = `/recording-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordingRuleJSON, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecordingRulesApi - functional programming interface
 * @export
 */
export const RecordingRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecordingRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordingRuleJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.createRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrometheusRemoteWriteTargetJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.createRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingRule(recordingRuleID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.deleteRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRecordingRuleWriteTarget(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.deleteRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PrometheusRemoteWriteTargetJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecordingRuleWriteTarget(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.getRecordingRuleWriteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecordingRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecordingRuleJSON>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecordingRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.listRecordingRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCreateRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.testCreateRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordingRuleJSON>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecordingRule(recordingRuleJSON, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecordingRulesApi.updateRecordingRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecordingRulesApi - factory interface
 * @export
 */
export const RecordingRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecordingRulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a recording rule that is then registered and started.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<RecordingRuleJSON> {
            return localVarFp.createRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * It returns a 422 if there is not an existing prometheus data source configured.
         * @summary Create a remote write target.
         * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig): AxiosPromise<PrometheusRemoteWriteTargetJSON> {
            return localVarFp.createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete removes the rule from the registry and stops it.
         * @param {number} recordingRuleID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRecordingRule(recordingRuleID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete the remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteRecordingRuleWriteTarget(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the prometheus remote write target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig): AxiosPromise<PrometheusRemoteWriteTargetJSON> {
            return localVarFp.getRecordingRuleWriteTarget(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all rules in the database: active or deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordingRules(options?: RawAxiosRequestConfig): AxiosPromise<Array<RecordingRuleJSON>> {
            return localVarFp.listRecordingRules(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test a recording rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.testCreateRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the active status of a rule.
         * @param {RecordingRuleJSON} recordingRuleJSON 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig): AxiosPromise<RecordingRuleJSON> {
            return localVarFp.updateRecordingRule(recordingRuleJSON, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecordingRulesApi - object-oriented interface
 * @export
 * @class RecordingRulesApi
 * @extends {BaseAPI}
 */
export class RecordingRulesApi extends BaseAPI {
    /**
     * 
     * @summary Create a recording rule that is then registered and started.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public createRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).createRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * It returns a 422 if there is not an existing prometheus data source configured.
     * @summary Create a remote write target.
     * @param {PrometheusRemoteWriteTargetJSON} prometheusRemoteWriteTargetJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON: PrometheusRemoteWriteTargetJSON, options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).createRecordingRuleWriteTarget(prometheusRemoteWriteTargetJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete removes the rule from the registry and stops it.
     * @param {number} recordingRuleID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public deleteRecordingRule(recordingRuleID: number, options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).deleteRecordingRule(recordingRuleID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete the remote write target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public deleteRecordingRuleWriteTarget(options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).deleteRecordingRuleWriteTarget(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the prometheus remote write target.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public getRecordingRuleWriteTarget(options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).getRecordingRuleWriteTarget(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all rules in the database: active or deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public listRecordingRules(options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).listRecordingRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test a recording rule.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public testCreateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).testCreateRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the active status of a rule.
     * @param {RecordingRuleJSON} recordingRuleJSON 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecordingRulesApi
     */
    public updateRecordingRule(recordingRuleJSON: RecordingRuleJSON, options?: RawAxiosRequestConfig) {
        return RecordingRulesApiFp(this.configuration).updateRecordingRule(recordingRuleJSON, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('createReport', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReport', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getReport', 'id', id)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsImage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/images/:image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportCSVs: async (dashboards?: string, title?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/render/csvs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dashboards !== undefined) {
                localVarQueryParameter['dashboards'] = dashboards;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportPDFs: async (dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/render/pdfs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (dashboards !== undefined) {
                localVarQueryParameter['dashboards'] = dashboards;
            }

            if (orientation !== undefined) {
                localVarQueryParameter['orientation'] = orientation;
            }

            if (layout !== undefined) {
                localVarQueryParameter['layout'] = layout;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (scaleFactor !== undefined) {
                localVarQueryParameter['scaleFactor'] = scaleFactor;
            }

            if (includeTables !== undefined) {
                localVarQueryParameter['includeTables'] = includeTables;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReportSettings: async (reportSettings: ReportSettings, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportSettings' is not null or undefined
            assertParamExists('saveReportSettings', 'reportSettings', reportSettings)
            const localVarPath = `/reports/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReport: async (reportEmail: ReportEmail, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportEmail' is not null or undefined
            assertParamExists('sendReport', 'reportEmail', reportEmail)
            const localVarPath = `/reports/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportEmail, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail: async (createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('sendTestEmail', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports/test-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport: async (id: number, createOrUpdateReport: CreateOrUpdateReport, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateReport', 'id', id)
            // verify required parameter 'createOrUpdateReport' is not null or undefined
            assertParamExists('updateReport', 'createOrUpdateReport', createOrUpdateReport)
            const localVarPath = `/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrUpdateReport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.createReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.deleteReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReportSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReports(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Report>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReports(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingsImage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSettingsImage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.getSettingsImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderReportCSVs(dashboards, title, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.renderReportCSVs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.renderReportPDFs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveReportSettings(reportSettings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.saveReportSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendReport(reportEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.sendReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendTestEmail(createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.sendTestEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateReport(id, createOrUpdateReport, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportsApi.updateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
         * @summary Create a report.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<CreateReport200Response> {
            return localVarFp.createReport(createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
         * @summary Delete a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(id: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
         * @summary Get a report.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.getReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
         * @summary Get report settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportSettings(options?: RawAxiosRequestConfig): AxiosPromise<ReportSettings> {
            return localVarFp.getReportSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
         * @summary List reports.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(options?: RawAxiosRequestConfig): AxiosPromise<Array<Report>> {
            return localVarFp.getReports(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
         * @summary Get custom branding report image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsImage(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getSettingsImage(options).then((request) => request(axios, basePath));
        },
        /**
         * Available to all users and with a valid license.
         * @summary Download a CSV report.
         * @param {string} [dashboards] 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.renderReportCSVs(dashboards, title, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to all users and with a valid license.
         * @summary Render report for multiple dashboards.
         * @param {string} [dashboards] 
         * @param {string} [orientation] 
         * @param {string} [layout] 
         * @param {string} [title] 
         * @param {string} [scaleFactor] 
         * @param {string} [includeTables] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
         * @summary Save settings.
         * @param {ReportSettings} reportSettings 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.saveReportSettings(reportSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
         * @summary Send a report.
         * @param {ReportEmail} reportEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.sendReport(reportEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
         * @summary Send test report via email.
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.sendTestEmail(createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
        /**
         * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
         * @summary Update a report.
         * @param {number} id 
         * @param {CreateOrUpdateReport} createOrUpdateReport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateReport(id, createOrUpdateReport, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports.admin:create`.
     * @summary Create a report.
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public createReport(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).createReport(createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.delete` with scope `reports:id:<report ID>`.
     * @summary Delete a report.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public deleteReport(id: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).deleteReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:id:<report ID>`.
     * @summary Get a report.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(id: number, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`x.
     * @summary Get report settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportSettings(options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReportSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports:read` with scope `reports:*`.
     * @summary List reports.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReports(options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getReports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:read`.
     * @summary Get custom branding report image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getSettingsImage(options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).getSettingsImage(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to all users and with a valid license.
     * @summary Download a CSV report.
     * @param {string} [dashboards] 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public renderReportCSVs(dashboards?: string, title?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).renderReportCSVs(dashboards, title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to all users and with a valid license.
     * @summary Render report for multiple dashboards.
     * @param {string} [dashboards] 
     * @param {string} [orientation] 
     * @param {string} [layout] 
     * @param {string} [title] 
     * @param {string} [scaleFactor] 
     * @param {string} [includeTables] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public renderReportPDFs(dashboards?: string, orientation?: string, layout?: string, title?: string, scaleFactor?: string, includeTables?: string, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).renderReportPDFs(dashboards, orientation, layout, title, scaleFactor, includeTables, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.settings:write`xx.
     * @summary Save settings.
     * @param {ReportSettings} reportSettings 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public saveReportSettings(reportSettings: ReportSettings, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).saveReportSettings(reportSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate and send a report. This API waits for the report to be generated before returning. We recommend that you set the client’s timeout to at least 60 seconds. Available to org admins only and with a valid license.  Only available in Grafana Enterprise v7.0+. This API endpoint is experimental and may be deprecated in a future release. On deprecation, a migration strategy will be provided and the endpoint will remain functional until the next major release of Grafana.  You need to have a permission with action `reports:send`.
     * @summary Send a report.
     * @param {ReportEmail} reportEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public sendReport(reportEmail: ReportEmail, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).sendReport(reportEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid license.  You need to have a permission with action `reports:send`.
     * @summary Send test report via email.
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public sendTestEmail(createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).sendTestEmail(createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Available to org admins only and with a valid or expired license.  You need to have a permission with action `reports.admin:write` with scope `reports:id:<report ID>`.
     * @summary Update a report.
     * @param {number} id 
     * @param {CreateOrUpdateReport} createOrUpdateReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public updateReport(id: number, createOrUpdateReport: CreateOrUpdateReport, options?: RawAxiosRequestConfig) {
        return ReportsApiFp(this.configuration).updateReport(id, createOrUpdateReport, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SamlApi - axios parameter creator
 * @export
 */
export const SamlApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout/saml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSLO: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/slo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACS: async (relayState?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/acs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (relayState !== undefined) {
                localVarQueryParameter['RelayState'] = relayState;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSLO: async (sAMLRequest?: string, sAMLResponse?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/saml/slo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (sAMLRequest !== undefined) {
                localVarQueryParameter['SAMLRequest'] = sAMLRequest;
            }

            if (sAMLResponse !== undefined) {
                localVarQueryParameter['SAMLResponse'] = sAMLResponse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SamlApi - functional programming interface
 * @export
 */
export const SamlApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SamlApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamlApi.getMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSAMLLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSAMLLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamlApi.getSAMLLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSLO(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSLO(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamlApi.getSLO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postACS(relayState?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postACS(relayState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamlApi.postACS']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSLO(sAMLRequest, sAMLResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SamlApi.postSLO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SamlApi - factory interface
 * @export
 */
export const SamlApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SamlApiFp(configuration)
    return {
        /**
         * 
         * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary GetLogout initiates single logout process.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSAMLLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSAMLLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSLO(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSLO(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary It performs Assertion Consumer Service (ACS).
         * @param {string} [relayState] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postACS(relayState?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postACS(relayState, options).then((request) => request(axios, basePath));
        },
        /**
         * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
         * @summary It performs Single Logout (SLO) callback.
         * @param {string} [sAMLRequest] 
         * @param {string} [sAMLResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postSLO(sAMLRequest, sAMLResponse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SamlApi - object-oriented interface
 * @export
 * @class SamlApi
 * @extends {BaseAPI}
 */
export class SamlApi extends BaseAPI {
    /**
     * 
     * @summary It exposes the SP (Grafana\'s) metadata for the IdP\'s consumption.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamlApi
     */
    public getMetadata(options?: RawAxiosRequestConfig) {
        return SamlApiFp(this.configuration).getMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary GetLogout initiates single logout process.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamlApi
     */
    public getSAMLLogout(options?: RawAxiosRequestConfig) {
        return SamlApiFp(this.configuration).getSAMLLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * @summary It performs Single Logout (SLO) callback.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamlApi
     */
    public getSLO(options?: RawAxiosRequestConfig) {
        return SamlApiFp(this.configuration).getSLO(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary It performs Assertion Consumer Service (ACS).
     * @param {string} [relayState] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamlApi
     */
    public postACS(relayState?: string, options?: RawAxiosRequestConfig) {
        return SamlApiFp(this.configuration).postACS(relayState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * There might be two possible requests: 1. Logout response (callback) when Grafana initiates single logout and IdP returns response to logout request. 2. Logout request when another SP initiates single logout and IdP sends logout request to the Grafana, or in case of IdP-initiated logout.
     * @summary It performs Single Logout (SLO) callback.
     * @param {string} [sAMLRequest] 
     * @param {string} [sAMLResponse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SamlApi
     */
    public postSLO(sAMLRequest?: string, sAMLResponse?: string, options?: RawAxiosRequestConfig) {
        return SamlApiFp(this.configuration).postSLO(sAMLRequest, sAMLResponse, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List search sorting options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSortOptions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/sorting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [query] Search Query
         * @param {Array<string>} [tag] List of tags to search for
         * @param {SearchTypeEnum} [type] Type to search for, dash-folder or dash-db
         * @param {Array<number>} [dashboardIds] List of dashboard id’s to search for This is deprecated: users should use the &#x60;dashboardUIDs&#x60; query parameter instead
         * @param {Array<string>} [dashboardUIDs] List of dashboard uid’s to search for
         * @param {Array<number>} [folderIds] List of folder id’s to search in for dashboards If it\&#39;s &#x60;0&#x60; then it will query for the top level folders This is deprecated: users should use the &#x60;folderUIDs&#x60; query parameter instead
         * @param {Array<string>} [folderUIDs] List of folder UID’s to search in for dashboards If it\&#39;s an empty string then it will query for the top level folders
         * @param {boolean} [starred] Flag indicating if only starred Dashboards should be returned
         * @param {number} [limit] Limit the number of returned results (max 5000)
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+.
         * @param {SearchPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return dashboards/folders that the user can edit
         * @param {SearchSortEnum} [sort] Sort method; for listing all the possible sort methods use the search sorting endpoint.
         * @param {boolean} [deleted] Flag indicating if only soft deleted Dashboards should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (query?: string, tag?: Array<string>, type?: SearchTypeEnum, dashboardIds?: Array<number>, dashboardUIDs?: Array<string>, folderIds?: Array<number>, folderUIDs?: Array<string>, starred?: boolean, limit?: number, page?: number, permission?: SearchPermissionEnum, sort?: SearchSortEnum, deleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (dashboardIds) {
                localVarQueryParameter['dashboardIds'] = dashboardIds;
            }

            if (dashboardUIDs) {
                localVarQueryParameter['dashboardUIDs'] = dashboardUIDs;
            }

            if (folderIds) {
                localVarQueryParameter['folderIds'] = folderIds;
            }

            if (folderUIDs) {
                localVarQueryParameter['folderUIDs'] = folderUIDs;
            }

            if (starred !== undefined) {
                localVarQueryParameter['starred'] = starred;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (permission !== undefined) {
                localVarQueryParameter['permission'] = permission;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List search sorting options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSortOptions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSortOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSortOptions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.listSortOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [query] Search Query
         * @param {Array<string>} [tag] List of tags to search for
         * @param {SearchTypeEnum} [type] Type to search for, dash-folder or dash-db
         * @param {Array<number>} [dashboardIds] List of dashboard id’s to search for This is deprecated: users should use the &#x60;dashboardUIDs&#x60; query parameter instead
         * @param {Array<string>} [dashboardUIDs] List of dashboard uid’s to search for
         * @param {Array<number>} [folderIds] List of folder id’s to search in for dashboards If it\&#39;s &#x60;0&#x60; then it will query for the top level folders This is deprecated: users should use the &#x60;folderUIDs&#x60; query parameter instead
         * @param {Array<string>} [folderUIDs] List of folder UID’s to search in for dashboards If it\&#39;s an empty string then it will query for the top level folders
         * @param {boolean} [starred] Flag indicating if only starred Dashboards should be returned
         * @param {number} [limit] Limit the number of returned results (max 5000)
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+.
         * @param {SearchPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return dashboards/folders that the user can edit
         * @param {SearchSortEnum} [sort] Sort method; for listing all the possible sort methods use the search sorting endpoint.
         * @param {boolean} [deleted] Flag indicating if only soft deleted Dashboards should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(query?: string, tag?: Array<string>, type?: SearchTypeEnum, dashboardIds?: Array<number>, dashboardUIDs?: Array<string>, folderIds?: Array<number>, folderUIDs?: Array<string>, starred?: boolean, limit?: number, page?: number, permission?: SearchPermissionEnum, sort?: SearchSortEnum, deleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(query, tag, type, dashboardIds, dashboardUIDs, folderIds, folderUIDs, starred, limit, page, permission, sort, deleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary List search sorting options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSortOptions(options?: RawAxiosRequestConfig): AxiosPromise<ListSortOptions200Response> {
            return localVarFp.listSortOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [query] Search Query
         * @param {Array<string>} [tag] List of tags to search for
         * @param {SearchTypeEnum} [type] Type to search for, dash-folder or dash-db
         * @param {Array<number>} [dashboardIds] List of dashboard id’s to search for This is deprecated: users should use the &#x60;dashboardUIDs&#x60; query parameter instead
         * @param {Array<string>} [dashboardUIDs] List of dashboard uid’s to search for
         * @param {Array<number>} [folderIds] List of folder id’s to search in for dashboards If it\&#39;s &#x60;0&#x60; then it will query for the top level folders This is deprecated: users should use the &#x60;folderUIDs&#x60; query parameter instead
         * @param {Array<string>} [folderUIDs] List of folder UID’s to search in for dashboards If it\&#39;s an empty string then it will query for the top level folders
         * @param {boolean} [starred] Flag indicating if only starred Dashboards should be returned
         * @param {number} [limit] Limit the number of returned results (max 5000)
         * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+.
         * @param {SearchPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return dashboards/folders that the user can edit
         * @param {SearchSortEnum} [sort] Sort method; for listing all the possible sort methods use the search sorting endpoint.
         * @param {boolean} [deleted] Flag indicating if only soft deleted Dashboards should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(query?: string, tag?: Array<string>, type?: SearchTypeEnum, dashboardIds?: Array<number>, dashboardUIDs?: Array<string>, folderIds?: Array<number>, folderUIDs?: Array<string>, starred?: boolean, limit?: number, page?: number, permission?: SearchPermissionEnum, sort?: SearchSortEnum, deleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Hit>> {
            return localVarFp.search(query, tag, type, dashboardIds, dashboardUIDs, folderIds, folderUIDs, starred, limit, page, permission, sort, deleted, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * 
     * @summary List search sorting options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public listSortOptions(options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).listSortOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [query] Search Query
     * @param {Array<string>} [tag] List of tags to search for
     * @param {SearchTypeEnum} [type] Type to search for, dash-folder or dash-db
     * @param {Array<number>} [dashboardIds] List of dashboard id’s to search for This is deprecated: users should use the &#x60;dashboardUIDs&#x60; query parameter instead
     * @param {Array<string>} [dashboardUIDs] List of dashboard uid’s to search for
     * @param {Array<number>} [folderIds] List of folder id’s to search in for dashboards If it\&#39;s &#x60;0&#x60; then it will query for the top level folders This is deprecated: users should use the &#x60;folderUIDs&#x60; query parameter instead
     * @param {Array<string>} [folderUIDs] List of folder UID’s to search in for dashboards If it\&#39;s an empty string then it will query for the top level folders
     * @param {boolean} [starred] Flag indicating if only starred Dashboards should be returned
     * @param {number} [limit] Limit the number of returned results (max 5000)
     * @param {number} [page] Use this parameter to access hits beyond limit. Numbering starts at 1. limit param acts as page size. Only available in Grafana v6.2+.
     * @param {SearchPermissionEnum} [permission] Set to &#x60;Edit&#x60; to return dashboards/folders that the user can edit
     * @param {SearchSortEnum} [sort] Sort method; for listing all the possible sort methods use the search sorting endpoint.
     * @param {boolean} [deleted] Flag indicating if only soft deleted Dashboards should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(query?: string, tag?: Array<string>, type?: SearchTypeEnum, dashboardIds?: Array<number>, dashboardUIDs?: Array<string>, folderIds?: Array<number>, folderUIDs?: Array<string>, starred?: boolean, limit?: number, page?: number, permission?: SearchPermissionEnum, sort?: SearchSortEnum, deleted?: boolean, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(query, tag, type, dashboardIds, dashboardUIDs, folderIds, folderUIDs, starred, limit, page, permission, sort, deleted, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchTypeEnum = {
    Folder: 'dash-folder',
    Db: 'dash-db'
} as const;
export type SearchTypeEnum = typeof SearchTypeEnum[keyof typeof SearchTypeEnum];
/**
 * @export
 */
export const SearchPermissionEnum = {
    Edit: 'Edit',
    View: 'View'
} as const;
export type SearchPermissionEnum = typeof SearchPermissionEnum[keyof typeof SearchPermissionEnum];
/**
 * @export
 */
export const SearchSortEnum = {
    Asc: 'alpha-asc',
    Desc: 'alpha-desc'
} as const;
export type SearchSortEnum = typeof SearchSortEnum[keyof typeof SearchSortEnum];


/**
 * ServiceAccountsApi - axios parameter creator
 * @export
 */
export const ServiceAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Create service account
         * @param {CreateServiceAccountForm} [createServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount: async (createServiceAccountForm?: CreateServiceAccountForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/serviceaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createServiceAccountForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary CreateNewToken adds a token to a service account
         * @param {number} serviceAccountId 
         * @param {AddServiceAccountTokenCommand} [addServiceAccountTokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken: async (serviceAccountId: number, addServiceAccountTokenCommand?: AddServiceAccountTokenCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('createToken', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}/tokens`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addServiceAccountTokenCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
         * @summary Delete service account
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount: async (serviceAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('deleteServiceAccount', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary DeleteToken deletes service account tokens
         * @param {number} tokenId 
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (tokenId: number, serviceAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('deleteToken', 'tokenId', tokenId)
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('deleteToken', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}/tokens/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Get service account tokens
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens: async (serviceAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('listTokens', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}/tokens`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
         * @summary Get single serviceaccount by Id
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveServiceAccount: async (serviceAccountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('retrieveServiceAccount', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
         * @summary Search service accounts with paging
         * @param {boolean} [disabled] 
         * @param {boolean} [expiredTokens] 
         * @param {string} [query] It will return results where the query value is contained in one of the name. Query values with spaces need to be URL encoded.
         * @param {number} [perpage] The default value is 1000.
         * @param {number} [page] The default value is 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgServiceAccountsWithPaging: async (disabled?: boolean, expiredTokens?: boolean, query?: string, perpage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/serviceaccounts/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (disabled !== undefined) {
                localVarQueryParameter['Disabled'] = disabled;
            }

            if (expiredTokens !== undefined) {
                localVarQueryParameter['expiredTokens'] = expiredTokens;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary Update service account
         * @param {number} serviceAccountId 
         * @param {UpdateServiceAccountForm} [updateServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceAccount: async (serviceAccountId: number, updateServiceAccountForm?: UpdateServiceAccountForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceAccountId' is not null or undefined
            assertParamExists('updateServiceAccount', 'serviceAccountId', serviceAccountId)
            const localVarPath = `/serviceaccounts/{serviceAccountId}`
                .replace(`{${"serviceAccountId"}}`, encodeURIComponent(String(serviceAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateServiceAccountForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceAccountsApi - functional programming interface
 * @export
 */
export const ServiceAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Create service account
         * @param {CreateServiceAccountForm} [createServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createServiceAccount(createServiceAccountForm?: CreateServiceAccountForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createServiceAccount(createServiceAccountForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.createServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary CreateNewToken adds a token to a service account
         * @param {number} serviceAccountId 
         * @param {AddServiceAccountTokenCommand} [addServiceAccountTokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToken(serviceAccountId: number, addServiceAccountTokenCommand?: AddServiceAccountTokenCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewApiKeyResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(serviceAccountId, addServiceAccountTokenCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.createToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
         * @summary Delete service account
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteServiceAccount(serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary DeleteToken deletes service account tokens
         * @param {number} tokenId 
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(tokenId: number, serviceAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(tokenId, serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.deleteToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Get service account tokens
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTokens(serviceAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TokenDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTokens(serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.listTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
         * @summary Get single serviceaccount by Id
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveServiceAccount(serviceAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.retrieveServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
         * @summary Search service accounts with paging
         * @param {boolean} [disabled] 
         * @param {boolean} [expiredTokens] 
         * @param {string} [query] It will return results where the query value is contained in one of the name. Query values with spaces need to be URL encoded.
         * @param {number} [perpage] The default value is 1000.
         * @param {number} [page] The default value is 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchOrgServiceAccountsWithPaging(disabled?: boolean, expiredTokens?: boolean, query?: string, perpage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchOrgServiceAccountsResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchOrgServiceAccountsWithPaging(disabled, expiredTokens, query, perpage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.searchOrgServiceAccountsWithPaging']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary Update service account
         * @param {number} serviceAccountId 
         * @param {UpdateServiceAccountForm} [updateServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateServiceAccount(serviceAccountId: number, updateServiceAccountForm?: UpdateServiceAccountForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateServiceAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceAccount(serviceAccountId, updateServiceAccountForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServiceAccountsApi.updateServiceAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServiceAccountsApi - factory interface
 * @export
 */
export const ServiceAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceAccountsApiFp(configuration)
    return {
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Create service account
         * @param {CreateServiceAccountForm} [createServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createServiceAccount(createServiceAccountForm?: CreateServiceAccountForm, options?: RawAxiosRequestConfig): AxiosPromise<ServiceAccountDTO> {
            return localVarFp.createServiceAccount(createServiceAccountForm, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary CreateNewToken adds a token to a service account
         * @param {number} serviceAccountId 
         * @param {AddServiceAccountTokenCommand} [addServiceAccountTokenCommand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToken(serviceAccountId: number, addServiceAccountTokenCommand?: AddServiceAccountTokenCommand, options?: RawAxiosRequestConfig): AxiosPromise<NewApiKeyResult> {
            return localVarFp.createToken(serviceAccountId, addServiceAccountTokenCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
         * @summary Delete service account
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteServiceAccount(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary DeleteToken deletes service account tokens
         * @param {number} tokenId 
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(tokenId: number, serviceAccountId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteToken(tokenId, serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
         * @summary Get service account tokens
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTokens(serviceAccountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TokenDTO>> {
            return localVarFp.listTokens(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
         * @summary Get single serviceaccount by Id
         * @param {number} serviceAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig): AxiosPromise<ServiceAccountDTO> {
            return localVarFp.retrieveServiceAccount(serviceAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
         * @summary Search service accounts with paging
         * @param {boolean} [disabled] 
         * @param {boolean} [expiredTokens] 
         * @param {string} [query] It will return results where the query value is contained in one of the name. Query values with spaces need to be URL encoded.
         * @param {number} [perpage] The default value is 1000.
         * @param {number} [page] The default value is 1.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchOrgServiceAccountsWithPaging(disabled?: boolean, expiredTokens?: boolean, query?: string, perpage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchOrgServiceAccountsResult> {
            return localVarFp.searchOrgServiceAccountsWithPaging(disabled, expiredTokens, query, perpage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
         * @summary Update service account
         * @param {number} serviceAccountId 
         * @param {UpdateServiceAccountForm} [updateServiceAccountForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateServiceAccount(serviceAccountId: number, updateServiceAccountForm?: UpdateServiceAccountForm, options?: RawAxiosRequestConfig): AxiosPromise<UpdateServiceAccount200Response> {
            return localVarFp.updateServiceAccount(serviceAccountId, updateServiceAccountForm, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceAccountsApi - object-oriented interface
 * @export
 * @class ServiceAccountsApi
 * @extends {BaseAPI}
 */
export class ServiceAccountsApi extends BaseAPI {
    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:*`  Requires basic authentication and that the authenticated user is a Grafana Admin.
     * @summary Create service account
     * @param {CreateServiceAccountForm} [createServiceAccountForm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public createServiceAccount(createServiceAccountForm?: CreateServiceAccountForm, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).createServiceAccount(createServiceAccountForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
     * @summary CreateNewToken adds a token to a service account
     * @param {number} serviceAccountId 
     * @param {AddServiceAccountTokenCommand} [addServiceAccountTokenCommand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public createToken(serviceAccountId: number, addServiceAccountTokenCommand?: AddServiceAccountTokenCommand, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).createToken(serviceAccountId, addServiceAccountTokenCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:delete` scope: `serviceaccounts:id:1` (single service account)
     * @summary Delete service account
     * @param {number} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public deleteServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteServiceAccount(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
     * @summary DeleteToken deletes service account tokens
     * @param {number} tokenId 
     * @param {number} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public deleteToken(tokenId: number, serviceAccountId: number, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).deleteToken(tokenId, serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `global:serviceaccounts:id:1` (single service account)  Requires basic authentication and that the authenticated user is a Grafana Admin.
     * @summary Get service account tokens
     * @param {number} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public listTokens(serviceAccountId: number, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).listTokens(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:id:1` (single service account)
     * @summary Get single serviceaccount by Id
     * @param {number} serviceAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public retrieveServiceAccount(serviceAccountId: number, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).retrieveServiceAccount(serviceAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:read` scope: `serviceaccounts:*`
     * @summary Search service accounts with paging
     * @param {boolean} [disabled] 
     * @param {boolean} [expiredTokens] 
     * @param {string} [query] It will return results where the query value is contained in one of the name. Query values with spaces need to be URL encoded.
     * @param {number} [perpage] The default value is 1000.
     * @param {number} [page] The default value is 1.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public searchOrgServiceAccountsWithPaging(disabled?: boolean, expiredTokens?: boolean, query?: string, perpage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).searchOrgServiceAccountsWithPaging(disabled, expiredTokens, query, perpage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Required permissions (See note in the [introduction](https://grafana.com/docs/grafana/latest/developers/http_api/serviceaccount/#service-account-api) for an explanation): action: `serviceaccounts:write` scope: `serviceaccounts:id:1` (single service account)
     * @summary Update service account
     * @param {number} serviceAccountId 
     * @param {UpdateServiceAccountForm} [updateServiceAccountForm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceAccountsApi
     */
    public updateServiceAccount(serviceAccountId: number, updateServiceAccountForm?: UpdateServiceAccountForm, options?: RawAxiosRequestConfig) {
        return ServiceAccountsApiFp(this.configuration).updateServiceAccount(serviceAccountId, updateServiceAccountForm, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SignedInUserApi - axios parameter creator
 * @export
 */
export const SignedInUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the password for the user.
         * @summary Change Password.
         * @param {ChangeUserPasswordCommand} changeUserPasswordCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword: async (changeUserPasswordCommand: ChangeUserPasswordCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changeUserPasswordCommand' is not null or undefined
            assertParamExists('changeUserPassword', 'changeUserPasswordCommand', changeUserPasswordCommand)
            const localVarPath = `/user/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeUserPasswordCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Clear user help flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearHelpFlags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/helpflags/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get (current authenticated user)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all organizations of the current user.
         * @summary Organizations of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUserOrgList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all teams that the current user is member of.
         * @summary Teams that the actual User is member of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUserTeamList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
         * @summary Auth tokens of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthTokens: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/auth-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch user quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuotas: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/quotas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
         * @summary Revoke an auth token of the actual User.
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserAuthToken: async (revokeAuthTokenCmd: RevokeAuthTokenCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'revokeAuthTokenCmd' is not null or undefined
            assertParamExists('revokeUserAuthToken', 'revokeAuthTokenCmd', revokeAuthTokenCmd)
            const localVarPath = `/user/revoke-auth-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeAuthTokenCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set user help flag.
         * @param {string} flagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHelpFlag: async (flagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flagId' is not null or undefined
            assertParamExists('setHelpFlag', 'flagId', flagId)
            const localVarPath = `/user/helpflags/{flag_id}`
                .replace(`{${"flag_id"}}`, encodeURIComponent(String(flagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        starDashboard: async (dashboardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('starDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/user/stars/dashboard/{dashboard_id}`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starDashboardByUID: async (dashboardUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('starDashboardByUID', 'dashboardUid', dashboardUid)
            const localVarPath = `/user/stars/dashboard/uid/{dashboard_uid}`
                .replace(`{${"dashboard_uid"}}`, encodeURIComponent(String(dashboardUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        unstarDashboard: async (dashboardId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists('unstarDashboard', 'dashboardId', dashboardId)
            const localVarPath = `/user/stars/dashboard/{dashboard_id}`
                .replace(`{${"dashboard_id"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarDashboardByUID: async (dashboardUid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dashboardUid' is not null or undefined
            assertParamExists('unstarDashboardByUID', 'dashboardUid', dashboardUid)
            const localVarPath = `/user/stars/dashboard/uid/{dashboard_uid}`
                .replace(`{${"dashboard_uid"}}`, encodeURIComponent(String(dashboardUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update signed in User.
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignedInUser: async (updateUserCommand: UpdateUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserCommand' is not null or undefined
            assertParamExists('updateSignedInUser', 'updateUserCommand', updateUserCommand)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Switch user context to the given organization.
         * @summary Switch user context for signed in user.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetUsingOrg: async (orgId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('userSetUsingOrg', 'orgId', orgId)
            const localVarPath = `/user/using/{org_id}`
                .replace(`{${"org_id"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignedInUserApi - functional programming interface
 * @export
 */
export const SignedInUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SignedInUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the password for the user.
         * @summary Change Password.
         * @param {ChangeUserPasswordCommand} changeUserPasswordCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeUserPassword(changeUserPasswordCommand: ChangeUserPasswordCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserPassword(changeUserPasswordCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.changeUserPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Clear user help flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearHelpFlags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClearHelpFlags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearHelpFlags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.clearHelpFlags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get (current authenticated user)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignedInUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignedInUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.getSignedInUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of all organizations of the current user.
         * @summary Organizations of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignedInUserOrgList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOrgDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignedInUserOrgList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.getSignedInUserOrgList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of all teams that the current user is member of.
         * @summary Teams that the actual User is member of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignedInUserTeamList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSignedInUserTeamList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.getSignedInUserTeamList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
         * @summary Auth tokens of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAuthTokens(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAuthTokens(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.getUserAuthTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch user quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserQuotas(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuotaDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserQuotas(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.getUserQuotas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
         * @summary Revoke an auth token of the actual User.
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserAuthToken(revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserAuthToken(revokeAuthTokenCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.revokeUserAuthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set user help flag.
         * @param {string} flagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setHelpFlag(flagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClearHelpFlags200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setHelpFlag(flagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.setHelpFlag']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async starDashboard(dashboardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starDashboard(dashboardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.starDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starDashboardByUID(dashboardUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.starDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async unstarDashboard(dashboardId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstarDashboard(dashboardId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.unstarDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unstarDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unstarDashboardByUID(dashboardUid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.unstarDashboardByUID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update signed in User.
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSignedInUser(updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSignedInUser(updateUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.updateSignedInUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Switch user context to the given organization.
         * @summary Switch user context for signed in user.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSetUsingOrg(orgId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSetUsingOrg(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SignedInUserApi.userSetUsingOrg']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SignedInUserApi - factory interface
 * @export
 */
export const SignedInUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SignedInUserApiFp(configuration)
    return {
        /**
         * Changes the password for the user.
         * @summary Change Password.
         * @param {ChangeUserPasswordCommand} changeUserPasswordCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeUserPassword(changeUserPasswordCommand: ChangeUserPasswordCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.changeUserPassword(changeUserPasswordCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Clear user help flag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearHelpFlags(options?: RawAxiosRequestConfig): AxiosPromise<ClearHelpFlags200Response> {
            return localVarFp.clearHelpFlags(options).then((request) => request(axios, basePath));
        },
        /**
         * Get (current authenticated user)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUser(options?: RawAxiosRequestConfig): AxiosPromise<UserProfileDTO> {
            return localVarFp.getSignedInUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of all organizations of the current user.
         * @summary Organizations of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUserOrgList(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOrgDTO>> {
            return localVarFp.getSignedInUserOrgList(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of all teams that the current user is member of.
         * @summary Teams that the actual User is member of.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignedInUserTeamList(options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDTO>> {
            return localVarFp.getSignedInUserTeamList(options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
         * @summary Auth tokens of the actual User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAuthTokens(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserToken>> {
            return localVarFp.getUserAuthTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch user quota.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuotas(options?: RawAxiosRequestConfig): AxiosPromise<Array<QuotaDTO>> {
            return localVarFp.getUserQuotas(options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
         * @summary Revoke an auth token of the actual User.
         * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserAuthToken(revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.revokeUserAuthToken(revokeAuthTokenCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set user help flag.
         * @param {string} flagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setHelpFlag(flagId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClearHelpFlags200Response> {
            return localVarFp.setHelpFlag(flagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        starDashboard(dashboardId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.starDashboard(dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stars the given Dashboard for the actual user.
         * @summary Star a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.starDashboardByUID(dashboardUid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        unstarDashboard(dashboardId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.unstarDashboard(dashboardId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the starring of the given Dashboard for the actual user.
         * @summary Unstar a dashboard.
         * @param {string} dashboardUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unstarDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.unstarDashboardByUID(dashboardUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update signed in User.
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSignedInUser(updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateSignedInUser(updateUserCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * Switch user context to the given organization.
         * @summary Switch user context for signed in user.
         * @param {number} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSetUsingOrg(orgId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.userSetUsingOrg(orgId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SignedInUserApi - object-oriented interface
 * @export
 * @class SignedInUserApi
 * @extends {BaseAPI}
 */
export class SignedInUserApi extends BaseAPI {
    /**
     * Changes the password for the user.
     * @summary Change Password.
     * @param {ChangeUserPasswordCommand} changeUserPasswordCommand To change the email, name, login, theme, provide another one.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public changeUserPassword(changeUserPasswordCommand: ChangeUserPasswordCommand, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).changeUserPassword(changeUserPasswordCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Clear user help flag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public clearHelpFlags(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).clearHelpFlags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get (current authenticated user)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public getSignedInUser(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).getSignedInUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of all organizations of the current user.
     * @summary Organizations of the actual User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public getSignedInUserOrgList(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).getSignedInUserOrgList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of all teams that the current user is member of.
     * @summary Teams that the actual User is member of.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public getSignedInUserTeamList(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).getSignedInUserTeamList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of all auth tokens (devices) that the actual user currently have logged in from.
     * @summary Auth tokens of the actual User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public getUserAuthTokens(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).getUserAuthTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch user quota.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public getUserQuotas(options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).getUserQuotas(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revokes the given auth token (device) for the actual user. User of issued auth token (device) will no longer be logged in and will be required to authenticate again upon next activity.
     * @summary Revoke an auth token of the actual User.
     * @param {RevokeAuthTokenCmd} revokeAuthTokenCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public revokeUserAuthToken(revokeAuthTokenCmd: RevokeAuthTokenCmd, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).revokeUserAuthToken(revokeAuthTokenCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set user help flag.
     * @param {string} flagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public setHelpFlag(flagId: string, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).setHelpFlag(flagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stars the given Dashboard for the actual user.
     * @summary Star a dashboard.
     * @param {string} dashboardId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public starDashboard(dashboardId: string, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).starDashboard(dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stars the given Dashboard for the actual user.
     * @summary Star a dashboard.
     * @param {string} dashboardUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public starDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).starDashboardByUID(dashboardUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the starring of the given Dashboard for the actual user.
     * @summary Unstar a dashboard.
     * @param {string} dashboardId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public unstarDashboard(dashboardId: string, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).unstarDashboard(dashboardId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes the starring of the given Dashboard for the actual user.
     * @summary Unstar a dashboard.
     * @param {string} dashboardUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public unstarDashboardByUID(dashboardUid: string, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).unstarDashboardByUID(dashboardUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update signed in User.
     * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public updateSignedInUser(updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).updateSignedInUser(updateUserCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Switch user context to the given organization.
     * @summary Switch user context for signed in user.
     * @param {number} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignedInUserApi
     */
    public userSetUsingOrg(orgId: number, options?: RawAxiosRequestConfig) {
        return SignedInUserApiFp(this.configuration).userSetUsingOrg(orgId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SigningKeysApi - axios parameter creator
 * @export
 */
export const SigningKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Required permissions None
         * @summary Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveJWKS: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/signing-keys/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SigningKeysApi - functional programming interface
 * @export
 */
export const SigningKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SigningKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Required permissions None
         * @summary Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveJWKS(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveJWKS200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveJWKS(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SigningKeysApi.retrieveJWKS']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SigningKeysApi - factory interface
 * @export
 */
export const SigningKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SigningKeysApiFp(configuration)
    return {
        /**
         * Required permissions None
         * @summary Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveJWKS(options?: RawAxiosRequestConfig): AxiosPromise<RetrieveJWKS200Response> {
            return localVarFp.retrieveJWKS(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SigningKeysApi - object-oriented interface
 * @export
 * @class SigningKeysApi
 * @extends {BaseAPI}
 */
export class SigningKeysApi extends BaseAPI {
    /**
     * Required permissions None
     * @summary Get JSON Web Key Set (JWKS) with all the keys that can be used to verify tokens (public keys)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigningKeysApi
     */
    public retrieveJWKS(options?: RawAxiosRequestConfig) {
        return SigningKeysApiFp(this.configuration).retrieveJWKS(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnapshotsApi - axios parameter creator
 * @export
 */
export const SnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
         * @param {CreateDashboardSnapshotCommand} createDashboardSnapshotCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardSnapshot: async (createDashboardSnapshotCommand: CreateDashboardSnapshotCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDashboardSnapshotCommand' is not null or undefined
            assertParamExists('createDashboardSnapshot', 'createDashboardSnapshotCommand', createDashboardSnapshotCommand)
            const localVarPath = `/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDashboardSnapshotCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardSnapshot: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteDashboardSnapshot', 'key', key)
            const localVarPath = `/snapshots/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary Delete Snapshot by deleteKey.
         * @param {string} deleteKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardSnapshotByDeleteKey: async (deleteKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteKey' is not null or undefined
            assertParamExists('deleteDashboardSnapshotByDeleteKey', 'deleteKey', deleteKey)
            const localVarPath = `/snapshots-delete/{deleteKey}`
                .replace(`{${"deleteKey"}}`, encodeURIComponent(String(deleteKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardSnapshot: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getDashboardSnapshot', 'key', key)
            const localVarPath = `/snapshots/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get snapshot sharing settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharingOptions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/snapshot/shared-options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List snapshots.
         * @param {string} [query] Search Query
         * @param {number} [limit] Limit the number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDashboardSnapshots: async (query?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotsApi - functional programming interface
 * @export
 */
export const SnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
         * @param {CreateDashboardSnapshotCommand} createDashboardSnapshotCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardSnapshot(createDashboardSnapshotCommand: CreateDashboardSnapshotCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDashboardSnapshot200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardSnapshot(createDashboardSnapshotCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.createDashboardSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboardSnapshot(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboardSnapshot(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.deleteDashboardSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary Delete Snapshot by deleteKey.
         * @param {string} deleteKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDashboardSnapshotByDeleteKey(deleteKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDashboardSnapshotByDeleteKey(deleteKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.deleteDashboardSnapshotByDeleteKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardSnapshot(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardSnapshot(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.getDashboardSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get snapshot sharing settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSharingOptions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSharingOptions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSharingOptions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.getSharingOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List snapshots.
         * @param {string} [query] Search Query
         * @param {number} [limit] Limit the number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDashboardSnapshots(query?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DashboardSnapshotDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDashboardSnapshots(query, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotsApi.searchDashboardSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnapshotsApi - factory interface
 * @export
 */
export const SnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotsApiFp(configuration)
    return {
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
         * @param {CreateDashboardSnapshotCommand} createDashboardSnapshotCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardSnapshot(createDashboardSnapshotCommand: CreateDashboardSnapshotCommand, options?: RawAxiosRequestConfig): AxiosPromise<CreateDashboardSnapshot200Response> {
            return localVarFp.createDashboardSnapshot(createDashboardSnapshotCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardSnapshot(key: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteDashboardSnapshot(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Snapshot public mode should be enabled or authentication is required.
         * @summary Delete Snapshot by deleteKey.
         * @param {string} deleteKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardSnapshotByDeleteKey(deleteKey: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteDashboardSnapshotByDeleteKey(deleteKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Snapshot by Key.
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardSnapshot(key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDashboardSnapshot(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get snapshot sharing settings.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSharingOptions(options?: RawAxiosRequestConfig): AxiosPromise<GetSharingOptions200Response> {
            return localVarFp.getSharingOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List snapshots.
         * @param {string} [query] Search Query
         * @param {number} [limit] Limit the number of returned results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDashboardSnapshots(query?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DashboardSnapshotDTO>> {
            return localVarFp.searchDashboardSnapshots(query, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotsApi - object-oriented interface
 * @export
 * @class SnapshotsApi
 * @extends {BaseAPI}
 */
export class SnapshotsApi extends BaseAPI {
    /**
     * Snapshot public mode should be enabled or authentication is required.
     * @summary When creating a snapshot using the API, you have to provide the full dashboard payload including the snapshot data. This endpoint is designed for the Grafana UI.
     * @param {CreateDashboardSnapshotCommand} createDashboardSnapshotCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public createDashboardSnapshot(createDashboardSnapshotCommand: CreateDashboardSnapshotCommand, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).createDashboardSnapshot(createDashboardSnapshotCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Snapshot by Key.
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public deleteDashboardSnapshot(key: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).deleteDashboardSnapshot(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Snapshot public mode should be enabled or authentication is required.
     * @summary Delete Snapshot by deleteKey.
     * @param {string} deleteKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public deleteDashboardSnapshotByDeleteKey(deleteKey: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).deleteDashboardSnapshotByDeleteKey(deleteKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Snapshot by Key.
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getDashboardSnapshot(key: string, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).getDashboardSnapshot(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get snapshot sharing settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public getSharingOptions(options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).getSharingOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List snapshots.
     * @param {string} [query] Search Query
     * @param {number} [limit] Limit the number of returned results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotsApi
     */
    public searchDashboardSnapshots(query?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return SnapshotsApiFp(this.configuration).searchDashboardSnapshots(query, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SsoSettingsApi - axios parameter creator
 * @export
 */
export const SsoSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary Get an SSO Settings entry by Key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderSettings: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProviderSettings', 'key', key)
            const localVarPath = `/v1/sso-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary List all SSO Settings entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllProvidersSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sso-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Remove SSO Settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProviderSettings: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('removeProviderSettings', 'key', key)
            const localVarPath = `/v1/sso-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Update SSO Settings
         * @param {string} key 
         * @param {UpdateProviderSettingsRequest} updateProviderSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProviderSettings: async (key: string, updateProviderSettingsRequest: UpdateProviderSettingsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateProviderSettings', 'key', key)
            // verify required parameter 'updateProviderSettingsRequest' is not null or undefined
            assertParamExists('updateProviderSettings', 'updateProviderSettingsRequest', updateProviderSettingsRequest)
            const localVarPath = `/v1/sso-settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProviderSettingsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsoSettingsApi - functional programming interface
 * @export
 */
export const SsoSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SsoSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary Get an SSO Settings entry by Key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviderSettings(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllProvidersSettings200ResponseInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviderSettings(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoSettingsApi.getProviderSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary List all SSO Settings entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllProvidersSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAllProvidersSettings200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllProvidersSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoSettingsApi.listAllProvidersSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Remove SSO Settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProviderSettings(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProviderSettings(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoSettingsApi.removeProviderSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Update SSO Settings
         * @param {string} key 
         * @param {UpdateProviderSettingsRequest} updateProviderSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProviderSettings(key: string, updateProviderSettingsRequest: UpdateProviderSettingsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProviderSettings(key, updateProviderSettingsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SsoSettingsApi.updateProviderSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SsoSettingsApi - factory interface
 * @export
 */
export const SsoSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SsoSettingsApiFp(configuration)
    return {
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary Get an SSO Settings entry by Key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviderSettings(key: string, options?: RawAxiosRequestConfig): AxiosPromise<ListAllProvidersSettings200ResponseInner> {
            return localVarFp.getProviderSettings(key, options).then((request) => request(axios, basePath));
        },
        /**
         * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
         * @summary List all SSO Settings entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllProvidersSettings(options?: RawAxiosRequestConfig): AxiosPromise<Array<ListAllProvidersSettings200ResponseInner>> {
            return localVarFp.listAllProvidersSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Remove SSO Settings
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProviderSettings(key: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeProviderSettings(key, options).then((request) => request(axios, basePath));
        },
        /**
         * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
         * @summary Update SSO Settings
         * @param {string} key 
         * @param {UpdateProviderSettingsRequest} updateProviderSettingsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProviderSettings(key: string, updateProviderSettingsRequest: UpdateProviderSettingsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateProviderSettings(key, updateProviderSettingsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SsoSettingsApi - object-oriented interface
 * @export
 * @class SsoSettingsApi
 * @extends {BaseAPI}
 */
export class SsoSettingsApi extends BaseAPI {
    /**
     * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
     * @summary Get an SSO Settings entry by Key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoSettingsApi
     */
    public getProviderSettings(key: string, options?: RawAxiosRequestConfig) {
        return SsoSettingsApiFp(this.configuration).getProviderSettings(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You need to have a permission with action `settings:read` with scope `settings:auth.<provider>:*`.
     * @summary List all SSO Settings entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoSettingsApi
     */
    public listAllProvidersSettings(options?: RawAxiosRequestConfig) {
        return SsoSettingsApiFp(this.configuration).listAllProvidersSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
     * @summary Remove SSO Settings
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoSettingsApi
     */
    public removeProviderSettings(key: string, options?: RawAxiosRequestConfig) {
        return SsoSettingsApiFp(this.configuration).removeProviderSettings(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inserts or updates the SSO Settings for a provider.  You need to have a permission with action `settings:write` and scope `settings:auth.<provider>:*`.
     * @summary Update SSO Settings
     * @param {string} key 
     * @param {UpdateProviderSettingsRequest} updateProviderSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsoSettingsApi
     */
    public updateProviderSettings(key: string, updateProviderSettingsRequest: UpdateProviderSettingsRequest, options?: RawAxiosRequestConfig) {
        return SsoSettingsApiFp(this.configuration).updateProviderSettings(key, updateProviderSettingsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SyncTeamGroupsApi - axios parameter creator
 * @export
 */
export const SyncTeamGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamGroupApi: async (teamId: number, teamGroupMapping: TeamGroupMapping, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamGroupApi', 'teamId', teamId)
            // verify required parameter 'teamGroupMapping' is not null or undefined
            assertParamExists('addTeamGroupApi', 'teamGroupMapping', teamGroupMapping)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teamGroupMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamGroupsApi: async (teamId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamGroupsApi', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamGroupApiQuery: async (teamId: number, groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamGroupApiQuery', 'teamId', teamId)
            const localVarPath = `/teams/{teamId}/groups`
                .replace(`{${"teamId"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SyncTeamGroupsApi - functional programming interface
 * @export
 */
export const SyncTeamGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SyncTeamGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamGroupApi(teamId, teamGroupMapping, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncTeamGroupsApi.addTeamGroupApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamGroupDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamGroupsApi(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncTeamGroupsApi.getTeamGroupsApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamGroupApiQuery(teamId, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SyncTeamGroupsApi.removeTeamGroupApiQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SyncTeamGroupsApi - factory interface
 * @export
 */
export const SyncTeamGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SyncTeamGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add External Group.
         * @param {number} teamId 
         * @param {TeamGroupMapping} teamGroupMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addTeamGroupApi(teamId, teamGroupMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get External Groups.
         * @param {number} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamGroupDTO>> {
            return localVarFp.getTeamGroupsApi(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove External Group.
         * @param {number} teamId 
         * @param {string} [groupId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeTeamGroupApiQuery(teamId, groupId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SyncTeamGroupsApi - object-oriented interface
 * @export
 * @class SyncTeamGroupsApi
 * @extends {BaseAPI}
 */
export class SyncTeamGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Add External Group.
     * @param {number} teamId 
     * @param {TeamGroupMapping} teamGroupMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncTeamGroupsApi
     */
    public addTeamGroupApi(teamId: number, teamGroupMapping: TeamGroupMapping, options?: RawAxiosRequestConfig) {
        return SyncTeamGroupsApiFp(this.configuration).addTeamGroupApi(teamId, teamGroupMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get External Groups.
     * @param {number} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncTeamGroupsApi
     */
    public getTeamGroupsApi(teamId: number, options?: RawAxiosRequestConfig) {
        return SyncTeamGroupsApiFp(this.configuration).getTeamGroupsApi(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove External Group.
     * @param {number} teamId 
     * @param {string} [groupId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SyncTeamGroupsApi
     */
    public removeTeamGroupApiQuery(teamId: number, groupId?: string, options?: RawAxiosRequestConfig) {
        return SyncTeamGroupsApiFp(this.configuration).removeTeamGroupApiQuery(teamId, groupId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Team Member.
         * @param {string} teamId 
         * @param {AddTeamMemberCommand} addTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamMember: async (teamId: string, addTeamMemberCommand: AddTeamMemberCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('addTeamMember', 'teamId', teamId)
            // verify required parameter 'addTeamMemberCommand' is not null or undefined
            assertParamExists('addTeamMember', 'addTeamMemberCommand', addTeamMemberCommand)
            const localVarPath = `/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTeamMemberCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Team.
         * @param {CreateTeamCommand} createTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam: async (createTeamCommand: CreateTeamCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTeamCommand' is not null or undefined
            assertParamExists('createTeam', 'createTeamCommand', createTeamCommand)
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTeamCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamByID: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('deleteTeamByID', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamByID: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamByID', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Team Members.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamMembers', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Team Preferences.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPreferences: async (teamId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('getTeamPreferences', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/preferences`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove Member From Team.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamMember: async (teamId: string, userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('removeTeamMember', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeTeamMember', 'userId', userId)
            const localVarPath = `/teams/{team_id}/members/{user_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Team Search With Paging.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams: async (page?: number, perpage?: number, name?: string, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes user emails, and updates team members and admins to the provided lists of users. Any current team members and admins not in the provided lists will be removed.
         * @summary Set team memberships.
         * @param {string} teamId 
         * @param {SetTeamMembershipsCommand} setTeamMembershipsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamMemberships: async (teamId: string, setTeamMembershipsCommand: SetTeamMembershipsCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('setTeamMemberships', 'teamId', teamId)
            // verify required parameter 'setTeamMembershipsCommand' is not null or undefined
            assertParamExists('setTeamMemberships', 'setTeamMembershipsCommand', setTeamMembershipsCommand)
            const localVarPath = `/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setTeamMembershipsCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Team.
         * @param {string} teamId 
         * @param {UpdateTeamCommand} updateTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam: async (teamId: string, updateTeamCommand: UpdateTeamCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeam', 'teamId', teamId)
            // verify required parameter 'updateTeamCommand' is not null or undefined
            assertParamExists('updateTeam', 'updateTeamCommand', updateTeamCommand)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Team Member.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {UpdateTeamMemberCommand} updateTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember: async (teamId: string, userId: number, updateTeamMemberCommand: UpdateTeamMemberCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeamMember', 'teamId', teamId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateTeamMember', 'userId', userId)
            // verify required parameter 'updateTeamMemberCommand' is not null or undefined
            assertParamExists('updateTeamMember', 'updateTeamMemberCommand', updateTeamMemberCommand)
            const localVarPath = `/teams/{team_id}/members/{user_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTeamMemberCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Team Preferences.
         * @param {string} teamId 
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamPreferences: async (teamId: string, updatePrefsCmd: UpdatePrefsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('updateTeamPreferences', 'teamId', teamId)
            // verify required parameter 'updatePrefsCmd' is not null or undefined
            assertParamExists('updateTeamPreferences', 'updatePrefsCmd', updatePrefsCmd)
            const localVarPath = `/teams/{team_id}/preferences`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePrefsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Team Member.
         * @param {string} teamId 
         * @param {AddTeamMemberCommand} addTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTeamMember(teamId: string, addTeamMemberCommand: AddTeamMemberCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTeamMember(teamId, addTeamMemberCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.addTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Team.
         * @param {CreateTeamCommand} createTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTeam(createTeamCommand: CreateTeamCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTeam200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTeam(createTeamCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.createTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTeamByID(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeamByID(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.deleteTeamByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamByID(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamByID(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.getTeamByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Team Members.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamMembers(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamMemberDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamMembers(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.getTeamMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Team Preferences.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTeamPreferences(teamId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamPreferences(teamId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.getTeamPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove Member From Team.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeTeamMember(teamId: string, userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamMember(teamId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.removeTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Team Search With Paging.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTeams(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchTeamQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchTeams(page, perpage, name, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.searchTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes user emails, and updates team members and admins to the provided lists of users. Any current team members and admins not in the provided lists will be removed.
         * @summary Set team memberships.
         * @param {string} teamId 
         * @param {SetTeamMembershipsCommand} setTeamMembershipsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTeamMemberships(teamId: string, setTeamMembershipsCommand: SetTeamMembershipsCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTeamMemberships(teamId, setTeamMembershipsCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.setTeamMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Team.
         * @param {string} teamId 
         * @param {UpdateTeamCommand} updateTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeam(teamId: string, updateTeamCommand: UpdateTeamCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeam(teamId, updateTeamCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.updateTeam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Team Member.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {UpdateTeamMemberCommand} updateTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamMember(teamId: string, userId: number, updateTeamMemberCommand: UpdateTeamMemberCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamMember(teamId, userId, updateTeamMemberCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.updateTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Team Preferences.
         * @param {string} teamId 
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTeamPreferences(teamId: string, updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTeamPreferences(teamId, updatePrefsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TeamsApi.updateTeamPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Team Member.
         * @param {string} teamId 
         * @param {AddTeamMemberCommand} addTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTeamMember(teamId: string, addTeamMemberCommand: AddTeamMemberCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.addTeamMember(teamId, addTeamMemberCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Team.
         * @param {CreateTeamCommand} createTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTeam(createTeamCommand: CreateTeamCommand, options?: RawAxiosRequestConfig): AxiosPromise<CreateTeam200Response> {
            return localVarFp.createTeam(createTeamCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTeamByID(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.deleteTeamByID(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Team By ID.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamByID(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<TeamDTO> {
            return localVarFp.getTeamByID(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Team Members.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamMembers(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamMemberDTO>> {
            return localVarFp.getTeamMembers(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Team Preferences.
         * @param {string} teamId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTeamPreferences(teamId: string, options?: RawAxiosRequestConfig): AxiosPromise<Preferences> {
            return localVarFp.getTeamPreferences(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove Member From Team.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeTeamMember(teamId: string, userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.removeTeamMember(teamId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Team Search With Paging.
         * @param {number} [page] 
         * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
         * @param {string} [name] 
         * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTeams(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<SearchTeamQueryResult> {
            return localVarFp.searchTeams(page, perpage, name, query, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes user emails, and updates team members and admins to the provided lists of users. Any current team members and admins not in the provided lists will be removed.
         * @summary Set team memberships.
         * @param {string} teamId 
         * @param {SetTeamMembershipsCommand} setTeamMembershipsCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTeamMemberships(teamId: string, setTeamMembershipsCommand: SetTeamMembershipsCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.setTeamMemberships(teamId, setTeamMembershipsCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Team.
         * @param {string} teamId 
         * @param {UpdateTeamCommand} updateTeamCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeam(teamId: string, updateTeamCommand: UpdateTeamCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateTeam(teamId, updateTeamCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Team Member.
         * @param {string} teamId 
         * @param {number} userId 
         * @param {UpdateTeamMemberCommand} updateTeamMemberCommand 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamMember(teamId: string, userId: number, updateTeamMemberCommand: UpdateTeamMemberCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateTeamMember(teamId, userId, updateTeamMemberCommand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Team Preferences.
         * @param {string} teamId 
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTeamPreferences(teamId: string, updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateTeamPreferences(teamId, updatePrefsCmd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * 
     * @summary Add Team Member.
     * @param {string} teamId 
     * @param {AddTeamMemberCommand} addTeamMemberCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public addTeamMember(teamId: string, addTeamMemberCommand: AddTeamMemberCommand, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).addTeamMember(teamId, addTeamMemberCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Team.
     * @param {CreateTeamCommand} createTeamCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public createTeam(createTeamCommand: CreateTeamCommand, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).createTeam(createTeamCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Team By ID.
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public deleteTeamByID(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).deleteTeamByID(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Team By ID.
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamByID(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamByID(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Team Members.
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamMembers(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamMembers(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Team Preferences.
     * @param {string} teamId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public getTeamPreferences(teamId: string, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).getTeamPreferences(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove Member From Team.
     * @param {string} teamId 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public removeTeamMember(teamId: string, userId: number, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).removeTeamMember(teamId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Team Search With Paging.
     * @param {number} [page] 
     * @param {number} [perpage] Number of items per page The totalCount field in the response can be used for pagination list E.g. if totalCount is equal to 100 teams and the perpage parameter is set to 10 then there are 10 pages of teams.
     * @param {string} [name] 
     * @param {string} [query] If set it will return results where the query value is contained in the name field. Query values with spaces need to be URL encoded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public searchTeams(page?: number, perpage?: number, name?: string, query?: string, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).searchTeams(page, perpage, name, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes user emails, and updates team members and admins to the provided lists of users. Any current team members and admins not in the provided lists will be removed.
     * @summary Set team memberships.
     * @param {string} teamId 
     * @param {SetTeamMembershipsCommand} setTeamMembershipsCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public setTeamMemberships(teamId: string, setTeamMembershipsCommand: SetTeamMembershipsCommand, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).setTeamMemberships(teamId, setTeamMembershipsCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Team.
     * @param {string} teamId 
     * @param {UpdateTeamCommand} updateTeamCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeam(teamId: string, updateTeamCommand: UpdateTeamCommand, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).updateTeam(teamId, updateTeamCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Team Member.
     * @param {string} teamId 
     * @param {number} userId 
     * @param {UpdateTeamMemberCommand} updateTeamMemberCommand 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeamMember(teamId: string, userId: number, updateTeamMemberCommand: UpdateTeamMemberCommand, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).updateTeamMember(teamId, userId, updateTeamMemberCommand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Team Preferences.
     * @param {string} teamId 
     * @param {UpdatePrefsCmd} updatePrefsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public updateTeamPreferences(teamId: string, updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig) {
        return TeamsApiFp(this.configuration).updateTeamPreferences(teamId, updatePrefsCmd, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the email of user given a verification code.
         * @summary Update user email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/email/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Update the email of user given a verification code.
         * @summary Update user email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserEmail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUserEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Update the email of user given a verification code.
         * @summary Update user email.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserEmail(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUserEmail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Update the email of user given a verification code.
     * @summary Update user email.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserEmail(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserEmail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserPreferencesApi - axios parameter creator
 * @export
 */
export const UserPreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch user preferences.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserPreferences: async (patchPrefsCmd: PatchPrefsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patchPrefsCmd' is not null or undefined
            assertParamExists('patchUserPreferences', 'patchPrefsCmd', patchPrefsCmd)
            const localVarPath = `/user/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchPrefsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
         * @summary Update user preferences.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences: async (updatePrefsCmd: UpdatePrefsCmd, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePrefsCmd' is not null or undefined
            assertParamExists('updateUserPreferences', 'updatePrefsCmd', updatePrefsCmd)
            const localVarPath = `/user/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePrefsCmd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserPreferencesApi - functional programming interface
 * @export
 */
export const UserPreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserPreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.getUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch user preferences.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserPreferences(patchPrefsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.patchUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
         * @summary Update user preferences.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPreferences(updatePrefsCmd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserPreferencesApi.updateUserPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserPreferencesApi - factory interface
 * @export
 */
export const UserPreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserPreferencesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences(options?: RawAxiosRequestConfig): AxiosPromise<Preferences> {
            return localVarFp.getUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch user preferences.
         * @param {PatchPrefsCmd} patchPrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.patchUserPreferences(patchPrefsCmd, options).then((request) => request(axios, basePath));
        },
        /**
         * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
         * @summary Update user preferences.
         * @param {UpdatePrefsCmd} updatePrefsCmd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateUserPreferences(updatePrefsCmd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserPreferencesApi - object-oriented interface
 * @export
 * @class UserPreferencesApi
 * @extends {BaseAPI}
 */
export class UserPreferencesApi extends BaseAPI {
    /**
     * 
     * @summary Get user preferences.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public getUserPreferences(options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).getUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch user preferences.
     * @param {PatchPrefsCmd} patchPrefsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public patchUserPreferences(patchPrefsCmd: PatchPrefsCmd, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).patchUserPreferences(patchPrefsCmd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Omitting a key (`theme`, `homeDashboardId`, `timezone`) will cause the current value to be replaced with the system default value.
     * @summary Update user preferences.
     * @param {UpdatePrefsCmd} updatePrefsCmd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserPreferencesApi
     */
    public updateUserPreferences(updatePrefsCmd: UpdatePrefsCmd, options?: RawAxiosRequestConfig) {
        return UserPreferencesApiFp(this.configuration).updateUserPreferences(updatePrefsCmd, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user by id.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByID: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserByID', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by login or email.
         * @param {string} loginOrEmail loginOrEmail of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByLoginOrEmail: async (loginOrEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginOrEmail' is not null or undefined
            assertParamExists('getUserByLoginOrEmail', 'loginOrEmail', loginOrEmail)
            const localVarPath = `/users/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (loginOrEmail !== undefined) {
                localVarQueryParameter['loginOrEmail'] = loginOrEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get organizations for user identified by id.
         * @summary Get organizations for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrgList: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserOrgList', 'userId', userId)
            const localVarPath = `/users/{user_id}/orgs`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get teams for user identified by id.
         * @summary Get teams for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTeams: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTeams', 'userId', userId)
            const localVarPath = `/users/{user_id}/teams`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all users that the authenticated user has permission to view, admin permission required.
         * @summary Get users.
         * @param {number} [perpage] Limit the maximum number of users to return per page
         * @param {number} [page] Page index for starting fetching users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (perpage?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (perpage !== undefined) {
                localVarQueryParameter['perpage'] = perpage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users with paging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersWithPaging: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user identified by id.
         * @summary Update user.
         * @param {number} userId 
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: number, updateUserCommand: UpdateUserCommand, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'updateUserCommand' is not null or undefined
            assertParamExists('updateUser', 'updateUserCommand', updateUserCommand)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserCommand, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user by id.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByID(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByID(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserByID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user by login or email.
         * @param {string} loginOrEmail loginOrEmail of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByLoginOrEmail(loginOrEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByLoginOrEmail(loginOrEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserByLoginOrEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get organizations for user identified by id.
         * @summary Get organizations for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserOrgList(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOrgDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOrgList(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserOrgList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get teams for user identified by id.
         * @summary Get teams for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTeams(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TeamDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTeams(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserTeams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all users that the authenticated user has permission to view, admin permission required.
         * @summary Get users.
         * @param {number} [perpage] Limit the maximum number of users to return per page
         * @param {number} [page] Page index for starting fetching users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(perpage?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSearchHitDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(perpage, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get users with paging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsersWithPaging(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchUserQueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsersWithPaging(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsersWithPaging']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the user identified by id.
         * @summary Update user.
         * @param {number} userId 
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: number, updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, updateUserCommand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user by id.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByID(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileDTO> {
            return localVarFp.getUserByID(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by login or email.
         * @param {string} loginOrEmail loginOrEmail of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByLoginOrEmail(loginOrEmail: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileDTO> {
            return localVarFp.getUserByLoginOrEmail(loginOrEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Get organizations for user identified by id.
         * @summary Get organizations for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrgList(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOrgDTO>> {
            return localVarFp.getUserOrgList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get teams for user identified by id.
         * @summary Get teams for user.
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTeams(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TeamDTO>> {
            return localVarFp.getUserTeams(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all users that the authenticated user has permission to view, admin permission required.
         * @summary Get users.
         * @param {number} [perpage] Limit the maximum number of users to return per page
         * @param {number} [page] Page index for starting fetching users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(perpage?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSearchHitDTO>> {
            return localVarFp.searchUsers(perpage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users with paging.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsersWithPaging(options?: RawAxiosRequestConfig): AxiosPromise<SearchUserQueryResult> {
            return localVarFp.searchUsersWithPaging(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user identified by id.
         * @summary Update user.
         * @param {number} userId 
         * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponseBody> {
            return localVarFp.updateUser(userId, updateUserCommand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get user by id.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByID(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByID(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by login or email.
     * @param {string} loginOrEmail loginOrEmail of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByLoginOrEmail(loginOrEmail: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserByLoginOrEmail(loginOrEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get organizations for user identified by id.
     * @summary Get organizations for user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserOrgList(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserOrgList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get teams for user identified by id.
     * @summary Get teams for user.
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserTeams(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTeams(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all users that the authenticated user has permission to view, admin permission required.
     * @summary Get users.
     * @param {number} [perpage] Limit the maximum number of users to return per page
     * @param {number} [page] Page index for starting fetching users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(perpage?: number, page?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(perpage, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users with paging.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsersWithPaging(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsersWithPaging(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user identified by id.
     * @summary Update user.
     * @param {number} userId 
     * @param {UpdateUserCommand} updateUserCommand To change the email, name, login, theme, provide another one.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: number, updateUserCommand: UpdateUserCommand, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUser(userId, updateUserCommand, options).then((request) => request(this.axios, this.basePath));
    }
}



